[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.483407229204301,
            10.520398210608256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.483407229204301,
            10.520398210608256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.483407229204301,
            10.520398210608256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and solution diversity, then applies a novel 3-opt-like local search with a guided diversification step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful modification\n\n    # Step 1: Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Step 2: Recombine segments in a novel way\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Guided diversification - swap nodes based on distance matrices\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    return new_order\n\n",
        "score": [
            6.638091370909896,
            6.868138406096367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful modification\n\n    # Step 1: Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Step 2: Recombine segments in a novel way\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Guided diversification - swap nodes based on distance matrices\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    return new_order\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion with a distance-aware swap, prioritizing solutions with non-dominated objectives and leveraging both distance matrices to guide the search for improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: multi-segment inversion + distance-aware swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Multi-segment inversion\n    seg_length = max(2, n // 4)\n    start = random.randint(0, n - seg_length - 1)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Distance-aware swap\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.1184091247001025,
            6.7379645120966485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: multi-segment inversion + distance-aware swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Multi-segment inversion\n    seg_length = max(2, n // 4)\n    start = random.randint(0, n - seg_length - 1)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Distance-aware swap\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining segment rotation and alternating path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    weighted_scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search: segment rotation + alternating path reversal\n    if n > 3:\n        # Segment rotation: move a segment to a different position\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Alternating path reversal: reverse every alternate segment\n        for i in range(2, n, 4):\n            if i + 1 < n:\n                new_solution[i:i+2] = new_solution[i:i+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.3523383024578175,
            8.976304681616655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    weighted_scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search: segment rotation + alternating path reversal\n    if n > 3:\n        # Segment rotation: move a segment to a different position\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Alternating path reversal: reverse every alternate segment\n        for i in range(2, n, 4):\n            if i + 1 < n:\n                new_solution[i:i+2] = new_solution[i:i+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.2639558858526865,
            6.456350947292165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge swapping + segment rotation\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge swapping: swap two edges between i and j, and k and l\n        if i != k and j != l:\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        # Segment rotation: rotate a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[m:p+1]\n        rotation_point = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation_point:], segment[:rotation_point]])\n        new_solution[m:p+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            10.468177984765227,
            10.588042137223267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge swapping + segment rotation\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge swapping: swap two edges between i and j, and k and l\n        if i != k and j != l:\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        # Segment rotation: rotate a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[m:p+1]\n        rotation_point = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation_point:], segment[:rotation_point]])\n        new_solution[m:p+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel local search operator that combines random segment swapping with a biased edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate a selection metric combining objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.std(archive[i][0]) for i in range(len(archive))])\n        selection_metric = (objectives[:, 0] + objectives[:, 1]) * diversity\n        selected_idx = np.argmax(selection_metric)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Random segment swapping\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        if len(segment1) == len(segment2):\n            new_solution[a:b+1], new_solution[c:d+1] = segment2, segment1\n\n        # Biased edge insertion based on distance matrices\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            if dist1 > dist2:\n                # Insert node1 after node2 if it improves the second objective\n                new_solution = np.concatenate([new_solution[:j+1], [node1], new_solution[j+1:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node1)[0][0])\n            else:\n                # Insert node2 after node1 if it improves the first objective\n                new_solution = np.concatenate([new_solution[:i+1], [node2], new_solution[i+1:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node2)[0][0])\n\n    return new_solution\n\n",
        "score": [
            10.48627912470911,
            10.667076106015934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate a selection metric combining objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.std(archive[i][0]) for i in range(len(archive))])\n        selection_metric = (objectives[:, 0] + objectives[:, 1]) * diversity\n        selected_idx = np.argmax(selection_metric)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Random segment swapping\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        if len(segment1) == len(segment2):\n            new_solution[a:b+1], new_solution[c:d+1] = segment2, segment1\n\n        # Biased edge insertion based on distance matrices\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            if dist1 > dist2:\n                # Insert node1 after node2 if it improves the second objective\n                new_solution = np.concatenate([new_solution[:j+1], [node1], new_solution[j+1:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node1)[0][0])\n            else:\n                # Insert node2 after node1 if it improves the first objective\n                new_solution = np.concatenate([new_solution[:i+1], [node2], new_solution[i+1:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node2)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.446352880272228,
            6.4478337409255095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining adaptive segment relocation and partial tour reconstruction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    centroid = objectives.mean(axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential insertion points based on both objectives\n        insertion_scores = []\n        for i in range(n):\n            if i >= a and i <= b:\n                insertion_scores.append(-float('inf'))\n                continue\n\n            # Calculate cost for both objectives\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n            elif i == n-1:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n\n            # Score based on both objectives (weighted by segment length)\n            score = - (cost1 + cost2) / (b - a + 1)\n            insertion_scores.append(score)\n\n        # Select best insertion point\n        best_i = np.argmax(insertion_scores)\n        if best_i < a:\n            new_solution = np.concatenate([new_solution[:best_i+1], segment, new_solution[best_i+1:a], new_solution[b+1:]])\n        elif best_i > b:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:best_i+1], segment, new_solution[best_i+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Partial tour reconstruction: reverse segments with probability based on their length\n        for _ in range(min(3, n//2)):\n            c, d = sorted(random.sample(range(n), 2))\n            if random.random() < 0.5 * (d - c + 1) / n:\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.4454656218727635,
            7.410546466004641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    centroid = objectives.mean(axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential insertion points based on both objectives\n        insertion_scores = []\n        for i in range(n):\n            if i >= a and i <= b:\n                insertion_scores.append(-float('inf'))\n                continue\n\n            # Calculate cost for both objectives\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n            elif i == n-1:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n\n            # Score based on both objectives (weighted by segment length)\n            score = - (cost1 + cost2) / (b - a + 1)\n            insertion_scores.append(score)\n\n        # Select best insertion point\n        best_i = np.argmax(insertion_scores)\n        if best_i < a:\n            new_solution = np.concatenate([new_solution[:best_i+1], segment, new_solution[best_i+1:a], new_solution[b+1:]])\n        elif best_i > b:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:best_i+1], segment, new_solution[best_i+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Partial tour reconstruction: reverse segments with probability based on their length\n        for _ in range(min(3, n//2)):\n            c, d = sorted(random.sample(range(n), 2))\n            if random.random() < 0.5 * (d - c + 1) / n:\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search combining node relocation and edge swapping to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance to select a solution in less explored regions\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives, axis=0)\n        crowding_distance = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            for j in range(1, len(archive)-1):\n                crowding_distance[sorted_indices[j, i]] += (objectives[sorted_indices[j+1, i], i] - objectives[sorted_indices[j-1, i], i]) / (objectives[sorted_indices[-1, i], i] - objectives[sorted_indices[0, i], i] + 1e-6)\n\n        selected_idx = np.argmax(crowding_distance)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: node relocation + edge swapping\n    if n > 3:\n        # Node relocation: move a random node to a new position\n        a, b = random.sample(range(1, n), 2)\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n        # Edge swapping: swap two random edges\n        c, d = sorted(random.sample(range(1, n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            8.081271322251432,
            8.389968258747013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance to select a solution in less explored regions\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives, axis=0)\n        crowding_distance = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            for j in range(1, len(archive)-1):\n                crowding_distance[sorted_indices[j, i]] += (objectives[sorted_indices[j+1, i], i] - objectives[sorted_indices[j-1, i], i]) / (objectives[sorted_indices[-1, i], i] - objectives[sorted_indices[0, i], i] + 1e-6)\n\n        selected_idx = np.argmax(crowding_distance)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: node relocation + edge swapping\n    if n > 3:\n        # Node relocation: move a random node to a new position\n        a, b = random.sample(range(1, n), 2)\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n        # Edge swapping: swap two random edges\n        c, d = sorted(random.sample(range(1, n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        objectives = np.array([obj for _, obj in archive])\n        scores = objectives[:, 0] + objectives[:, 1]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        if a != c and b != d:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        e, f = sorted(random.sample(range(1, n), 2))\n        new_solution[e:f+1] = np.roll(new_solution[e:f+1], 1)\n\n    return new_solution\n\n",
        "score": [
            6.764651269708752,
            6.949026613018829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        objectives = np.array([obj for _, obj in archive])\n        scores = objectives[:, 0] + objectives[:, 1]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        if a != c and b != d:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        e, f = sorted(random.sample(range(1, n), 2))\n        new_solution[e:f+1] = np.roll(new_solution[e:f+1], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: move segment between i and j to after k\n        if i != k and j != l:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        # Segment reversal: reverse a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        new_solution[m:p+1] = new_solution[m:p+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score and applies a novel local search operator combining path decomposition and segment reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path decomposition: split the tour into two segments\n    split_pos = np.random.randint(1, N-1)\n    segment1 = new_solution[:split_pos]\n    segment2 = new_solution[split_pos:]\n\n    # Reorder segments with probability based on their relative costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(len(segment2)))\n\n    if (cost1_seg1 + cost2_seg1) > (cost1_seg2 + cost2_seg2):\n        new_solution = np.concatenate([segment2, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment2])\n\n    # Segment reordering: reverse a random segment with probability based on its cost\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1)) + \\\n                   sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n    if np.random.rand() < (segment_cost / (sum(new_solution[1:]) + 1e-6)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.981988373014443,
            7.66974688648388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path decomposition: split the tour into two segments\n    split_pos = np.random.randint(1, N-1)\n    segment1 = new_solution[:split_pos]\n    segment2 = new_solution[split_pos:]\n\n    # Reorder segments with probability based on their relative costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(len(segment2)))\n\n    if (cost1_seg1 + cost2_seg1) > (cost1_seg2 + cost2_seg2):\n        new_solution = np.concatenate([segment2, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment2])\n\n    # Segment reordering: reverse a random segment with probability based on its cost\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1)) + \\\n                   sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n    if np.random.rand() < (segment_cost / (sum(new_solution[1:]) + 1e-6)):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment reversal and adaptive edge relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive selection\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive edge relocation\n    for _ in range(2):\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j and (i != j+1 and j != i+1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.022942942004352,
            6.4919563094590735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive selection\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive edge relocation\n    for _ in range(2):\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j and (i != j+1 and j != i+1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives and compute combined score\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion operator\n    if N > 2:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            10.491919975628658,
            10.591170305345528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives and compute combined score\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion operator\n    if N > 2:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and solution diversity, then applies a novel 3-opt-like local search with a guided diversification step to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful modification\n\n    # Step 1: Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Step 2: Recombine segments in a novel way\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Guided diversification - swap nodes based on distance matrices\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    return new_order\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel 4-opt-like local search with adaptive segment rearrangement and guided node swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Select four random segments\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:d],\n        new_solution[d:]\n    ]\n\n    # Step 2: Rearrange segments in a novel pattern\n    new_order = np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]])\n\n    # Step 3: Adaptive guided swaps\n    for i in range(n):\n        if random.random() < 0.4:\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    # Step 4: Local segment inversion\n    if random.random() < 0.3:\n        x, y = sorted(random.sample(range(1, n-1), 2))\n        new_order[x:y] = new_order[x:y][::-1]\n\n    return new_order\n\n",
        "score": [
            6.383012759151082,
            6.57127879868931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Select four random segments\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:d],\n        new_solution[d:]\n    ]\n\n    # Step 2: Rearrange segments in a novel pattern\n    new_order = np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]])\n\n    # Step 3: Adaptive guided swaps\n    for i in range(n):\n        if random.random() < 0.4:\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    # Step 4: Local segment inversion\n    if random.random() < 0.3:\n        x, y = sorted(random.sample(range(1, n-1), 2))\n        new_order[x:y] = new_order[x:y][::-1]\n\n    return new_order\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score weighted by the inverse of the normalized objective values, then applies a novel local search strategy combining edge reversal and segment rotation with adaptive segment sizes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    weighted_scores = []\n    for i, (o1, o2) in enumerate(objectives):\n        norm1 = (o1 - min1) / (max1 - min1 + 1e-6)\n        norm2 = (o2 - min2) / (max2 - min2 + 1e-6)\n        score = 0.7 * (1 - norm1) + 0.3 * (1 - norm2)  # Higher weight for better objective 1\n        weighted_scores.append((score, i))\n\n    weighted_scores.sort(reverse=True)\n    base_solution = archive[weighted_scores[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_size = max(2, N // 4)\n    a = np.random.randint(0, N - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal with adaptive segment size\n    segment_size = max(2, N // 3)\n    x = np.random.randint(0, N - segment_size)\n    y = x + segment_size - 1\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.105817909283184,
            8.488978238382913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    weighted_scores = []\n    for i, (o1, o2) in enumerate(objectives):\n        norm1 = (o1 - min1) / (max1 - min1 + 1e-6)\n        norm2 = (o2 - min2) / (max2 - min2 + 1e-6)\n        score = 0.7 * (1 - norm1) + 0.3 * (1 - norm2)  # Higher weight for better objective 1\n        weighted_scores.append((score, i))\n\n    weighted_scores.sort(reverse=True)\n    base_solution = archive[weighted_scores[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_size = max(2, N // 4)\n    a = np.random.randint(0, N - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal with adaptive segment size\n    segment_size = max(2, N // 3)\n    x = np.random.randint(0, N - segment_size)\n    y = x + segment_size - 1\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, node chain insertion, and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node chain insertion\n    if np.random.rand() < 0.3:\n        chain_length = min(3, N // 2)\n        chain = np.random.choice(new_solution, size=chain_length, replace=False)\n        pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:]])\n        new_solution = np.unique(new_solution)\n\n    # Edge reversal with feasibility check\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j - i) > 1:\n            new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n",
        "score": [
            6.231663226219714,
            6.107997658428222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node chain insertion\n    if np.random.rand() < 0.3:\n        chain_length = min(3, N // 2)\n        chain = np.random.choice(new_solution, size=chain_length, replace=False)\n        pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:]])\n        new_solution = np.unique(new_solution)\n\n    # Edge reversal with feasibility check\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j - i) > 1:\n            new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a multi-segment inversion with a distance-aware swap, prioritizing solutions with non-dominated objectives and leveraging both distance matrices to guide the search for improved solutions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: multi-segment inversion + distance-aware swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Multi-segment inversion\n    seg_length = max(2, n // 4)\n    start = random.randint(0, n - seg_length - 1)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Distance-aware swap\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm combines a distance-aware segment relocation with a multi-objective edge flipping strategy, prioritizing solutions with balanced objective improvements while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Distance-aware segment relocation\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best relocation point based on combined distance\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue\n\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Multi-objective edge flipping\n    if N >= 3:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i or j == (i+1) % N or j == (i-1) % N:\n            j = np.random.randint(0, N)\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 * 0.9 and new_cost1 < old_cost1 * 1.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.287792477765741,
            10.386382544753742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Distance-aware segment relocation\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best relocation point based on combined distance\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue\n\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Multi-objective edge flipping\n    if N >= 3:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i or j == (i+1) % N or j == (i-1) % N:\n            j = np.random.randint(0, N)\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 * 0.9 and new_cost1 < old_cost1 * 1.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment transposition and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment transposition: swap two non-overlapping segments\n        seg1_start, seg1_end = sorted(np.random.choice(range(n-1), size=2, replace=False))\n        seg1_length = np.random.randint(1, (n - seg1_end) // 2 + 1)\n        seg2_start = np.random.randint(seg1_end + 1, n - seg1_length + 1)\n        seg2_length = seg1_length\n\n        seg1 = new_solution[seg1_start:seg1_start+seg1_length]\n        seg2 = new_solution[seg2_start:seg2_start+seg2_length]\n\n        new_solution[seg1_start:seg1_start+seg1_length] = seg2\n        new_solution[seg2_start:seg2_start+seg2_length] = seg1\n\n        # Adaptive edge swapping: swap edges based on their contribution to the total cost\n        total_cost_1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        total_cost_2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(min(3, n//2)):\n            i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n            if i == j or j == (i+1)%n or i == (j+1)%n:\n                continue\n\n            # Calculate cost difference if we swap edges\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.494622708473536,
            10.604538408287658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment transposition: swap two non-overlapping segments\n        seg1_start, seg1_end = sorted(np.random.choice(range(n-1), size=2, replace=False))\n        seg1_length = np.random.randint(1, (n - seg1_end) // 2 + 1)\n        seg2_start = np.random.randint(seg1_end + 1, n - seg1_length + 1)\n        seg2_length = seg1_length\n\n        seg1 = new_solution[seg1_start:seg1_start+seg1_length]\n        seg2 = new_solution[seg2_start:seg2_start+seg2_length]\n\n        new_solution[seg1_start:seg1_start+seg1_length] = seg2\n        new_solution[seg2_start:seg2_start+seg2_length] = seg1\n\n        # Adaptive edge swapping: swap edges based on their contribution to the total cost\n        total_cost_1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        total_cost_2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(min(3, n//2)):\n            i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n            if i == j or j == (i+1)%n or i == (j+1)%n:\n                continue\n\n            # Calculate cost difference if we swap edges\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with alternating segment reversal and edge contraction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with node reordering\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            new_solution[i] = node_j\n            new_solution[j] = node_i\n\n    # Node reordering with alternating segments\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            6.325400618025214,
            5.7434767355675245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with node reordering\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            new_solution[i] = node_j\n            new_solution[j] = node_i\n\n    # Node reordering with alternating segments\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with alternating segment reversal and edge contraction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with node reordering\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            new_solution[i] = node_j\n            new_solution[j] = node_i\n\n    # Node reordering with alternating segments\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            6.325400618025214,
            5.7434767355675245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with node reordering\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            new_solution[i] = node_j\n            new_solution[j] = node_i\n\n    # Node reordering with alternating segments\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.398611415506409,
            5.191416454747967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.398611415506409,
            5.191416454747967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search combining multi-segment shuffling with adaptive edge contraction and expansion, while ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment shuffling\n    num_segments = np.random.randint(2, min(5, N//2))\n    segment_indices = sorted(np.random.choice(range(1, N), size=num_segments, replace=False))\n    segments = np.split(new_solution, segment_indices)\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Adaptive edge contraction and expansion\n    for i in range(N):\n        if np.random.rand() < 0.2:  # 20% chance to contract/expand\n            j = (i + 1) % N\n            if np.random.rand() < 0.5:  # Contract (remove and insert elsewhere)\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                insert_pos = np.random.randint(N-1)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n            else:  # Expand (duplicate and insert)\n                node = new_solution[i]\n                insert_pos = np.random.randint(N)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure solution remains valid\n    while len(new_solution) != N:\n        if len(new_solution) > N:\n            # Remove duplicates\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n        else:\n            # Add missing nodes\n            missing = np.setdiff1d(np.arange(N), new_solution)\n            insert_pos = np.random.randint(len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], missing, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.494643182456743,
            6.757668489943577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment shuffling\n    num_segments = np.random.randint(2, min(5, N//2))\n    segment_indices = sorted(np.random.choice(range(1, N), size=num_segments, replace=False))\n    segments = np.split(new_solution, segment_indices)\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Adaptive edge contraction and expansion\n    for i in range(N):\n        if np.random.rand() < 0.2:  # 20% chance to contract/expand\n            j = (i + 1) % N\n            if np.random.rand() < 0.5:  # Contract (remove and insert elsewhere)\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                insert_pos = np.random.randint(N-1)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n            else:  # Expand (duplicate and insert)\n                node = new_solution[i]\n                insert_pos = np.random.randint(N)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure solution remains valid\n    while len(new_solution) != N:\n        if len(new_solution) > N:\n            # Remove duplicates\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n        else:\n            # Add missing nodes\n            missing = np.setdiff1d(np.arange(N), new_solution)\n            insert_pos = np.random.randint(len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], missing, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining node swapping, segment insertion, and adaptive edge flipping to generate a neighbor solution with probabilistic checks for feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node swapping with probabilistic check\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment insertion with edge flipping\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n            if np.random.rand() < 0.4 and insert_pos > 0 and insert_pos < len(new_solution)-1:\n                new_solution[insert_pos], new_solution[insert_pos-1] = new_solution[insert_pos-1], new_solution[insert_pos]\n\n    return new_solution\n\n",
        "score": [
            8.063901498019312,
            8.601480728545877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node swapping with probabilistic check\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment insertion with edge flipping\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n            if np.random.rand() < 0.4 and insert_pos > 0 and insert_pos < len(new_solution)-1:\n                new_solution[insert_pos], new_solution[insert_pos-1] = new_solution[insert_pos-1], new_solution[insert_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The heuristic selects a solution from the archive based on a normalized objective score combining both objectives with adaptive weights, then applies a hybrid local search combining segment reinsertion with probabilistic node swapping and adaptive edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reinsertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge reversal\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + 1) % N\n                if j != 0 or i != N-1:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.336344112188879,
            6.723219531992748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reinsertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge reversal\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + 1) % N\n                if j != 0 or i != N-1:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining segment reversal, node reinsertion, and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if np.random.rand() < 0.4:\n        segment_length = min(3, N // 2)\n        a = np.random.randint(0, N - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node reinsertion with objective-aware selection\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, N - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge swapping based on objective differences\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.321251073921056,
            6.193761774680785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if np.random.rand() < 0.4:\n        segment_length = min(3, N // 2)\n        a = np.random.randint(0, N - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node reinsertion with objective-aware selection\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, N - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge swapping based on objective differences\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment rotation, node swapping, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4 and N > 3:\n        pos = np.random.randint(1, N-1)\n        new_solution[pos-1], new_solution[pos] = new_solution[pos], new_solution[pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.233451099269033,
            6.698666172275774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4 and N > 3:\n        pos = np.random.randint(1, N-1)\n        new_solution[pos-1], new_solution[pos] = new_solution[pos], new_solution[pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The new algorithm selects a solution based on a non-linear combination of objectives and applies a hybrid local search combining segment reversal and edge swapping while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0]**2 + x[1][1]**2)  # Weighted sum of squares\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + edge swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping if beneficial\n    if np.random.rand() < 0.7:  # Higher probability for edge swapping\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.185969536936016,
            5.950410480496441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0]**2 + x[1][1]**2)  # Weighted sum of squares\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + edge swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Random segment reversal\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping if beneficial\n    if np.random.rand() < 0.7:  # Higher probability for edge swapping\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a hybrid local search combining adaptive segment swapping, alternating path inversion, and cross-segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swapping\n    if np.random.rand() < 0.4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Alternating path inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if (a + b) % 2 == 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Cross-segment relocation\n    if np.random.rand() < 0.6:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    return new_solution\n\n",
        "score": [
            6.324491033980452,
            5.972716570277487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swapping\n    if np.random.rand() < 0.4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Alternating path inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if (a + b) % 2 == 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Cross-segment relocation\n    if np.random.rand() < 0.6:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The heuristic selects the best solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, dynamic edge insertion, and objective-aware node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(N - k)\n        segment = new_solution[start:start+k]\n        rotation = np.random.randint(1, k)\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+k] = rotated\n\n    # Dynamic edge insertion\n    if np.random.rand() < 0.3:\n        u, v = np.random.choice(N, size=2, replace=False)\n        u_pos, v_pos = np.where(new_solution == u)[0][0], np.where(new_solution == v)[0][0]\n        if abs(u_pos - v_pos) > 1:\n            if u_pos < v_pos:\n                new_solution[u_pos+1:v_pos] = np.roll(new_solution[u_pos+1:v_pos], -1)\n            else:\n                new_solution[v_pos+1:u_pos] = np.roll(new_solution[v_pos+1:u_pos], 1)\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n        cost1_before = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%N]] + \\\n                       distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%N]]\n        cost1_after = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%N]] + \\\n                      distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%N]]\n        cost2_before = distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%N]] + \\\n                       distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%N]]\n        cost2_after = distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%N]] + \\\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%N]]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.3732297426603655,
            6.4103710243875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with objective-aware selection\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(N - k)\n        segment = new_solution[start:start+k]\n        rotation = np.random.randint(1, k)\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+k] = rotated\n\n    # Dynamic edge insertion\n    if np.random.rand() < 0.3:\n        u, v = np.random.choice(N, size=2, replace=False)\n        u_pos, v_pos = np.where(new_solution == u)[0][0], np.where(new_solution == v)[0][0]\n        if abs(u_pos - v_pos) > 1:\n            if u_pos < v_pos:\n                new_solution[u_pos+1:v_pos] = np.roll(new_solution[u_pos+1:v_pos], -1)\n            else:\n                new_solution[v_pos+1:u_pos] = np.roll(new_solution[v_pos+1:u_pos], 1)\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n        cost1_before = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%N]] + \\\n                       distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%N]]\n        cost1_after = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%N]] + \\\n                      distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%N]]\n        cost2_before = distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%N]] + \\\n                       distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%N]]\n        cost2_after = distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%N]] + \\\n                     distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%N]]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining random segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_idx = 0\n    for i in range(1, len(archive)):\n        if archive[i][1][0] <= archive[base_idx][1][0] and archive[i][1][1] <= archive[base_idx][1][1]:\n            if archive[i][1][0] < archive[base_idx][1][0] or archive[i][1][1] < archive[base_idx][1][1]:\n                base_idx = i\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: random segment reversal or node insertion\n    if np.random.rand() < 0.6:  # 60% chance for segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # 40% chance for node insertion\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            6.145040931074577,
            9.748539121816819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    base_idx = 0\n    for i in range(1, len(archive)):\n        if archive[i][1][0] <= archive[base_idx][1][0] and archive[i][1][1] <= archive[base_idx][1][1]:\n            if archive[i][1][0] < archive[base_idx][1][0] or archive[i][1][1] < archive[base_idx][1][1]:\n                base_idx = i\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: random segment reversal or node insertion\n    if np.random.rand() < 0.6:  # 60% chance for segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # 40% chance for node insertion\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid objective score combining both objectives, then applies a novel local search combining segment rotation, node exchange, and edge contraction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    combined_scores = objectives[:, 0] * 0.4 + objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            rotated = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != 0 and j != N-1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.3 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and a != 0 and b != N-1:\n            new_segment = np.concatenate([new_solution[:a], new_solution[b:]])\n            new_solution = np.concatenate([new_segment[:a], new_solution[a:b+1], new_segment[a:]])\n\n    return new_solution\n\n",
        "score": [
            7.123620548615142,
            5.759904264684398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    combined_scores = objectives[:, 0] * 0.4 + objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            rotated = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != 0 and j != N-1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.3 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and a != 0 and b != N-1:\n            new_segment = np.concatenate([new_solution[:a], new_solution[b:]])\n            new_solution = np.concatenate([new_segment[:a], new_solution[a:b+1], new_segment[a:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The heuristic selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining alternating path reversal, cross-segment insertion, and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    if len(archive) > 1:\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = archive[i-1][1] if i > 0 else (float('inf'), float('inf'))\n            right = archive[(i+1)%len(archive)][1]\n            dist = (abs(archive[i][1][0] - left[0]) + abs(archive[i][1][0] - right[0]),\n                    abs(archive[i][1][1] - left[1]) + abs(archive[i][1][1] - right[1]))\n            crowding_distances.append(sum(dist))\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating path reversal with segment selection\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        new_solution[a:b] = segment\n\n    # Cross-segment insertion with alternating segments\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        if np.random.rand() < 0.5:\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n        else:\n            new_solution[a:c] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Segment rotation with alternating node swaps\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.concatenate([segment[1:], segment[:1]])\n        if np.random.rand() < 0.5:\n            i, j = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.248937432531002,
            6.0487997585185225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    if len(archive) > 1:\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = archive[i-1][1] if i > 0 else (float('inf'), float('inf'))\n            right = archive[(i+1)%len(archive)][1]\n            dist = (abs(archive[i][1][0] - left[0]) + abs(archive[i][1][0] - right[0]),\n                    abs(archive[i][1][1] - left[1]) + abs(archive[i][1][1] - right[1]))\n            crowding_distances.append(sum(dist))\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating path reversal with segment selection\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        new_solution[a:b] = segment\n\n    # Cross-segment insertion with alternating segments\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        if np.random.rand() < 0.5:\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n        else:\n            new_solution[a:c] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Segment rotation with alternating node swaps\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.concatenate([segment[1:], segment[:1]])\n        if np.random.rand() < 0.5:\n            i, j = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0:\n        max_obj1 = 1\n    if max_obj2 == 0:\n        max_obj2 = 1\n\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment reversal + node swapping\n    if np.random.rand() < 0.7:  # 70% chance to reverse segment\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.3:  # 30% chance to swap nodes\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.530779296567838,
            10.63002967409757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0:\n        max_obj1 = 1\n    if max_obj2 == 0:\n        max_obj2 = 1\n\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment reversal + node swapping\n    if np.random.rand() < 0.7:  # 70% chance to reverse segment\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.3:  # 30% chance to swap nodes\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest combined objective score, then applies a hybrid local search combining segment rotation, node swapping with proximity-based checks, and probabilistic edge flips to ensure feasibility and diversity while avoiding direct segment reversal or node relocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node swapping with proximity-based checks\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[node_j, node_i]\n        dist2 = distance_matrix_2[node_i, node_j] + distance_matrix_2[node_j, node_i]\n        if dist1 < np.mean(distance_matrix_1) or dist2 < np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge flip\n    if np.random.rand() < 0.3 and N > 3:\n        pos = np.random.randint(1, N-1)\n        if (distance_matrix_1[new_solution[pos-1], new_solution[pos+1]] + distance_matrix_2[new_solution[pos-1], new_solution[pos+1]]) < \\\n           (distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n            distance_matrix_1[new_solution[pos], new_solution[pos+1]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]):\n            new_solution[pos-1], new_solution[pos+1] = new_solution[pos+1], new_solution[pos-1]\n\n    return new_solution\n\n",
        "score": [
            10.459953394159465,
            10.547628423266271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node swapping with proximity-based checks\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[node_j, node_i]\n        dist2 = distance_matrix_2[node_i, node_j] + distance_matrix_2[node_j, node_i]\n        if dist1 < np.mean(distance_matrix_1) or dist2 < np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge flip\n    if np.random.rand() < 0.3 and N > 3:\n        pos = np.random.randint(1, N-1)\n        if (distance_matrix_1[new_solution[pos-1], new_solution[pos+1]] + distance_matrix_2[new_solution[pos-1], new_solution[pos+1]]) < \\\n           (distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n            distance_matrix_1[new_solution[pos], new_solution[pos+1]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]):\n            new_solution[pos-1], new_solution[pos+1] = new_solution[pos+1], new_solution[pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining node chain reversal, segment swapping, and probabilistic edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = float('inf')\n        crowding_dist[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            chain_length = np.random.randint(1, min(5, b - a + 1))\n            new_solution[a:a+chain_length] = new_solution[a:a+chain_length][::-1]\n\n    # Segment swapping\n    if np.random.rand() < 0.5:\n        a1, b1 = sorted(np.random.choice(N, size=2, replace=False))\n        a2, b2 = sorted(np.random.choice(N, size=2, replace=False))\n        if (b1 - a1) == (b2 - a2):\n            segment1 = new_solution[a1:b1+1].copy()\n            segment2 = new_solution[a2:b2+1].copy()\n            new_solution[a1:b1+1] = segment2\n            new_solution[a2:b2+1] = segment1\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = (i + np.random.randint(1, min(5, N//2))) % N\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.037825399177482,
            9.1802599343421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = float('inf')\n        crowding_dist[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            chain_length = np.random.randint(1, min(5, b - a + 1))\n            new_solution[a:a+chain_length] = new_solution[a:a+chain_length][::-1]\n\n    # Segment swapping\n    if np.random.rand() < 0.5:\n        a1, b1 = sorted(np.random.choice(N, size=2, replace=False))\n        a2, b2 = sorted(np.random.choice(N, size=2, replace=False))\n        if (b1 - a1) == (b2 - a2):\n            segment1 = new_solution[a1:b1+1].copy()\n            segment2 = new_solution[a2:b2+1].copy()\n            new_solution[a1:b1+1] = segment2\n            new_solution[a2:b2+1] = segment1\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = (i + np.random.randint(1, min(5, N//2))) % N\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity metrics, then applies a hybrid local search combining segment rotation, node insertion with edge swapping, and probabilistic inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n\n    # Add diversity consideration\n    if len(archive) > 1:\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        combined_scores = (combined_scores * 0.7) + (crowding * 0.3)\n\n    base_idx = np.argmin(combined_scores)\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic inversion\n    if np.random.rand() < 0.3 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.264269307950858,
            6.8614398585435925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n\n    # Add diversity consideration\n    if len(archive) > 1:\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        combined_scores = (combined_scores * 0.7) + (crowding * 0.3)\n\n    base_idx = np.argmin(combined_scores)\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic inversion\n    if np.random.rand() < 0.3 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            5.900424285316852,
            6.089619878083495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0] / max_cost1) + (x[1][1] / max_cost2))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge reversal + segment rotation\n    if np.random.rand() < 0.3:  # 30% chance to reverse a segment\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Rotate a segment\n    if np.random.rand() < 0.4:  # 40% chance to rotate\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n",
        "score": [
            5.908685108791174,
            6.283478050407191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0] / max_cost1) + (x[1][1] / max_cost2))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge reversal + segment rotation\n    if np.random.rand() < 0.3:  # 30% chance to reverse a segment\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Rotate a segment\n    if np.random.rand() < 0.4:  # 40% chance to rotate\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and solution diversity, then applies a novel local search combining adaptive segment insertion and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    improvement_scores = []\n    for sol, obj in archive:\n        total_dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_scores.append((total_dist1 + total_dist2) - (obj[0] + obj[1]))\n\n    if len(archive) > 1 and np.random.rand() < 0.6:\n        base_idx = np.argmax(improvement_scores)\n    else:\n        base_idx = 0\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_pos = np.random.randint(0, N - segment_length + 1)\n        if new_pos != start:\n            new_solution = np.concatenate([\n                new_solution[:start], new_solution[start+segment_length:],\n                segment\n            ])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n    # Probabilistic node swapping with distance awareness\n    if np.random.rand() < 0.7:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + np.random.randint(1, min(3, N//2))) % N\n                if j != i:\n                    # Only swap if it improves at least one objective\n                    old_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n                    new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%N]])\n                    if new_dist1 < old_dist1 or np.random.rand() < 0.3:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.018539887329771,
            7.502911611702826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    improvement_scores = []\n    for sol, obj in archive:\n        total_dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_scores.append((total_dist1 + total_dist2) - (obj[0] + obj[1]))\n\n    if len(archive) > 1 and np.random.rand() < 0.6:\n        base_idx = np.argmax(improvement_scores)\n    else:\n        base_idx = 0\n\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_pos = np.random.randint(0, N - segment_length + 1)\n        if new_pos != start:\n            new_solution = np.concatenate([\n                new_solution[:start], new_solution[start+segment_length:],\n                segment\n            ])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n    # Probabilistic node swapping with distance awareness\n    if np.random.rand() < 0.7:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + np.random.randint(1, min(3, N//2))) % N\n                if j != i:\n                    # Only swap if it improves at least one objective\n                    old_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n                    new_dist1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%N]])\n                    if new_dist1 < old_dist1 or np.random.rand() < 0.3:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The new algorithm selects a solution from the archive based on a novel dominance score that balances objective improvements, then applies a hybrid local search combining alternating path inversion, segment shifting, and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_scores = []\n    for sol, obj in archive:\n        total_obj = sum(obj)\n        dominance = (obj[0] / total_obj) * (obj[1] / total_obj)\n        dominance_scores.append(dominance)\n    base_idx = np.argmax(dominance_scores)\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: alternating path inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n        if np.random.rand() < 0.3:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Segment shifting\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Adaptive node swapping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] < \\\n           distance_matrix_1[new_solution[i], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.628149269025162,
            7.68756965158239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_scores = []\n    for sol, obj in archive:\n        total_obj = sum(obj)\n        dominance = (obj[0] / total_obj) * (obj[1] / total_obj)\n        dominance_scores.append(dominance)\n    base_idx = np.argmax(dominance_scores)\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: alternating path inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n        if np.random.rand() < 0.3:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Segment shifting\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Adaptive node swapping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] < \\\n           distance_matrix_1[new_solution[i], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto dominance-based selection to prioritize non-dominated solutions, then applies a hybrid local search combining segment rotation and node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_idx = np.random.choice(non_dominated)\n    else:\n        base_idx = np.random.randint(len(archive))\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment rotation + node exchange\n    if np.random.rand() < 0.6:  # 60% chance for segment rotation\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:  # 40% chance for node exchange\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.434972609659483,
            7.047509715551572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_idx = np.random.choice(non_dominated)\n    else:\n        base_idx = np.random.randint(len(archive))\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment rotation + node exchange\n    if np.random.rand() < 0.6:  # 60% chance for segment rotation\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:  # 40% chance for node exchange\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining multi-segment shuffling with adaptive node insertion and probabilistic path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment shuffling\n    if np.random.rand() < 0.6:\n        num_segments = np.random.randint(2, min(4, N//3))\n        segment_indices = np.sort(np.random.choice(N, num_segments, replace=False))\n        segments = np.split(new_solution, segment_indices)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(0, N-1)\n        if new_pos != old_pos and new_pos != (old_pos + 1) % N:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            insertion_pos = new_pos if new_pos < old_pos else new_pos - 1\n            new_solution = np.concatenate([new_solution[:insertion_pos+1], [node], new_solution[insertion_pos+1:]])\n\n    # Probabilistic path reversal with objective-aware selection\n    if np.random.rand() < 0.3:\n        segment_length = np.random.randint(3, min(7, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n        # Reverse with higher probability if segment is improving in both objectives\n        if np.random.rand() < 0.7 or (cost1 > 0 and cost2 > 0):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.323086562215222,
            6.302643729113589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment shuffling\n    if np.random.rand() < 0.6:\n        num_segments = np.random.randint(2, min(4, N//3))\n        segment_indices = np.sort(np.random.choice(N, num_segments, replace=False))\n        segments = np.split(new_solution, segment_indices)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(0, N-1)\n        if new_pos != old_pos and new_pos != (old_pos + 1) % N:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            insertion_pos = new_pos if new_pos < old_pos else new_pos - 1\n            new_solution = np.concatenate([new_solution[:insertion_pos+1], [node], new_solution[insertion_pos+1:]])\n\n    # Probabilistic path reversal with objective-aware selection\n    if np.random.rand() < 0.3:\n        segment_length = np.random.randint(3, min(7, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n        # Reverse with higher probability if segment is improving in both objectives\n        if np.random.rand() < 0.7 or (cost1 > 0 and cost2 > 0):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The new algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_indices[0]] = float('inf')\n            crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge reversal + segment inversion\n    if np.random.rand() < 0.5:  # Edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted = segment[::-1]\n        new_solution[a:b+1] = inverted\n\n    # Randomly swap two nodes if beneficial\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            8.58776880701429,
            7.874047386104571
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_indices[0]] = float('inf')\n            crowding[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge reversal + segment inversion\n    if np.random.rand() < 0.5:  # Edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted = segment[::-1]\n        new_solution[a:b+1] = inverted\n\n    # Randomly swap two nodes if beneficial\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining alternating segment reversal, cross-segment relocation, and conditional node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a % 2 == 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Cross-segment relocation\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Conditional node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if (i + j) % 3 == 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.327717904854814,
            6.279760333738882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: max(x[1][0], x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a % 2 == 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Cross-segment relocation\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Conditional node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if (i + j) % 3 == 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and diversity, then applies a hybrid local search combining edge exchange, path inversion, and probabilistic node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = max(0, i-1)\n        right = min(len(archive)-1, i+1)\n        crowding_dist[i] = np.sum(norm_objectives[right] - norm_objectives[left])\n\n    combined_scores = 0.5 * crowding_dist + 0.3 * norm_objectives[:, 0] + 0.2 * norm_objectives[:, 1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Edge exchange with probabilistic check\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path inversion with segment selection\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = segment\n\n    # Probabilistic node swaps\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, size=2, replace=False)\n            if np.random.rand() < 0.3 * (1 - np.abs(i-j)/N):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.39754876972282,
            9.166469172855564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = max(0, i-1)\n        right = min(len(archive)-1, i+1)\n        crowding_dist[i] = np.sum(norm_objectives[right] - norm_objectives[left])\n\n    combined_scores = 0.5 * crowding_dist + 0.3 * norm_objectives[:, 0] + 0.2 * norm_objectives[:, 1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Edge exchange with probabilistic check\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path inversion with segment selection\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = segment\n\n    # Probabilistic node swaps\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, size=2, replace=False)\n            if np.random.rand() < 0.3 * (1 - np.abs(i-j)/N):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.7 for first objective, 0.3 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.383681529895855,
            9.079510318929984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.7 for first objective, 0.3 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.383681529895855,
            9.079510318929984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using crowding distance-based weights) and applies a hybrid local search combining segment insertion and edge exchange to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(costs[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] = (costs[sorted_indices[i+1], 0] - costs[sorted_indices[i-1], 0]) / (costs[sorted_indices[-1], 0] - costs[sorted_indices[0], 0] + 1e-8)\n\n    sorted_indices = np.argsort(costs[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] += (costs[sorted_indices[i+1], 1] - costs[sorted_indices[i-1], 1]) / (costs[sorted_indices[-1], 1] - costs[sorted_indices[0], 1] + 1e-8)\n\n    weights = crowding_distances / np.sum(crowding_distances)\n    selected = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment insertion\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge exchange\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.829897983805551,
            6.135429431920297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(costs[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] = (costs[sorted_indices[i+1], 0] - costs[sorted_indices[i-1], 0]) / (costs[sorted_indices[-1], 0] - costs[sorted_indices[0], 0] + 1e-8)\n\n    sorted_indices = np.argsort(costs[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] += (costs[sorted_indices[i+1], 1] - costs[sorted_indices[i-1], 1]) / (costs[sorted_indices[-1], 1] - costs[sorted_indices[0], 1] + 1e-8)\n\n    weights = crowding_distances / np.sum(crowding_distances)\n    selected = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment insertion\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge exchange\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node transposition, and probabilistic edge flipping with feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.linalg.norm(objectives - np.median(objectives, axis=0), axis=1)\n    base_solution = archive[np.argmax(diversity_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node transposition with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N-1)\n        if i > 0 and i < N-2:\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i+1] = new_solution[i+1], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            7.622083375671635,
            7.672270918812541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.linalg.norm(objectives - np.median(objectives, axis=0), axis=1)\n    base_solution = archive[np.argmax(diversity_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node transposition with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N-1)\n        if i > 0 and i < N-2:\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i+1] = new_solution[i+1], new_solution[i-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear combination of objective values, then applies a hybrid local search combining segment rotation and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] * obj[1] for _, obj in archive]  # Product of objectives\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment rotation or adaptive node swapping\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n    else:\n        # Adaptive node swapping\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N)) % N\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.978727078877309,
            6.0793836372670285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] * obj[1] for _, obj in archive]  # Product of objectives\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment rotation or adaptive node swapping\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n    else:\n        # Adaptive node swapping\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N)) % N\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution length\n    prob = min(0.7, 0.3 + (N / 100))\n\n    if np.random.rand() < prob:\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n",
        "score": [
            10.47419865058942,
            10.619469517891769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution length\n    prob = min(0.7, 0.3 + (N / 100))\n\n    if np.random.rand() < prob:\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The new heuristic selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining path reversal with constrained node insertion and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with constrained node insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.7:\n            node = np.random.choice(new_solution)\n            pos = np.random.choice([i for i in range(N) if i not in [a, a+1, b-1, b]])\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation with position constraints\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.choice([i for i in range(N) if i != old_pos])\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            10.45733003836069,
            10.621560042143937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with constrained node insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.7:\n            node = np.random.choice(new_solution)\n            pos = np.random.choice([i for i in range(N) if i not in [a, a+1, b-1, b]])\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation with position constraints\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.choice([i for i in range(N) if i != old_pos])\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware ranking that combines objective scores and structural diversity, then applies a hybrid local search combining adaptive segment rotation, probabilistic node swapping, and edge-based inversion with dynamic probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware ranking\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(np.diff(x[0]))) for x in archive])\n    norm_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    combined_scores = 0.5 * norm_objectives[:, 0] + 0.3 * norm_objectives[:, 1] + 0.2 * norm_diversity\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        shift = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge-based inversion with dynamic probability\n    inversion_prob = 0.3 * (1 - np.min(combined_scores))\n    if np.random.rand() < inversion_prob:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n    return new_solution\n\n",
        "score": [
            5.414083515956996,
            7.8017170726814005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware ranking\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(np.diff(x[0]))) for x in archive])\n    norm_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    combined_scores = 0.5 * norm_objectives[:, 0] + 0.3 * norm_objectives[:, 1] + 0.2 * norm_diversity\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        shift = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge-based inversion with dynamic probability\n    inversion_prob = 0.3 * (1 - np.min(combined_scores))\n    if np.random.rand() < inversion_prob:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node clustering, segment rotation, and adaptive edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node clustering and segment rotation\n    if np.random.rand() < 0.4:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        segment = new_solution[start:start+cluster_size]\n        rotation = np.random.randint(1, cluster_size)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+cluster_size] = rotated_segment\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.5:\n        for _ in range(min(3, N//2)):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n\n            # Calculate cost change for both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            # Apply flip if beneficial for at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal with feasibility check\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != 0 and b != N-1 and a != b-1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.08374539576344,
            5.754247885828572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node clustering and segment rotation\n    if np.random.rand() < 0.4:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        segment = new_solution[start:start+cluster_size]\n        rotation = np.random.randint(1, cluster_size)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+cluster_size] = rotated_segment\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.5:\n        for _ in range(min(3, N//2)):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n\n            # Calculate cost change for both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            # Apply flip if beneficial for at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal with feasibility check\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != 0 and b != N-1 and a != b-1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node relocation with path optimization, and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(costs[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (costs[sorted_indices[j+1], i] - costs[sorted_indices[j-1], i]) / (costs[sorted_indices[-1], i] - costs[sorted_indices[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation with path optimization\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidates = []\n        for new_pos in range(N):\n            if new_pos == old_pos:\n                continue\n            temp = new_solution.copy()\n            temp = np.concatenate([temp[:old_pos], temp[old_pos+1:]])\n            temp = np.concatenate([temp[:new_pos], [node], temp[new_pos:]])\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(N))\n            candidates.append((cost1 + cost2, temp))\n\n        if candidates:\n            best_cost, best_solution = min(candidates, key=lambda x: x[0])\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n            if best_cost < (current_cost1 + current_cost2):\n                new_solution = best_solution\n\n    # Adaptive edge swapping\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != 0 and j != N-1 and i != j-1:\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(N))\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n            if (cost1 + cost2) < (current_cost1 + current_cost2):\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            7.181086140630805,
            6.721067698615504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(costs[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (costs[sorted_indices[j+1], i] - costs[sorted_indices[j-1], i]) / (costs[sorted_indices[-1], i] - costs[sorted_indices[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation with path optimization\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidates = []\n        for new_pos in range(N):\n            if new_pos == old_pos:\n                continue\n            temp = new_solution.copy()\n            temp = np.concatenate([temp[:old_pos], temp[old_pos+1:]])\n            temp = np.concatenate([temp[:new_pos], [node], temp[new_pos:]])\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(N))\n            candidates.append((cost1 + cost2, temp))\n\n        if candidates:\n            best_cost, best_solution = min(candidates, key=lambda x: x[0])\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n            if best_cost < (current_cost1 + current_cost2):\n                new_solution = best_solution\n\n    # Adaptive edge swapping\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != 0 and j != N-1 and i != j-1:\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(N))\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n            if (cost1 + cost2) < (current_cost1 + current_cost2):\n                new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining alternating segment transposition, adaptive node swapping with distance awareness, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment transposition\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a % 2 == 0 and b % 2 == 0:\n            segment1 = new_solution[a:a+2]\n            segment2 = new_solution[b:b+2]\n            new_solution[a:a+2] = segment2\n            new_solution[b:b+2] = segment1\n\n    # Adaptive node swapping with distance awareness\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = (i + np.random.randint(1, N//2)) % N\n        d1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1] if i+1 < N else new_solution[0]]\n        d1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1] if j+1 < N else new_solution[0]]\n        d2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1] if i+1 < N else new_solution[0]]\n        d2 += distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1] if j+1 < N else new_solution[0]]\n        if d1 + d2 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1] if i+1 < N else new_solution[0]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1] if i+1 < N else new_solution[0]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - k + 1)\n        if np.random.rand() < 0.7:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.484953032678183,
            6.978847417512667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment transposition\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a % 2 == 0 and b % 2 == 0:\n            segment1 = new_solution[a:a+2]\n            segment2 = new_solution[b:b+2]\n            new_solution[a:a+2] = segment2\n            new_solution[b:b+2] = segment1\n\n    # Adaptive node swapping with distance awareness\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = (i + np.random.randint(1, N//2)) % N\n        d1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1] if i+1 < N else new_solution[0]]\n        d1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1] if j+1 < N else new_solution[0]]\n        d2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1] if i+1 < N else new_solution[0]]\n        d2 += distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1] if j+1 < N else new_solution[0]]\n        if d1 + d2 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1] if i+1 < N else new_solution[0]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1] if i+1 < N else new_solution[0]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - k + 1)\n        if np.random.rand() < 0.7:\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective trade-off using Pareto dominance analysis, then applies a hybrid local search combining segment insertion and double-bridge moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected = min(non_dominated, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion + double-bridge move\n    if N > 4:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Double-bridge move\n        if N > 6:\n            i, j, k, l = sorted(np.random.choice(N, size=4, replace=False))\n            new_solution = np.concatenate([\n                new_solution[:i], new_solution[j:k+1], new_solution[i:j],\n                new_solution[l:], new_solution[k+1:l], new_solution[j+1:k+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            10.51669711770095,
            10.540610278168213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected = min(non_dominated, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion + double-bridge move\n    if N > 4:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Double-bridge move\n        if N > 6:\n            i, j, k, l = sorted(np.random.choice(N, size=4, replace=False))\n            new_solution = np.concatenate([\n                new_solution[:i], new_solution[j:k+1], new_solution[i:j],\n                new_solution[l:], new_solution[k+1:l], new_solution[j+1:k+1]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The new heuristic selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment shuffling with adaptive edge swaps and probabilistic node relocations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized.mean(axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment shuffling with adaptive length\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(7, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.7:  # 70% chance to shuffle\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    # Adaptive edge swaps\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, 2, replace=False)\n            if abs(i - j) > 1 and i != 0 and j != N-1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic node relocations\n    if np.random.rand() < 0.4:\n        for _ in range(3):\n            node = np.random.choice(new_solution)\n            old_pos = np.where(new_solution == node)[0][0]\n            new_pos = np.random.randint(N)\n            if new_pos != old_pos:\n                new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.677175281631139,
            6.94702994242428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized.mean(axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment shuffling with adaptive length\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(7, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.7:  # 70% chance to shuffle\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    # Adaptive edge swaps\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, 2, replace=False)\n            if abs(i - j) > 1 and i != 0 and j != N-1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic node relocations\n    if np.random.rand() < 0.4:\n        for _ in range(3):\n            node = np.random.choice(new_solution)\n            old_pos = np.where(new_solution == node)[0][0]\n            new_pos = np.random.randint(N)\n            if new_pos != old_pos:\n                new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node swapping, and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = float('inf')\n        crowding_distances[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        a = np.random.randint(N)\n        segment = new_solution[a:a+k]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+k:], segment])\n\n    # Node swapping with adaptive probability\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge insertion with feasibility check\n    if np.random.rand() < 0.4 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n",
        "score": [
            7.8230878752757,
            7.4512601064277195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = float('inf')\n        crowding_distances[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        a = np.random.randint(N)\n        segment = new_solution[a:a+k]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+k:], segment])\n\n    # Node swapping with adaptive probability\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge insertion with feasibility check\n    if np.random.rand() < 0.4 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection strategy that combines Pareto front analysis with crowding distance, then applies a novel local search combining adaptive segment merging and probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        distances = [0] * len(solutions)\n\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(len(solutions)), key=lambda i: objectives[i][m])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    if len(non_dominated) > 1:\n        distances = crowding_distance(non_dominated)\n        selected_idx = np.argmax(distances)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment merging\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N//2))\n        start = np.random.randint(0, N - 2*segment_length + 1)\n\n        segment1 = new_solution[start:start+segment_length]\n        segment2 = new_solution[start+segment_length:start+2*segment_length]\n\n        if np.random.rand() < 0.7:  # Merge with overlap\n            overlap = np.random.randint(1, min(3, segment_length))\n            merged = np.concatenate([segment1[:-overlap], segment2])\n        else:  # Merge with rotation\n            shift = np.random.randint(1, segment_length)\n            merged = np.concatenate([segment1[shift:], segment1[:shift], segment2])\n\n        new_solution = np.concatenate([new_solution[:start], merged, new_solution[start+2*segment_length:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, old_pos)\n\n        if np.random.rand() < 0.6:  # Insert at optimal position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)+1):\n                candidate = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n        else:  # Insert at random position\n            new_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.731858431446428,
            6.954377464851445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        distances = [0] * len(solutions)\n\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(len(solutions)), key=lambda i: objectives[i][m])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    if len(non_dominated) > 1:\n        distances = crowding_distance(non_dominated)\n        selected_idx = np.argmax(distances)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment merging\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N//2))\n        start = np.random.randint(0, N - 2*segment_length + 1)\n\n        segment1 = new_solution[start:start+segment_length]\n        segment2 = new_solution[start+segment_length:start+2*segment_length]\n\n        if np.random.rand() < 0.7:  # Merge with overlap\n            overlap = np.random.randint(1, min(3, segment_length))\n            merged = np.concatenate([segment1[:-overlap], segment2])\n        else:  # Merge with rotation\n            shift = np.random.randint(1, segment_length)\n            merged = np.concatenate([segment1[shift:], segment1[:shift], segment2])\n\n        new_solution = np.concatenate([new_solution[:start], merged, new_solution[start+2*segment_length:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, old_pos)\n\n        if np.random.rand() < 0.6:  # Insert at optimal position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)+1):\n                candidate = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n        else:  # Insert at random position\n            new_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances exploitation of good solutions with exploration of diverse regions, then applies a hybrid local search combining adaptive segment reversal, node relocation with distance-based insertion, and edge inversion, while ensuring feasibility through careful feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(objectives, axis=0)\n    diversity_scores = np.array([np.mean(np.abs(ranks[i] - ranks)) for i in range(len(archive))])\n    combined_scores = 0.7 * np.linalg.norm(ranks, axis=1) + 0.3 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a >= 2:\n            segment = new_solution[a:b+1]\n            total_dist = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            if np.random.rand() < 0.5 or total_dist > np.mean(distance_matrix_1):\n                new_solution[a:b+1] = segment[::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        distances = np.array([distance_matrix_1[node, new_solution[i]] + distance_matrix_1[new_solution[(i-1)%N], node] for i in range(N)])\n        new_pos = np.argmin(distances)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4 and N >= 4:\n        i, j = sorted(np.random.choice(range(1, N-1), size=2, replace=False))\n        if new_solution[i-1] != new_solution[j] and new_solution[j+1] != new_solution[i]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.072796619098487,
            6.582212180568826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(objectives, axis=0)\n    diversity_scores = np.array([np.mean(np.abs(ranks[i] - ranks)) for i in range(len(archive))])\n    combined_scores = 0.7 * np.linalg.norm(ranks, axis=1) + 0.3 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a >= 2:\n            segment = new_solution[a:b+1]\n            total_dist = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            if np.random.rand() < 0.5 or total_dist > np.mean(distance_matrix_1):\n                new_solution[a:b+1] = segment[::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        distances = np.array([distance_matrix_1[node, new_solution[i]] + distance_matrix_1[new_solution[(i-1)%N], node] for i in range(N)])\n        new_pos = np.argmin(distances)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4 and N >= 4:\n        i, j = sorted(np.random.choice(range(1, N-1), size=2, replace=False))\n        if new_solution[i-1] != new_solution[j] and new_solution[j+1] != new_solution[i]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The new algorithm selects a solution from the archive based on a probabilistic combination of objective scores, then applies a hybrid local search combining adaptive segment permutation, probabilistic node swapping, and dynamic edge inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = np.random.dirichlet(np.ones(2))\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment permutation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(4, N//2))\n        segments = [new_solution[i::k] for i in range(k)]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        swap_indices = np.random.choice(N, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Dynamic edge inversion\n    if np.random.rand() < 0.3:\n        inv_prob = np.random.beta(2, 5)\n        for i in range(N):\n            if np.random.rand() < inv_prob:\n                j = (i + 1) % N\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.363312550987707,
            6.372138980129313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = np.random.dirichlet(np.ones(2))\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment permutation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(4, N//2))\n        segments = [new_solution[i::k] for i in range(k)]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        swap_indices = np.random.choice(N, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Dynamic edge inversion\n    if np.random.rand() < 0.3:\n        inv_prob = np.random.beta(2, 5)\n        for i in range(N):\n            if np.random.rand() < inv_prob:\n                j = (i + 1) % N\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining segment rotation, node swapping, and edge flipping with dynamic probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n    selected_idx = np.random.choice(np.where(crowding == np.max(crowding))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if b - a > 1 and c - b > 1:\n            segment = new_solution[a:c+1]\n            rotated = np.concatenate([segment[b-a:], segment[:b-a]])\n            new_solution[a:c+1] = rotated\n\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if np.random.rand() < 0.3 and j > 0 and j < N-1:\n            new_solution[j-1], new_solution[j] = new_solution[j], new_solution[j-1]\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.798717628713039,
            8.368048183502184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n    selected_idx = np.random.choice(np.where(crowding == np.max(crowding))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if b - a > 1 and c - b > 1:\n            segment = new_solution[a:c+1]\n            rotated = np.concatenate([segment[b-a:], segment[:b-a]])\n            new_solution[a:c+1] = rotated\n\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if np.random.rand() < 0.3 and j > 0 and j < N-1:\n            new_solution[j-1], new_solution[j] = new_solution[j], new_solution[j-1]\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining segment rotation, node insertion with inversion, and probabilistic edge swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    crowding_distances[sorted_indices[0]] = np.inf\n    crowding_distances[sorted_indices[-1]] = np.inf\n    for i in range(1, len(objectives) - 1):\n        crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with inversion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge swap\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.25278213996397,
            6.675615566906119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    crowding_distances[sorted_indices[0]] = np.inf\n    crowding_distances[sorted_indices[-1]] = np.inf\n    for i in range(1, len(objectives) - 1):\n        crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with inversion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge swap\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based score, then applies a hybrid local search combining segment inversion with probabilistic node swapping and adaptive edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive length\n    if np.random.rand() < 0.5:\n        seg_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - seg_length + 1)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.281071198852657,
            6.196267590052442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive length\n    if np.random.rand() < 0.5:\n        seg_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - seg_length + 1)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.435497087536808,
            4.447767559872988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.435497087536808,
            4.447767559872988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware metric combining objective values and solution structure, then applies a hybrid local search combining segment rotation, node swapping, and adaptive edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(norm_objectives - np.mean(norm_objectives, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, b-a)\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node swapping with adaptive probability\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = (i + np.random.randint(1, N//2)) % N\n                if new_solution[i] != new_solution[j]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.989109331412582,
            6.975042782052864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(norm_objectives - np.mean(norm_objectives, axis=0)), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, b-a)\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node swapping with adaptive probability\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = (i + np.random.randint(1, N//2)) % N\n                if new_solution[i] != new_solution[j]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.127446975248162,
            9.261212523597171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.127446975248162,
            9.261212523597171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search combining segment rotation, node swapping with adaptive probabilities, and edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set()\n        for i in range(len(sol)):\n            unique_pairs.add((sol[i], sol[(i+1)%len(sol)]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        k = np.random.randint(1, N//2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n    else:\n        # Node swapping with adaptive probabilities\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge flipping\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != b and (b - a) > 1:\n            new_solution[a+1:b] = new_solution[b-1:a:-1]\n\n    return new_solution\n\n",
        "score": [
            8.150852815424223,
            8.317741987120604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set()\n        for i in range(len(sol)):\n            unique_pairs.add((sol[i], sol[(i+1)%len(sol)]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        k = np.random.randint(1, N//2)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n    else:\n        # Node swapping with adaptive probabilities\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge flipping\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != b and (b - a) > 1:\n            new_solution[a+1:b] = new_solution[b-1:a:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using crowding distance and dominance rank), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive), dtype=int)\n    dominated_counts = np.zeros(len(archive), dtype=int)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (costs[i][0] <= costs[j][0] and costs[i][1] <= costs[j][1]) and (costs[i][0] < costs[j][0] or costs[i][1] < costs[j][1]):\n                dominated_counts[j] += 1\n            elif (costs[j][0] <= costs[i][0] and costs[j][1] <= costs[i][1]) and (costs[j][0] < costs[i][0] or costs[j][1] < costs[i][1]):\n                dominated_counts[i] += 1\n\n    for i in range(len(archive)):\n        ranks[i] = np.sum(dominated_counts < dominated_counts[i])\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for obj in range(2):\n        sorted_indices = np.argsort(costs[:, obj])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (costs[sorted_indices[i+1], obj] - costs[sorted_indices[i-1], obj]) / (costs[sorted_indices[-1], obj] - costs[sorted_indices[0], obj] + 1e-8)\n\n    # Combine ranks and crowding distances for selection\n    scores = ranks + 1 / (crowding_distances + 1e-8)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.081518205124417,
            8.146602588693217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive), dtype=int)\n    dominated_counts = np.zeros(len(archive), dtype=int)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (costs[i][0] <= costs[j][0] and costs[i][1] <= costs[j][1]) and (costs[i][0] < costs[j][0] or costs[i][1] < costs[j][1]):\n                dominated_counts[j] += 1\n            elif (costs[j][0] <= costs[i][0] and costs[j][1] <= costs[i][1]) and (costs[j][0] < costs[i][0] or costs[j][1] < costs[i][1]):\n                dominated_counts[i] += 1\n\n    for i in range(len(archive)):\n        ranks[i] = np.sum(dominated_counts < dominated_counts[i])\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for obj in range(2):\n        sorted_indices = np.argsort(costs[:, obj])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (costs[sorted_indices[i+1], obj] - costs[sorted_indices[i-1], obj]) / (costs[sorted_indices[-1], obj] - costs[sorted_indices[0], obj] + 1e-8)\n\n    # Combine ranks and crowding distances for selection\n    scores = ranks + 1 / (crowding_distances + 1e-8)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining adaptive segment insertion with probabilistic node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = np.random.randint(0, N)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation\n    if np.random.rand() < 0.3:\n        segment_length = np.random.randint(2, min(3, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        shift = np.random.randint(1, segment_length)\n        new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    return new_solution\n\n",
        "score": [
            6.280388759674818,
            6.156648552742804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = np.random.randint(0, N)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation\n    if np.random.rand() < 0.3:\n        segment_length = np.random.randint(2, min(3, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        shift = np.random.randint(1, segment_length)\n        new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.015690534003456,
            7.696038592244591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining node swap and edge reversal operations to generate a neighbor solution while ensuring feasibility, with a probability-based approach to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total = sum((x[1][0] + x[1][1]) for x in archive)\n    if total == 0:\n        probs = [1/len(archive) for _ in archive]\n    else:\n        probs = [1 - (x[1][0] + x[1][1])/total for x in archive]\n    probs = [p/sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node swap or edge reversal\n    if np.random.rand() < 0.7:\n        # Node swap\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.449868578536463,
            6.731725997087021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total = sum((x[1][0] + x[1][1]) for x in archive)\n    if total == 0:\n        probs = [1/len(archive) for _ in archive]\n    else:\n        probs = [1 - (x[1][0] + x[1][1])/total for x in archive]\n    probs = [p/sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node swap or edge reversal\n    if np.random.rand() < 0.7:\n        # Node swap\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm selects a solution from the archive using a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining edge exchange and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        crowding = [0.0] * len(sorted_archive)\n        for m in range(2):  # For both objectives\n            sorted_archive.sort(key=lambda x: x[1][m])\n            crowding[0] = crowding[-1] = float('inf')\n            for i in range(1, len(sorted_archive)-1):\n                crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (max(sorted_archive[-1][1][m], 1e-6) - min(sorted_archive[0][1][m], 1e-6))\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge exchange + path reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[b:a-1 if a > 0 else None:-1]\n    else:  # 30% chance for path reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Ensure feasibility by checking for duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != N:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.89523692142575,
            9.673320769978861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        crowding = [0.0] * len(sorted_archive)\n        for m in range(2):  # For both objectives\n            sorted_archive.sort(key=lambda x: x[1][m])\n            crowding[0] = crowding[-1] = float('inf')\n            for i in range(1, len(sorted_archive)-1):\n                crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (max(sorted_archive[-1][1][m], 1e-6) - min(sorted_archive[0][1][m], 1e-6))\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge exchange + path reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[b:a-1 if a > 0 else None:-1]\n    else:  # 30% chance for path reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Ensure feasibility by checking for duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != N:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel local search combining adaptive segment insertion and probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        diversity_scores = []\n        for i, (sol, _) in enumerate(archive):\n            diversity = sum(abs(sol[j] - archive[(i+1)%len(archive)][0][j]) for j in range(len(sol)))\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = np.random.randint(0, N)\n                if i != j and (i != 0 or j != N-1) and (i != N-1 or j != 0):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.08010942222796,
            7.065634709865346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        diversity_scores = []\n        for i, (sol, _) in enumerate(archive):\n            diversity = sum(abs(sol[j] - archive[(i+1)%len(archive)][0][j]) for j in range(len(sol)))\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = np.random.randint(0, N)\n                if i != j and (i != 0 or j != N-1) and (i != N-1 or j != 0):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.7 for first objective, 0.3 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.625591026710601,
            8.158764205204154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reinsertion with path reversal and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reinsertion with path reversal\n    a = np.random.randint(0, N)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N-1):\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Edge exchange with path reversal\n    if np.random.rand() < 0.3:  # 30% chance to exchange edges\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with segment selection\n    if np.random.rand() < 0.4:  # 40% chance to reverse a segment\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.89980875824665,
            5.80465254215507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reinsertion with path reversal\n    a = np.random.randint(0, N)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N-1):\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Edge exchange with path reversal\n    if np.random.rand() < 0.3:  # 30% chance to exchange edges\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with segment selection\n    if np.random.rand() < 0.4:  # 40% chance to reverse a segment\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The new algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node swapping, and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node swapping with distance-based probability\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%N]]\n        dist2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n        if dist1 < dist2 or np.random.rand() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(2, N-1)) % N\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.776826336531361,
            7.956278084036375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node swapping with distance-based probability\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%N]]\n        dist2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n        if dist1 < dist2 or np.random.rand() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(2, N-1)) % N\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining segment reversal and node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.202172320233735,
            5.743949921978457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining node reordering with adaptive segment reversal, probabilistic edge swapping, and a novel \"objective-aware\" node relocation strategy that considers both distance matrices to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(7, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.7:  # 70% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 30% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Objective-aware edge swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:  # 20% chance to consider each node\n                j = (i + 1) % N\n                # Calculate potential improvement in both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware node relocation\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidates = []\n        for new_pos in range(N):\n            if new_pos != old_pos:\n                # Calculate potential improvement in both objectives\n                old_prev = new_solution[old_pos-1] if old_pos > 0 else new_solution[-1]\n                old_next = new_solution[(old_pos+1)%N]\n                new_prev = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n                new_next = new_solution[new_pos]\n                old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n                new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n                new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.15:\n                    candidates.append(new_pos)\n        if candidates:\n            new_pos = np.random.choice(candidates)\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.375574027632876,
            6.218597960903394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(7, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.7:  # 70% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 30% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Objective-aware edge swapping\n    if np.random.rand() < 0.4:\n        for i in range(N):\n            if np.random.rand() < 0.2:  # 20% chance to consider each node\n                j = (i + 1) % N\n                # Calculate potential improvement in both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware node relocation\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidates = []\n        for new_pos in range(N):\n            if new_pos != old_pos:\n                # Calculate potential improvement in both objectives\n                old_prev = new_solution[old_pos-1] if old_pos > 0 else new_solution[-1]\n                old_next = new_solution[(old_pos+1)%N]\n                new_prev = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n                new_next = new_solution[new_pos]\n                old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n                new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n                new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.15:\n                    candidates.append(new_pos)\n        if candidates:\n            new_pos = np.random.choice(candidates)\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted sum of normalized objectives with equal weights (0.5 for each objective), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.059291832154049,
            5.786648258257412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives, where weights are adjusted based on the solution's proximity to the current Pareto front, then applies a hybrid local search combining segment rotation, adaptive node insertion, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = np.array([obj for _, obj in archive if not np.any(np.all(objectives <= obj, axis=1) & (objectives < obj).any(axis=1))])\n    if len(pareto_front) > 0:\n        weights = np.random.uniform(0.3, 0.7)\n        scores = [weights * (obj[0] - pareto_front[:, 0].min()) / (pareto_front[:, 0].max() - pareto_front[:, 0].min() + 1e-8) +\n                  (1 - weights) * (obj[1] - pareto_front[:, 1].min()) / (pareto_front[:, 1].max() - pareto_front[:, 1].min() + 1e-8)\n                  for obj in objectives]\n    else:\n        scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.1397582508716075,
            6.493642585675516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = np.array([obj for _, obj in archive if not np.any(np.all(objectives <= obj, axis=1) & (objectives < obj).any(axis=1))])\n    if len(pareto_front) > 0:\n        weights = np.random.uniform(0.3, 0.7)\n        scores = [weights * (obj[0] - pareto_front[:, 0].min()) / (pareto_front[:, 0].max() - pareto_front[:, 0].min() + 1e-8) +\n                  (1 - weights) * (obj[1] - pareto_front[:, 1].min()) / (pareto_front[:, 1].max() - pareto_front[:, 1].min() + 1e-8)\n                  for obj in objectives]\n    else:\n        scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection, then applies a novel hybrid local search combining adaptive node swapping, partial tour reversal with objective-aware segment selection, and probabilistic edge swapping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node swapping based on objective differences\n    for _ in range(2):\n        i, j = np.random.choice(N, size=2, replace=False)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial tour reversal with objective-aware segment selection\n    if np.random.rand() < 0.7:\n        segment_length = min(5, N // 2)\n        start = np.random.randint(N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        if segment_cost1 > segment_cost2:\n            new_solution[start:end] = segment[::-1]\n\n    # Probabilistic edge swapping\n    for i in range(N):\n        if np.random.rand() < 0.3:\n            j = (i + np.random.randint(2, 5)) % N\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.7262832571309925,
            7.330811317655889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node swapping based on objective differences\n    for _ in range(2):\n        i, j = np.random.choice(N, size=2, replace=False)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial tour reversal with objective-aware segment selection\n    if np.random.rand() < 0.7:\n        segment_length = min(5, N // 2)\n        start = np.random.randint(N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        if segment_cost1 > segment_cost2:\n            new_solution[start:end] = segment[::-1]\n\n    # Probabilistic edge swapping\n    for i in range(N):\n        if np.random.rand() < 0.3:\n            j = (i + np.random.randint(2, 5)) % N\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel local search combining edge insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((costs[:, 1], costs[:, 0]))\n    selected_idx = sorted_indices[len(sorted_indices) // 2]  # Select middle solution\n    selected = archive[selected_idx][0].copy()\n\n    # Novel local search: edge insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    i, j = np.random.choice(N, size=2, replace=False)\n    if abs(i - j) > 1:\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i:j]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j:i]])\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            8.557039750322357,
            8.477767085973028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((costs[:, 1], costs[:, 0]))\n    selected_idx = sorted_indices[len(sorted_indices) // 2]  # Select middle solution\n    selected = archive[selected_idx][0].copy()\n\n    # Novel local search: edge insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    i, j = np.random.choice(N, size=2, replace=False)\n    if abs(i - j) > 1:\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i:j]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j:i]])\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining double-bridge moves, node insertion, and probabilistic edge flips to generate diverse and high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n    for i in range(2):  # For both objectives\n        for j in range(1, len(archive)-1):\n            crowding[sorted_indices[j, i]] += (objectives[sorted_indices[j+1, i], i] - objectives[sorted_indices[j-1, i], i]) / (objectives[sorted_indices[-1, i], i] - objectives[sorted_indices[0, i], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Double-bridge move with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment3, segment2, segment1, new_solution[d+1:]])\n\n    # Node insertion with edge flip\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n        if np.random.rand() < 0.3 and new_pos > 0:\n            new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.230495276635429,
            8.286628760868686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n    for i in range(2):  # For both objectives\n        for j in range(1, len(archive)-1):\n            crowding[sorted_indices[j, i]] += (objectives[sorted_indices[j+1, i], i] - objectives[sorted_indices[j-1, i], i]) / (objectives[sorted_indices[-1, i], i] - objectives[sorted_indices[0, i], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Double-bridge move with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            segment3 = new_solution[c+1:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment3, segment2, segment1, new_solution[d+1:]])\n\n    # Node insertion with edge flip\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n        if np.random.rand() < 0.3 and new_pos > 0:\n            new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining adaptive segment insertion and probabilistic node swapping with edge cost analysis to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive_sorted):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive_sorted):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_idx = np.random.randint(len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        selected_idx = np.random.randint(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.7:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping with edge cost analysis\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            # Accept swap if both objectives improve or at least one improves\n            if (cost1_after <= cost1_before and cost2_after <= cost2_before) or (cost1_after < cost1_before or cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.293577504701231,
            7.009531181064993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive_sorted):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive_sorted):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_idx = np.random.randint(len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        selected_idx = np.random.randint(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.7:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping with edge cost analysis\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            # Accept swap if both objectives improve or at least one improves\n            if (cost1_after <= cost1_before and cost2_after <= cost2_before) or (cost1_after < cost1_before or cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = sum(x[1][0] for x in archive) / len(archive)\n    obj2_avg = sum(x[1][1] for x in archive) / len(archive)\n\n    if obj1_avg < obj2_avg:\n        weights = [0.7, 0.3]\n    else:\n        weights = [0.3, 0.7]\n\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swapping\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swapping if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        # Accept if at least one objective improves\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n\n        if cost1 < original_cost1 or cost2 < original_cost2:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.655018324499326,
            5.670958167546884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = sum(x[1][0] for x in archive) / len(archive)\n    obj2_avg = sum(x[1][1] for x in archive) / len(archive)\n\n    if obj1_avg < obj2_avg:\n        weights = [0.7, 0.3]\n    else:\n        weights = [0.3, 0.7]\n\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swapping\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swapping if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        # Accept if at least one objective improves\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n\n        if cost1 < original_cost1 or cost2 < original_cost2:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective ranking, then applies a hybrid local search combining edge exchange and adaptive node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.sqrt(np.sum(normalized**2, axis=1))\n    selected_idx = np.argmin(distances)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with dynamic probabilities\n    if np.random.rand() < 0.5:  # Edge exchange\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Adaptive node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N or i == (node_pos + 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = 0.4 * cost1 + 0.6 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.589892311109557,
            6.000348035090601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.sqrt(np.sum(normalized**2, axis=1))\n    selected_idx = np.argmin(distances)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with dynamic probabilities\n    if np.random.rand() < 0.5:  # Edge exchange\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Adaptive node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N or i == (node_pos + 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = 0.4 * cost1 + 0.6 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a novel local search combining adaptive segment insertion and probabilistic node merging to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] - x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node merging\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1 and j - i < N // 2:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    return new_solution\n\n",
        "score": [
            10.214494634365844,
            4.735454217265248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] - x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(4, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node merging\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1 and j - i < N // 2:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective balance using Pareto dominance and applies a hybrid local search combining adaptive segment insertion, node relocation with objective-aware acceptance, and conditional multi-node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(new_solution) > N:\n            new_solution = new_solution[:N]\n\n    # Node relocation with objective-aware acceptance\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:  # Allow slight degradation\n            new_solution = candidate\n\n    # Conditional multi-node swap\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        candidate = new_solution.copy()\n        candidate[indices] = segment\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.975668459748311,
            6.316607588532149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(new_solution) > N:\n            new_solution = new_solution[:N]\n\n    # Node relocation with objective-aware acceptance\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:  # Allow slight degradation\n            new_solution = candidate\n\n    # Conditional multi-node swap\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        candidate = new_solution.copy()\n        candidate[indices] = segment\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware score, then applies a hybrid local search combining multi-segment permutation, adaptive node insertion, and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] - x[1][1])**2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment permutation\n    if np.random.rand() < 0.5:\n        segments = np.random.choice([1, 2, 3], p=[0.4, 0.4, 0.2])\n        if segments == 1:\n            a, b = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            points = sorted(np.random.choice(N, size=segments+1, replace=False))\n            for i in range(segments):\n                seg1, seg2 = points[i], points[i+1]\n                if seg2 - seg1 > 1:\n                    new_solution[seg1:seg2] = new_solution[seg1:seg2][::-1]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 2:\n            segment = new_solution[i:j+1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            inverted_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] +\n                           distance_matrix_1[segment[0], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[-1]] +\n                           distance_matrix_2[segment[0], new_solution[(j+1)%N]])\n\n            if inverted_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            7.5628143261619085,
            7.483117392549502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] - x[1][1])**2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment permutation\n    if np.random.rand() < 0.5:\n        segments = np.random.choice([1, 2, 3], p=[0.4, 0.4, 0.2])\n        if segments == 1:\n            a, b = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            points = sorted(np.random.choice(N, size=segments+1, replace=False))\n            for i in range(segments):\n                seg1, seg2 = points[i], points[i+1]\n                if seg2 - seg1 > 1:\n                    new_solution[seg1:seg2] = new_solution[seg1:seg2][::-1]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 2:\n            segment = new_solution[i:j+1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            inverted_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] +\n                           distance_matrix_1[segment[0], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[-1]] +\n                           distance_matrix_2[segment[0], new_solution[(j+1)%N]])\n\n            if inverted_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining adaptive segment insertion, probabilistic node swapping, and dynamic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = np.random.randint(0, N)\n                if j != i:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic edge reversal\n    if np.random.rand() < 0.3:\n        num_reversals = np.random.randint(1, min(3, N//2))\n        for _ in range(num_reversals):\n            start = np.random.randint(0, N - 2)\n            end = np.random.randint(start + 2, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.548297229054842,
            6.281307048013103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:\n                j = np.random.randint(0, N)\n                if j != i:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic edge reversal\n    if np.random.rand() < 0.3:\n        num_reversals = np.random.randint(1, min(3, N//2))\n        for _ in range(num_reversals):\n            start = np.random.randint(0, N - 2)\n            end = np.random.randint(start + 2, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            4.763291755419781,
            9.040409322446497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.120311480775534,
            5.790523628268353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective balance using Pareto dominance and applies a hybrid local search combining adaptive segment insertion, node relocation with objective-aware acceptance, and conditional multi-node swap to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(new_solution) > N:\n            new_solution = new_solution[:N]\n\n    # Node relocation with objective-aware acceptance\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:  # Allow slight degradation\n            new_solution = candidate\n\n    # Conditional multi-node swap\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        candidate = new_solution.copy()\n        candidate[indices] = segment\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and probabilistic path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if np.random.rand() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate([segment[1:], [segment[0]]])\n\n    return new_solution\n\n",
        "score": [
            5.647537924902148,
            6.317000518219621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if np.random.rand() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate([segment[1:], [segment[0]]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The new algorithm selects a solution from the archive based on the worst objective value (to encourage exploration), then applies a novel \"node chain reversal\" operator that reverses segments of nodes while maintaining feasibility, and combines it with a probabilistic node swap to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_idx = np.argmax([max(obj[0], obj[1]) for _, obj in archive])\n    base_solution = archive[worst_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain reversal operator\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))  # Chain length\n        start = np.random.randint(0, N - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n    else:\n        # Probabilistic node swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.50502841973255,
            10.500807509106366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_idx = np.argmax([max(obj[0], obj[1]) for _, obj in archive])\n    base_solution = archive[worst_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain reversal operator\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))  # Chain length\n        start = np.random.randint(0, N - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n    else:\n        # Probabilistic node swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining segment insertion, probabilistic node swaps, and adaptive edge reversal to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        pos = np.random.randint(N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n\n    # Probabilistic node swaps\n    if np.random.rand() < 0.4:\n        for _ in range(min(3, N//2)):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge reversal\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + 1) % N\n                if j != 0 or i != N-1:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.834341719587108,
            6.873433915326749
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment insertion\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        pos = np.random.randint(N - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n\n    # Probabilistic node swaps\n    if np.random.rand() < 0.4:\n        for _ in range(min(3, N//2)):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge reversal\n    if np.random.rand() < 0.3:\n        for i in range(N):\n            if np.random.rand() < 0.2:\n                j = (i + 1) % N\n                if j != 0 or i != N-1:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining adaptive segment relocation with probabilistic node swapping and objective-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, N - segment_length + 1)\n        if new_pos != start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        obj_weights = np.array([0.7, 0.3]) if np.random.rand() < 0.5 else np.array([0.3, 0.7])\n        for i in range(N):\n            j = (i + 1) % N\n            for k in range(N):\n                if k != i and k != j and k != (i - 1) % N:\n                    cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[j]]\n                    cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[j]]\n                    weighted_cost = obj_weights[0] * cost1 + obj_weights[1] * cost2\n                    if weighted_cost < 0:\n                        new_solution = np.insert(new_solution, j, new_solution[k])\n                        new_solution = np.delete(new_solution, np.where(new_solution == new_solution[k])[0][1])\n                        break\n\n    return new_solution\n\n",
        "score": [
            6.622698320893962,
            6.061221732822507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_pos = np.random.randint(0, N - segment_length + 1)\n        if new_pos != start:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if np.random.rand() < 0.6:\n        for _ in range(2):\n            i, j = np.random.choice(N, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        obj_weights = np.array([0.7, 0.3]) if np.random.rand() < 0.5 else np.array([0.3, 0.7])\n        for i in range(N):\n            j = (i + 1) % N\n            for k in range(N):\n                if k != i and k != j and k != (i - 1) % N:\n                    cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[j]]\n                    cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[j]]\n                    weighted_cost = obj_weights[0] * cost1 + obj_weights[1] * cost2\n                    if weighted_cost < 0:\n                        new_solution = np.insert(new_solution, j, new_solution[k])\n                        new_solution = np.delete(new_solution, np.where(new_solution == new_solution[k])[0][1])\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining segment reversal and node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining segment reversal with dynamic segment length and node insertion with probabilistic improvement, ensuring feasibility throughout.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Adaptive weights based on solution diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else np.array([0.5, 0.5])\n\n    scores = weights[0] * normalized[:, 0] + weights[1] * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality and diversity\n    prob = 0.6 + 0.3 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with dynamic segment length\n        seg_length = max(2, int(np.random.rand() * N / 4))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with probabilistic improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Consider multiple insertion positions\n        candidates = np.random.choice(N, size=min(5, N), replace=False)\n        candidates = [c for c in candidates if c != node_pos and c != (node_pos - 1) % N]\n\n        if candidates:\n            best_cost = float('inf')\n            best_pos = -1\n\n            for i in candidates:\n                candidate = new_solution.copy()\n                candidate = np.delete(candidate, node_pos)\n                candidate = np.insert(candidate, i, node)\n\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n                total_cost = weights[0] * cost1 + weights[1] * cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.3594720628939765,
            6.002479246336416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Adaptive weights based on solution diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else np.array([0.5, 0.5])\n\n    scores = weights[0] * normalized[:, 0] + weights[1] * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality and diversity\n    prob = 0.6 + 0.3 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with dynamic segment length\n        seg_length = max(2, int(np.random.rand() * N / 4))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with probabilistic improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Consider multiple insertion positions\n        candidates = np.random.choice(N, size=min(5, N), replace=False)\n        candidates = [c for c in candidates if c != node_pos and c != (node_pos - 1) % N]\n\n        if candidates:\n            best_cost = float('inf')\n            best_pos = -1\n\n            for i in candidates:\n                candidate = new_solution.copy()\n                candidate = np.delete(candidate, node_pos)\n                candidate = np.insert(candidate, i, node)\n\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n                total_cost = weights[0] * cost1 + weights[1] * cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This new algorithm selects a solution from the archive using a crowding distance-based selection, then applies a hybrid local search combining segment rotation, node insertion with inversion, and probabilistic edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_order = np.argsort(sorted_objectives[:,i])\n        crowding_distances[sorted_indices[sorted_order[0]]] = np.inf\n        crowding_distances[sorted_indices[sorted_order[-1]]] = np.inf\n        for j in range(1, len(archive)-1):\n            idx = sorted_indices[sorted_order[j]]\n            if idx not in [sorted_indices[sorted_order[0]], sorted_indices[sorted_order[-1]]]:\n                crowding_distances[idx] += (sorted_objectives[sorted_order[j+1],i] - sorted_objectives[sorted_order[j-1],i]) / (objectives[:,i].max() - objectives[:,i].min() + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with inversion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge swapping\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.775867803161145,
            10.252163579019168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_order = np.argsort(sorted_objectives[:,i])\n        crowding_distances[sorted_indices[sorted_order[0]]] = np.inf\n        crowding_distances[sorted_indices[sorted_order[-1]]] = np.inf\n        for j in range(1, len(archive)-1):\n            idx = sorted_indices[sorted_order[j]]\n            if idx not in [sorted_indices[sorted_order[0]], sorted_indices[sorted_order[-1]]]:\n                crowding_distances[idx] += (sorted_objectives[sorted_order[j+1],i] - sorted_objectives[sorted_order[j-1],i]) / (objectives[:,i].max() - objectives[:,i].min() + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion with inversion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge swapping\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective balance using Pareto dominance and applies a hybrid local search combining adaptive segment insertion, node relocation with objective-aware acceptance, and conditional multi-node swap to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(new_solution) > N:\n            new_solution = new_solution[:N]\n\n    # Node relocation with objective-aware acceptance\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:  # Allow slight degradation\n            new_solution = candidate\n\n    # Conditional multi-node swap\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        candidate = new_solution.copy()\n        candidate[indices] = segment\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-dominated sorting approach and applies a hybrid local search combining adaptive k-opt moves with objective-aware segment insertion and conditional node reinsertion, ensuring feasibility through strict feasibility checks and diversity through probabilistic segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated = {i: 0 for i in range(len(archive))}\n    domination_sets = {i: set() for i in range(len(archive))}\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                domination_sets[i].add(j)\n            elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                  (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in domination_sets[i]:\n                dominated[j] -= 1\n                if dominated[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_index = fronts[0][0] if fronts[0] else 0\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive k-opt move\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Objective-aware segment insertion\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(candidate) > N:\n            candidate = candidate[:N]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Conditional node reinsertion\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        pos = np.random.randint(0, N-1)\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            7.90560317433602,
            6.707306299781719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated = {i: 0 for i in range(len(archive))}\n    domination_sets = {i: set() for i in range(len(archive))}\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                domination_sets[i].add(j)\n            elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                  (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in domination_sets[i]:\n                dominated[j] -= 1\n                if dominated[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_index = fronts[0][0] if fronts[0] else 0\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive k-opt move\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Objective-aware segment insertion\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(candidate) > N:\n            candidate = candidate[:N]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Conditional node reinsertion\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        pos = np.random.randint(0, N-1)\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (70% for the first objective, 30% for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.46970847436979,
            9.067799820589551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and probabilistic path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if np.random.rand() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate([segment[1:], [segment[0]]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-aware selection criterion, then applies a novel local search combining adaptive segment reversal with objective-weighted node relocation and probabilistic multi-segment shuffling to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Objective-weighted node relocation\n    if np.random.rand() < 0.7:\n        i = np.random.randint(0, N)\n        node = new_solution[i]\n        candidate_positions = list(range(N))\n        candidate_positions.remove(i)\n\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in candidate_positions:\n            candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            candidate = np.insert(candidate, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic multi-segment shuffling\n    if np.random.rand() < 0.3:\n        num_segments = np.random.randint(2, 4)\n        segment_indices = sorted(np.random.choice(range(1, N), size=num_segments-1, replace=False))\n        segments = np.split(new_solution, segment_indices)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            5.579377089114326,
            6.075030883348134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Objective-weighted node relocation\n    if np.random.rand() < 0.7:\n        i = np.random.randint(0, N)\n        node = new_solution[i]\n        candidate_positions = list(range(N))\n        candidate_positions.remove(i)\n\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in candidate_positions:\n            candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            candidate = np.insert(candidate, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic multi-segment shuffling\n    if np.random.rand() < 0.3:\n        num_segments = np.random.randint(2, 4)\n        segment_indices = sorted(np.random.choice(range(1, N), size=num_segments-1, replace=False))\n        segments = np.split(new_solution, segment_indices)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel segment rotation and node insertion operator that considers both objective spaces simultaneously to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n        crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with minimum crowding distance\n    base_solution = archive[np.argmin(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation and node insertion operator\n    if np.random.rand() < 0.7:\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(N - k)\n        segment = new_solution[start:start+k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n        new_solution[start:start+k] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            8.552902532034501,
            8.997151432708026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n        crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with minimum crowding distance\n    base_solution = archive[np.argmin(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation and node insertion operator\n    if np.random.rand() < 0.7:\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(N - k)\n        segment = new_solution[start:start+k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n        new_solution[start:start+k] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-based selection with adaptive weights, then applies a hybrid local search combining segment rotation, node insertion with inversion, and edge swapping with dynamic probability adjustments to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if (other[0] < obj[0] and other[1] <= obj[1]) or (other[0] <= obj[0] and other[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    return new_solution\n\n",
        "score": [
            6.8671501552594325,
            6.925734242252905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if (other[0] < obj[0] and other[1] <= obj[1]) or (other[0] <= obj[0] and other[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Hybrid local search: edge swapping and segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i or j == (i + 1) % N or j == (i - 1) % N:\n            j = np.random.randint(N)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N))\n\n        if (cost1 + cost2) < (original_cost1 + original_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.596652640539812,
            6.519839047984798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Hybrid local search: edge swapping and segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i or j == (i + 1) % N or j == (i - 1) % N:\n            j = np.random.randint(N)\n\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N))\n\n        if (cost1 + cost2) < (original_cost1 + original_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted Pareto dominance score, then applies a hybrid local search combining segment rotation, node permutation, and edge swapping with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        dominated = 0\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        pareto_ranks[i] = dominated\n    selection_prob = 1 / (1 + pareto_ranks)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.01264840228361,
            7.209458052701761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        dominated = 0\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        pareto_ranks[i] = dominated\n    selection_prob = 1 / (1 + pareto_ranks)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment reversal, node insertion, and adaptive edge swapping with probabilistic checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0]) + \\\n                                     (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.roll(new_solution, (j - i) % N)\n\n    if np.random.rand() < 0.4:\n        i, j, k = sorted(np.random.choice(N, size=3, replace=False))\n        temp = new_solution[i]\n        new_solution[i:k] = np.roll(new_solution[i:k], -1)\n        new_solution[k-1] = temp\n\n    return new_solution\n\n",
        "score": [
            7.315516276626118,
            7.971969340279227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0]) + \\\n                                     (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.roll(new_solution, (j - i) % N)\n\n    if np.random.rand() < 0.4:\n        i, j, k = sorted(np.random.choice(N, size=3, replace=False))\n        temp = new_solution[i]\n        new_solution[i:k] = np.roll(new_solution[i:k], -1)\n        new_solution[k-1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and probabilistic path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:\n            new_solution = candidate\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if np.random.rand() < 0.7:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = np.concatenate([segment[1:], [segment[0]]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining adaptive segment reversal with objective-balanced node swapping and probabilistic segment shifting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.6:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Objective-balanced node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.1:\n            new_solution = candidate\n\n    # Probabilistic segment shifting\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N - len(segment) + 1)\n        if pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, pos, segment)\n\n    return new_solution\n\n",
        "score": [
            6.07918884145244,
            6.153663949830069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.6:\n        segment_length = np.random.randint(2, min(6, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Objective-balanced node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.1:\n            new_solution = candidate\n\n    # Probabilistic segment shifting\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N - len(segment) + 1)\n        if pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based objective score with dynamic weights, then applies a hybrid local search combining node insertion and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    rank1 = np.argsort(np.argsort(obj1))\n    rank2 = np.argsort(np.argsort(obj2))\n    norm_rank1 = rank1 / (len(archive) - 1)\n    norm_rank2 = rank2 / (len(archive) - 1)\n\n    # Dynamic weights based on solution quality\n    avg_rank = (norm_rank1 + norm_rank2) / 2\n    weights = 0.6 - 0.4 * (avg_rank - np.mean(avg_rank))\n    weights = np.clip(weights, 0.2, 0.8)\n    scores = weights * norm_rank1 + (1 - weights) * norm_rank2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.6 - 0.3 * (1 - np.mean(avg_rank)):  # Higher probability for segment reversal when solutions are diverse\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Node insertion\n        a = np.random.randint(N)\n        b = np.random.randint(N)\n        while b == a or abs(a - b) == 1:\n            b = np.random.randint(N)\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    return new_solution\n\n",
        "score": [
            5.007475641041563,
            9.910834227293787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    rank1 = np.argsort(np.argsort(obj1))\n    rank2 = np.argsort(np.argsort(obj2))\n    norm_rank1 = rank1 / (len(archive) - 1)\n    norm_rank2 = rank2 / (len(archive) - 1)\n\n    # Dynamic weights based on solution quality\n    avg_rank = (norm_rank1 + norm_rank2) / 2\n    weights = 0.6 - 0.4 * (avg_rank - np.mean(avg_rank))\n    weights = np.clip(weights, 0.2, 0.8)\n    scores = weights * norm_rank1 + (1 - weights) * norm_rank2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.6 - 0.3 * (1 - np.mean(avg_rank)):  # Higher probability for segment reversal when solutions are diverse\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Node insertion\n        a = np.random.randint(N)\n        b = np.random.randint(N)\n        while b == a or abs(a - b) == 1:\n            b = np.random.randint(N)\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance inspired selection, then applies a novel multi-segment crossover operator that combines segments from different solutions in the archive while ensuring feasibility through a feasibility-preserving merge process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment crossover with feasibility preservation\n    N = len(base_solution)\n    new_solution = np.zeros(N, dtype=int)\n    used = set()\n\n    # Select random segments from different solutions\n    segments = []\n    for _ in range(np.random.randint(2, 5)):\n        donor_idx = np.random.randint(len(archive))\n        donor_sol = archive[donor_idx][0]\n        start = np.random.randint(N)\n        length = np.random.randint(2, max(3, N//4))\n        end = (start + length) % N\n        if start < end:\n            segment = donor_sol[start:end]\n        else:\n            segment = np.concatenate([donor_sol[start:], donor_sol[:end]])\n        segments.append(segment)\n\n    # Merge segments while preserving feasibility\n    remaining_nodes = set(range(N)) - set(base_solution)\n    current_pos = 0\n    for segment in segments:\n        for node in segment:\n            if node not in used and current_pos < N:\n                new_solution[current_pos] = node\n                used.add(node)\n                current_pos += 1\n\n    # Fill remaining positions with unused nodes\n    for node in range(N):\n        if node not in used and current_pos < N:\n            new_solution[current_pos] = node\n            current_pos += 1\n\n    return new_solution\n\n",
        "score": [
            8.407080056006182,
            8.402944844776618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment crossover with feasibility preservation\n    N = len(base_solution)\n    new_solution = np.zeros(N, dtype=int)\n    used = set()\n\n    # Select random segments from different solutions\n    segments = []\n    for _ in range(np.random.randint(2, 5)):\n        donor_idx = np.random.randint(len(archive))\n        donor_sol = archive[donor_idx][0]\n        start = np.random.randint(N)\n        length = np.random.randint(2, max(3, N//4))\n        end = (start + length) % N\n        if start < end:\n            segment = donor_sol[start:end]\n        else:\n            segment = np.concatenate([donor_sol[start:], donor_sol[:end]])\n        segments.append(segment)\n\n    # Merge segments while preserving feasibility\n    remaining_nodes = set(range(N)) - set(base_solution)\n    current_pos = 0\n    for segment in segments:\n        for node in segment:\n            if node not in used and current_pos < N:\n                new_solution[current_pos] = node\n                used.add(node)\n                current_pos += 1\n\n    # Fill remaining positions with unused nodes\n    for node in range(N):\n        if node not in used and current_pos < N:\n            new_solution[current_pos] = node\n            current_pos += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score with adaptive weights, then applies a hybrid local search combining segment rotation and node permutation with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_scores = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = 0\n        for j, (sol2, obj2) in enumerate(archive):\n            if i == j:\n                continue\n            if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select solution with lowest dominance score (most non-dominated)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.7:  # Higher probability for segment rotation\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n    else:\n        # Node permutation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if abs(a - b) > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.716701414491275,
            6.684399723683607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_scores = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = 0\n        for j, (sol2, obj2) in enumerate(archive):\n            if i == j:\n                continue\n            if obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select solution with lowest dominance score (most non-dominated)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.7:  # Higher probability for segment rotation\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n    else:\n        # Node permutation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if abs(a - b) > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining segment reversal, node insertion, and edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist[sorted_indices[0]] = np.inf\n    crowding_dist[sorted_indices[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding_dist[sorted_indices[0]] += np.inf\n    crowding_dist[sorted_indices[-1]] += np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-8)\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.695163148388799,
            8.537224674787975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist[sorted_indices[0]] = np.inf\n    crowding_dist[sorted_indices[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding_dist[sorted_indices[0]] += np.inf\n    crowding_dist[sorted_indices[-1]] += np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-8)\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The new algorithm selects a solution from the archive using a dynamic crowding distance metric to identify under-explored regions, then applies a hybrid local search combining segment reversal and node insertion with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    crowding1 = np.zeros(len(archive))\n    crowding2 = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding1[i] = np.inf\n            crowding2[i] = np.inf\n        else:\n            crowding1[i] = obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]\n            crowding2[i] = obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]\n\n    # Combine crowding distances with adaptive weights\n    diversity = np.mean(crowding1) + np.mean(crowding2)\n    weights = 0.5 + 0.3 * (diversity / (diversity + 1e-6))\n    scores = weights * crowding1 + (1 - weights) * crowding2\n\n    selected_idx = np.argmax(scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.6 + 0.2 * (diversity / (diversity + 1e-6)):  # Higher probability for segment reversal when diverse\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b:\n            return new_solution\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Node insertion\n        a = np.random.randint(N)\n        b = np.random.randint(N)\n        if a == b:\n            return new_solution\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            8.623192559563673,
            8.84368787877524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    crowding1 = np.zeros(len(archive))\n    crowding2 = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding1[i] = np.inf\n            crowding2[i] = np.inf\n        else:\n            crowding1[i] = obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]\n            crowding2[i] = obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]\n\n    # Combine crowding distances with adaptive weights\n    diversity = np.mean(crowding1) + np.mean(crowding2)\n    weights = 0.5 + 0.3 * (diversity / (diversity + 1e-6))\n    scores = weights * crowding1 + (1 - weights) * crowding2\n\n    selected_idx = np.argmax(scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.6 + 0.2 * (diversity / (diversity + 1e-6)):  # Higher probability for segment reversal when diverse\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b:\n            return new_solution\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Node insertion\n        a = np.random.randint(N)\n        b = np.random.randint(N)\n        if a == b:\n            return new_solution\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.190828403502254,
            5.724854024845336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score combining normalized costs and diversity, then applies a hybrid local search combining adaptive segment rotation, objective-aware node insertion, and conditional edge reversal with probabilistic selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1] - 0.2 * np.linspace(0, 1, len(archive))\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with objective-aware probability\n    if np.random.rand() < 0.5 * (1 - selected_idx/len(archive)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.choice(N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional edge reversal with cost evaluation\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost * 1.1:  # Allow slight degradation\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            4.565498084740369,
            7.85893708444895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1] - 0.2 * np.linspace(0, 1, len(archive))\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with objective-aware probability\n    if np.random.rand() < 0.5 * (1 - selected_idx/len(archive)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.choice(N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional edge reversal with cost evaluation\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost * 1.1:  # Allow slight degradation\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid pareto dominance and crowding distance criterion, then applies a novel local search combining adaptive segment rearrangement, node insertion, and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = []\n    remaining = list(range(len(archive)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                              (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    # Select from the best front using crowding distance\n    best_front = fronts[0]\n    if len(best_front) > 1:\n        crowding = np.zeros(len(best_front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[best_front, m])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(best_front)-1):\n                crowding[sorted_idx[i]] += (objectives[best_front[sorted_idx[i+1]], m] -\n                                           objectives[best_front[sorted_idx[i-1]], m])\n        selected_idx = best_front[np.argmax(crowding)]\n    else:\n        selected_idx = best_front[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rearrangement\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if len(segment) > 2:\n            k = np.random.randint(1, len(segment)-1)\n            rearranged_segment = np.concatenate([segment[k:], segment[:k]])\n            new_solution[a:b+1] = rearranged_segment\n\n    # Node insertion with objective-aware selection\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            # Check feasibility and repair if needed\n            if len(np.unique(new_solution)) != N:\n                new_solution = base_solution.copy()\n\n    # Conditional path inversion with multi-objective evaluation\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            inverted_segment = segment[::-1]\n            # Evaluate inversion\n            original_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(j+1)%N]]\n            inverted_cost1 = distance_matrix_1[new_solution[i-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%N]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(j+1)%N]]\n            inverted_cost2 = distance_matrix_2[new_solution[i-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%N]]\n\n            if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.2 and (inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2)):\n                new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            8.08405731366811,
            6.7174199529640815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = []\n    remaining = list(range(len(archive)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                              (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    # Select from the best front using crowding distance\n    best_front = fronts[0]\n    if len(best_front) > 1:\n        crowding = np.zeros(len(best_front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[best_front, m])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(best_front)-1):\n                crowding[sorted_idx[i]] += (objectives[best_front[sorted_idx[i+1]], m] -\n                                           objectives[best_front[sorted_idx[i-1]], m])\n        selected_idx = best_front[np.argmax(crowding)]\n    else:\n        selected_idx = best_front[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rearrangement\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if len(segment) > 2:\n            k = np.random.randint(1, len(segment)-1)\n            rearranged_segment = np.concatenate([segment[k:], segment[:k]])\n            new_solution[a:b+1] = rearranged_segment\n\n    # Node insertion with objective-aware selection\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n            # Check feasibility and repair if needed\n            if len(np.unique(new_solution)) != N:\n                new_solution = base_solution.copy()\n\n    # Conditional path inversion with multi-objective evaluation\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            inverted_segment = segment[::-1]\n            # Evaluate inversion\n            original_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(j+1)%N]]\n            inverted_cost1 = distance_matrix_1[new_solution[i-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%N]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(j+1)%N]]\n            inverted_cost2 = distance_matrix_2[new_solution[i-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%N]]\n\n            if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.2 and (inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2)):\n                new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a hybrid local search combining segment reversal, node relocation, and adaptive edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    quality_scores = np.sum(objectives, axis=1)\n    diversity_scores = np.std(objectives, axis=0)\n    combined_scores = quality_scores + np.sum(diversity_scores * objectives, axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive size\n    if np.random.rand() < 0.7:\n        seg_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Node relocation with distance-based probability\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Calculate relocation costs\n        costs = []\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                costs.append(float('inf'))\n                continue\n\n            # Calculate cost for moving node to position i\n            left = new_solution[i-1]\n            right = new_solution[i]\n            cost1 = distance_matrix_1[left, node] + distance_matrix_1[node, right] - distance_matrix_1[left, right]\n            cost2 = distance_matrix_2[left, node] + distance_matrix_2[node, right] - distance_matrix_2[left, right]\n            costs.append(cost1 + cost2)\n\n        # Select best relocation with some randomness\n        valid_positions = [i for i in range(N) if costs[i] < float('inf')]\n        if valid_positions:\n            best_pos = min(valid_positions, key=lambda x: costs[x])\n            if np.random.rand() < 0.8:  # 80% chance to accept best move\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Adaptive edge swapping\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if abs(i - j) > 1:\n            # Calculate cost difference\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j-1]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.225005075460445,
            6.092770369023003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    quality_scores = np.sum(objectives, axis=1)\n    diversity_scores = np.std(objectives, axis=0)\n    combined_scores = quality_scores + np.sum(diversity_scores * objectives, axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive size\n    if np.random.rand() < 0.7:\n        seg_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Node relocation with distance-based probability\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Calculate relocation costs\n        costs = []\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                costs.append(float('inf'))\n                continue\n\n            # Calculate cost for moving node to position i\n            left = new_solution[i-1]\n            right = new_solution[i]\n            cost1 = distance_matrix_1[left, node] + distance_matrix_1[node, right] - distance_matrix_1[left, right]\n            cost2 = distance_matrix_2[left, node] + distance_matrix_2[node, right] - distance_matrix_2[left, right]\n            costs.append(cost1 + cost2)\n\n        # Select best relocation with some randomness\n        valid_positions = [i for i in range(N) if costs[i] < float('inf')]\n        if valid_positions:\n            best_pos = min(valid_positions, key=lambda x: costs[x])\n            if np.random.rand() < 0.8:  # 80% chance to accept best move\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Adaptive edge swapping\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if abs(i - j) > 1:\n            # Calculate cost difference\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j-1]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path shifting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, min(5, b - a + 1))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            cost_diff = (distance_matrix_1[new_solution[old_pos-1], new_solution[new_pos]] +\n                         distance_matrix_1[new_solution[new_pos], new_solution[(old_pos+1)%N]] +\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[old_pos]] +\n                         distance_matrix_1[new_solution[old_pos], new_solution[(new_pos+1)%N]] -\n                         distance_matrix_1[new_solution[old_pos-1], new_solution[old_pos]] -\n                         distance_matrix_1[new_solution[old_pos], new_solution[(old_pos+1)%N]] -\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] -\n                         distance_matrix_1[new_solution[new_pos], new_solution[(new_pos+1)%N]] +\n                         distance_matrix_2[new_solution[old_pos-1], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[new_pos], new_solution[(old_pos+1)%N]] +\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[old_pos]] +\n                         distance_matrix_2[new_solution[old_pos], new_solution[(new_pos+1)%N]] -\n                         distance_matrix_2[new_solution[old_pos-1], new_solution[old_pos]] -\n                         distance_matrix_2[new_solution[old_pos], new_solution[(old_pos+1)%N]] -\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] -\n                         distance_matrix_2[new_solution[new_pos], new_solution[(new_pos+1)%N]])\n\n            if cost_diff >= 0:\n                new_solution = np.concatenate([new_solution[:new_pos], new_solution[new_pos+1:]])\n                new_solution = np.concatenate([new_solution[:old_pos], [node], new_solution[old_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shifted_path = np.roll(path, np.random.randint(1, k))\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        shifted_cost = (distance_matrix_1[new_solution[-1], shifted_path[0]] +\n                        distance_matrix_1[shifted_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], shifted_path[0]] +\n                        distance_matrix_2[shifted_path[-1], new_solution[k]])\n\n        if shifted_cost < original_cost:\n            new_solution[:k] = shifted_path\n\n    return new_solution\n\n",
        "score": [
            6.692606321386447,
            5.815820507669217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, min(5, b - a + 1))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            cost_diff = (distance_matrix_1[new_solution[old_pos-1], new_solution[new_pos]] +\n                         distance_matrix_1[new_solution[new_pos], new_solution[(old_pos+1)%N]] +\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[old_pos]] +\n                         distance_matrix_1[new_solution[old_pos], new_solution[(new_pos+1)%N]] -\n                         distance_matrix_1[new_solution[old_pos-1], new_solution[old_pos]] -\n                         distance_matrix_1[new_solution[old_pos], new_solution[(old_pos+1)%N]] -\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] -\n                         distance_matrix_1[new_solution[new_pos], new_solution[(new_pos+1)%N]] +\n                         distance_matrix_2[new_solution[old_pos-1], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[new_pos], new_solution[(old_pos+1)%N]] +\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[old_pos]] +\n                         distance_matrix_2[new_solution[old_pos], new_solution[(new_pos+1)%N]] -\n                         distance_matrix_2[new_solution[old_pos-1], new_solution[old_pos]] -\n                         distance_matrix_2[new_solution[old_pos], new_solution[(old_pos+1)%N]] -\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] -\n                         distance_matrix_2[new_solution[new_pos], new_solution[(new_pos+1)%N]])\n\n            if cost_diff >= 0:\n                new_solution = np.concatenate([new_solution[:new_pos], new_solution[new_pos+1:]])\n                new_solution = np.concatenate([new_solution[:old_pos], [node], new_solution[old_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shifted_path = np.roll(path, np.random.randint(1, k))\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        shifted_cost = (distance_matrix_1[new_solution[-1], shifted_path[0]] +\n                        distance_matrix_1[shifted_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], shifted_path[0]] +\n                        distance_matrix_2[shifted_path[-1], new_solution[k]])\n\n        if shifted_cost < original_cost:\n            new_solution[:k] = shifted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted Pareto dominance score, then applies a hybrid local search combining adaptive segment reversal with edge exchange and node insertion, using objective-specific distance matrices to guide the search while maintaining feasibility through constrained probabilistic operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                    (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated += 1\n        pareto_scores[i] = dominated\n\n    base_solution = archive[np.argmin(pareto_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        if len(segment) > 2:\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, 1)\n            new_solution[i:j+1] = segment\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        neighbors = [new_solution[(old_pos - 1) % N], new_solution[(old_pos + 1) % N]]\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(N):\n            if pos != old_pos and new_solution[pos] not in neighbors:\n                delta1 = (distance_matrix_1[new_solution[(pos - 1) % N], node] +\n                          distance_matrix_1[node, new_solution[(pos + 1) % N]] -\n                          distance_matrix_1[new_solution[(pos - 1) % N], new_solution[(pos + 1) % N]])\n                delta2 = (distance_matrix_2[new_solution[(pos - 1) % N], node] +\n                          distance_matrix_2[node, new_solution[(pos + 1) % N]] -\n                          distance_matrix_2[new_solution[(pos - 1) % N], new_solution[(pos + 1) % N]])\n                improvement = -delta1 - delta2\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.425892720656213,
            7.161085165911193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                    (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated += 1\n        pareto_scores[i] = dominated\n\n    base_solution = archive[np.argmin(pareto_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        if len(segment) > 2:\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, 1)\n            new_solution[i:j+1] = segment\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        neighbors = [new_solution[(old_pos - 1) % N], new_solution[(old_pos + 1) % N]]\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(N):\n            if pos != old_pos and new_solution[pos] not in neighbors:\n                delta1 = (distance_matrix_1[new_solution[(pos - 1) % N], node] +\n                          distance_matrix_1[node, new_solution[(pos + 1) % N]] -\n                          distance_matrix_1[new_solution[(pos - 1) % N], new_solution[(pos + 1) % N]])\n                delta2 = (distance_matrix_2[new_solution[(pos - 1) % N], node] +\n                          distance_matrix_2[node, new_solution[(pos + 1) % N]] -\n                          distance_matrix_2[new_solution[(pos - 1) % N], new_solution[(pos + 1) % N]])\n                improvement = -delta1 - delta2\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a novel local search combining adaptive segment relocation, node swapping with objective-aware evaluation, and conditional segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    sorted_indices = np.argsort(obj1)\n    crowding = np.zeros(len(archive))\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = (obj1[sorted_indices[i+1]] - obj1[sorted_indices[i-1]]) / (obj1.max() - obj1.min() + 1e-10)\n    sorted_indices = np.argsort(obj2)\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] += (obj2[sorted_indices[i+1]] - obj2[sorted_indices[i-1]]) / (obj2.max() - obj2.min() + 1e-10)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node swapping with objective-aware evaluation\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost * 1.1:  # Allow slight deterioration\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional segment inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost * 1.2:  # Allow moderate deterioration\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            8.304920007869399,
            8.198325217376482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    sorted_indices = np.argsort(obj1)\n    crowding = np.zeros(len(archive))\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = (obj1[sorted_indices[i+1]] - obj1[sorted_indices[i-1]]) / (obj1.max() - obj1.min() + 1e-10)\n    sorted_indices = np.argsort(obj2)\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] += (obj2[sorted_indices[i+1]] - obj2[sorted_indices[i-1]]) / (obj2.max() - obj2.min() + 1e-10)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node swapping with objective-aware evaluation\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost * 1.1:  # Allow slight deterioration\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional segment inversion\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost * 1.2:  # Allow moderate deterioration\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining edge exchange and segment insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on diversity\n    diversity = np.mean(norm_obj1) + np.mean(norm_obj2)\n    weights = 0.5 + 0.3 * diversity\n    scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * (1 - diversity):  # Higher probability for edge exchange when diverse\n        # Edge exchange\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            return new_solution\n\n        # Check if exchange creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[(b+1)%N] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(b+1)%N]):\n            return new_solution\n\n        # Perform exchange\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria ranking that considers both objective values and solution diversity, then applies a hybrid local search combining adaptive segment swapping, node reinsertion with inversion, and probabilistic edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    solutions = np.array([x[0] for x in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol in solutions:\n        unique_edges = len(set(zip(sol, np.roll(sol, -1))))\n        diversity_scores.append(unique_edges)\n    diversity_scores = np.array(diversity_scores)\n\n    # Combined score (objectives + diversity)\n    combined_scores = norm_obj[:, 0] * 0.4 + norm_obj[:, 1] * 0.4 + (diversity_scores / diversity_scores.max()) * 0.2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swapping\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment_len = min(3, b - a)\n        if segment_len > 0:\n            segment = new_solution[a:a+segment_len]\n            new_pos = np.random.randint(N - segment_len)\n            if new_pos >= a:\n                new_pos += segment_len\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[a+segment_len:new_pos],\n                segment, new_solution[new_pos:]\n            ])\n\n    # Node reinsertion with inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(N, size=2, replace=False)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.378724685591246,
            6.280383538236035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    solutions = np.array([x[0] for x in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol in solutions:\n        unique_edges = len(set(zip(sol, np.roll(sol, -1))))\n        diversity_scores.append(unique_edges)\n    diversity_scores = np.array(diversity_scores)\n\n    # Combined score (objectives + diversity)\n    combined_scores = norm_obj[:, 0] * 0.4 + norm_obj[:, 1] * 0.4 + (diversity_scores / diversity_scores.max()) * 0.2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swapping\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment_len = min(3, b - a)\n        if segment_len > 0:\n            segment = new_solution[a:a+segment_len]\n            new_pos = np.random.randint(N - segment_len)\n            if new_pos >= a:\n                new_pos += segment_len\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[a+segment_len:new_pos],\n                segment, new_solution[new_pos:]\n            ])\n\n    # Node reinsertion with inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.4 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(N, size=2, replace=False)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection with adaptive weights, then applies a hybrid local search combining segment rotation, node insertion, and edge swapping with probabilistic checks to ensure feasibility and diversity, while also incorporating a dynamic perturbation mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    if np.random.rand() < 0.2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.771072456826328,
            7.372595640013691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    if np.random.rand() < 0.2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining adaptive segment insertion, node swapping with objective-aware validation, and probabilistic edge rotation to generate diverse neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    base_solution = archive[np.argmax(diversity_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_pos = np.random.randint(N)\n        if new_pos < a or new_pos > b:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            if new_pos > b:\n                new_pos -= (b - a + 1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node swapping with objective-aware validation\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate potential cost change\n            delta_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]) - \\\n                         (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n            delta_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]) - \\\n                         (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if (delta_cost1 < 0 and delta_cost2 < 0) or np.random.rand() < 0.2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge rotation\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            k = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[k:], segment[:k]])\n            # Evaluate rotation\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            rotated_cost = (distance_matrix_1[new_solution[i-1], rotated_segment[0]] +\n                          distance_matrix_1[rotated_segment[-1], new_solution[(j+1)%N]] +\n                          distance_matrix_2[new_solution[i-1], rotated_segment[0]] +\n                          distance_matrix_2[rotated_segment[-1], new_solution[(j+1)%N]])\n\n            if rotated_cost <= original_cost or np.random.rand() < 0.3:\n                new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            7.128904698507942,
            7.243814587888869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    base_solution = archive[np.argmax(diversity_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_pos = np.random.randint(N)\n        if new_pos < a or new_pos > b:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            if new_pos > b:\n                new_pos -= (b - a + 1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node swapping with objective-aware validation\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate potential cost change\n            delta_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]) - \\\n                         (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n\n            delta_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]) - \\\n                         (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if (delta_cost1 < 0 and delta_cost2 < 0) or np.random.rand() < 0.2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge rotation\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            k = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[k:], segment[:k]])\n            # Evaluate rotation\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            rotated_cost = (distance_matrix_1[new_solution[i-1], rotated_segment[0]] +\n                          distance_matrix_1[rotated_segment[-1], new_solution[(j+1)%N]] +\n                          distance_matrix_2[new_solution[i-1], rotated_segment[0]] +\n                          distance_matrix_2[rotated_segment[-1], new_solution[(j+1)%N]])\n\n            if rotated_cost <= original_cost or np.random.rand() < 0.3:\n                new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights, then applies a hybrid local search combining segment reversal, node relocation, and probabilistic edge inversion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.27608986177455,
            4.495841978458046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and adaptive edge swapping to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n        if np.random.rand() < 0.3 and i > 0 and i < N-2:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.229313433662414,
            6.6882267881249655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n        if np.random.rand() < 0.3 and i > 0 and i < N-2:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment rotation, node insertion, and edge swapping with adaptive probabilistic checks to ensure feasibility and diversity while leveraging both distance matrices for multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1]][0] - objectives[sorted_indices[i-1]][0]) / (objectives[-1][0] - objectives[0][0] + 1e-8) + \\\n                                   (objectives[sorted_indices[i+1]][1] - objectives[sorted_indices[i-1]][1]) / (objectives[-1][1] - objectives[0][1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.38303514296195,
            7.9811341592945055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1]][0] - objectives[sorted_indices[i-1]][0]) / (objectives[-1][0] - objectives[0][0] + 1e-8) + \\\n                                   (objectives[sorted_indices[i+1]][1] - objectives[sorted_indices[i-1]][1]) / (objectives[-1][1] - objectives[0][1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The new algorithm selects a solution from the archive using a non-dominated sorting approach to prioritize Pareto-efficient solutions, then applies a hybrid local search combining edge insertion and segment rotation with dynamic probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated = [0] * len(archive)\n    dominating = [[] for _ in range(len(archive))]\n\n    for i, (_, obj_i) in enumerate(archive):\n        for j, (_, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating[i].append(j)\n            elif obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating[i]:\n                dominated[j] -= 1\n                if dominated[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front\n    if fronts[0]:\n        selected_idx = np.random.choice(fronts[0])\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with dynamic probabilities\n    if np.random.rand() < 0.7:  # Higher probability for edge insertion\n        # Edge insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            6.562802944788478,
            6.222199562750285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated = [0] * len(archive)\n    dominating = [[] for _ in range(len(archive))]\n\n    for i, (_, obj_i) in enumerate(archive):\n        for j, (_, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating[i].append(j)\n            elif obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating[i]:\n                dominated[j] -= 1\n                if dominated[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front\n    if fronts[0]:\n        selected_idx = np.random.choice(fronts[0])\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with dynamic probabilities\n    if np.random.rand() < 0.7:  # Higher probability for edge insertion\n        # Edge insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-based selection with dynamic weight adaptation, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    alpha = 0.5 + 0.3 * np.random.rand()\n    if np.random.rand() < alpha:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    beta = 0.4 + 0.4 * np.random.rand()\n    if np.random.rand() < beta:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    gamma = 0.3 + 0.3 * np.random.rand()\n    if np.random.rand() < gamma and N > 2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[a:b+1] = new_segment\n\n    return new_solution\n\n",
        "score": [
            7.318294668118112,
            6.656158477237135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    alpha = 0.5 + 0.3 * np.random.rand()\n    if np.random.rand() < alpha:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    beta = 0.4 + 0.4 * np.random.rand()\n    if np.random.rand() < beta:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    gamma = 0.3 + 0.3 * np.random.rand()\n    if np.random.rand() < gamma and N > 2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[a:b+1] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining node insertion, segment rotation, and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    crowding[sorted_indices[0]] = float('inf')\n    crowding[sorted_indices[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[i] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding[sorted_indices[0]] += float('inf')\n    crowding[sorted_indices[-1]] += float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[i] += objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(N)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            k = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    if np.random.rand() < 0.3:\n        # Adaptive edge swapping\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.rand() < 0.2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.373114714550722,
            10.662657508872183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    crowding[sorted_indices[0]] = float('inf')\n    crowding[sorted_indices[-1]] = float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[i] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding[sorted_indices[0]] += float('inf')\n    crowding[sorted_indices[-1]] += float('inf')\n    for i in range(1, len(archive)-1):\n        crowding[i] += objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(N)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            k = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    if np.random.rand() < 0.3:\n        # Adaptive edge swapping\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.rand() < 0.2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining node swapping, segment inversion, and probabilistic edge flipping to generate a neighbor solution while maintaining feasibility, with dynamic adjustment of operator probabilities based on recent improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 5:\n        # Select from top 30% of diverse solutions\n        diversity_scores = np.std(objectives, axis=0)\n        combined_scores = objectives[:, 0] * (1 + diversity_scores[0]) + objectives[:, 1] * (1 + diversity_scores[1])\n        selected_idx = np.argsort(combined_scores)[:max(1, len(archive)//3)][np.random.randint(max(1, len(archive)//3))]\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Dynamic operator probabilities\n    success_rates = [0.5, 0.5, 0.5]  # Initial probabilities for swapping, inversion, flipping\n\n    # Apply node swapping\n    if np.random.rand() < success_rates[0]:\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment inversion\n    if np.random.rand() < success_rates[1]:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < success_rates[2]:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip edge\n                j = (i + 1) % N\n                k = (i + 2) % N\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Update success rates based on improvement (simplified)\n    if np.random.rand() < 0.3:  # 30% chance to update probabilities\n        success_rates = [min(0.9, r + 0.1) if np.random.rand() < 0.5 else max(0.1, r - 0.1) for r in success_rates]\n\n    return new_solution\n\n",
        "score": [
            6.571217759175137,
            6.16529019645469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 5:\n        # Select from top 30% of diverse solutions\n        diversity_scores = np.std(objectives, axis=0)\n        combined_scores = objectives[:, 0] * (1 + diversity_scores[0]) + objectives[:, 1] * (1 + diversity_scores[1])\n        selected_idx = np.argsort(combined_scores)[:max(1, len(archive)//3)][np.random.randint(max(1, len(archive)//3))]\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Dynamic operator probabilities\n    success_rates = [0.5, 0.5, 0.5]  # Initial probabilities for swapping, inversion, flipping\n\n    # Apply node swapping\n    if np.random.rand() < success_rates[0]:\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply segment inversion\n    if np.random.rand() < success_rates[1]:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < success_rates[2]:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip edge\n                j = (i + 1) % N\n                k = (i + 2) % N\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Update success rates based on improvement (simplified)\n    if np.random.rand() < 0.3:  # 30% chance to update probabilities\n        success_rates = [min(0.9, r + 0.1) if np.random.rand() < 0.5 else max(0.1, r - 0.1) for r in success_rates]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score that considers both cost and solution structure, then applies a novel local search combining adaptive segment rotation with objective-balanced node insertion, followed by a conditional path contraction to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on diversity-aware objective score\n    objectives = np.array([x[1] for x in archive])\n    norm_obj1 = (objectives[:, 0] - objectives[:, 0].min()) / (objectives[:, 0].max() - objectives[:, 0].min() + 1e-8)\n    norm_obj2 = (objectives[:, 1] - objectives[:, 1].min()) / (objectives[:, 1].max() - objectives[:, 1].min() + 1e-8)\n    diversity_scores = norm_obj1 * 0.7 + norm_obj2 * 0.3 + 0.2 * (np.arange(len(archive)) / len(archive))\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        rotation = np.random.randint(1, k)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_segment\n\n    # Objective-balanced node insertion\n    if np.random.rand() < 0.6:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n            # Evaluate insertion\n            obj1_diff = (distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], node] -\n                         distance_matrix_1[node, new_solution[(i+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], node] -\n                         distance_matrix_2[node, new_solution[(i+1)%N]])\n\n            if obj1_diff + obj2_diff > 0:\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Conditional path contraction\n    if np.random.rand() < 0.4 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            contracted_segment = np.array([segment[0], segment[-1]])\n\n            # Evaluate contraction\n            original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                            distance_matrix_2[new_solution[a-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n            contracted_cost = (distance_matrix_1[new_solution[a-1], contracted_segment[0]] +\n                              distance_matrix_1[contracted_segment[-1], new_solution[(b+1)%N]] +\n                              distance_matrix_2[new_solution[a-1], contracted_segment[0]] +\n                              distance_matrix_2[contracted_segment[-1], new_solution[(b+1)%N]])\n\n            if contracted_cost < original_cost:\n                new_solution[a:b+1] = contracted_segment\n\n    return new_solution\n\n",
        "score": [
            5.479459569982873,
            8.389180274696724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on diversity-aware objective score\n    objectives = np.array([x[1] for x in archive])\n    norm_obj1 = (objectives[:, 0] - objectives[:, 0].min()) / (objectives[:, 0].max() - objectives[:, 0].min() + 1e-8)\n    norm_obj2 = (objectives[:, 1] - objectives[:, 1].min()) / (objectives[:, 1].max() - objectives[:, 1].min() + 1e-8)\n    diversity_scores = norm_obj1 * 0.7 + norm_obj2 * 0.3 + 0.2 * (np.arange(len(archive)) / len(archive))\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        rotation = np.random.randint(1, k)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_segment\n\n    # Objective-balanced node insertion\n    if np.random.rand() < 0.6:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n            # Evaluate insertion\n            obj1_diff = (distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], node] -\n                         distance_matrix_1[node, new_solution[(i+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], node] -\n                         distance_matrix_2[node, new_solution[(i+1)%N]])\n\n            if obj1_diff + obj2_diff > 0:\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Conditional path contraction\n    if np.random.rand() < 0.4 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            contracted_segment = np.array([segment[0], segment[-1]])\n\n            # Evaluate contraction\n            original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                            distance_matrix_2[new_solution[a-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n            contracted_cost = (distance_matrix_1[new_solution[a-1], contracted_segment[0]] +\n                              distance_matrix_1[contracted_segment[-1], new_solution[(b+1)%N]] +\n                              distance_matrix_2[new_solution[a-1], contracted_segment[0]] +\n                              distance_matrix_2[contracted_segment[-1], new_solution[(b+1)%N]])\n\n            if contracted_cost < original_cost:\n                new_solution[a:b+1] = contracted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective priority score that adapts to the current distribution of solutions, then applies a hybrid local search combining multi-segment crossover, adaptive node insertion, and probabilistic edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        std_devs = np.std(objectives, axis=0)\n        priority_weights = std_devs / np.sum(std_devs)\n        combined_scores = objectives[:, 0] * priority_weights[0] + objectives[:, 1] * priority_weights[1]\n        base_solution = archive[np.argmin(combined_scores)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment crossover\n    if np.random.rand() < 0.5:\n        other_solution = archive[np.random.randint(len(archive))][0]\n        crossover_points = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[crossover_points[0]:crossover_points[1]] = other_solution[crossover_points[0]:crossover_points[1]]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insertion_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insertion_pos], [node], new_solution[insertion_pos:]])\n\n    # Probabilistic edge inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if np.random.rand() < 0.7:\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                new_solution[i:j+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    return new_solution\n\n",
        "score": [
            6.390968926856608,
            5.863443226786319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        std_devs = np.std(objectives, axis=0)\n        priority_weights = std_devs / np.sum(std_devs)\n        combined_scores = objectives[:, 0] * priority_weights[0] + objectives[:, 1] * priority_weights[1]\n        base_solution = archive[np.argmin(combined_scores)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment crossover\n    if np.random.rand() < 0.5:\n        other_solution = archive[np.random.randint(len(archive))][0]\n        crossover_points = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[crossover_points[0]:crossover_points[1]] = other_solution[crossover_points[0]:crossover_points[1]]\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insertion_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insertion_pos], [node], new_solution[insertion_pos:]])\n\n    # Probabilistic edge inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if np.random.rand() < 0.7:\n                new_solution[i:j+1] = segment[::-1]\n            else:\n                new_solution[i:j+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and exploration of diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            fronts.append(i)\n\n    if fronts:\n        selected_idx = np.random.choice(fronts)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    segment_len = min(5, N // 3)\n    a = np.random.randint(N - segment_len)\n    b = a + segment_len\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos], new_solution[new_pos-1] = new_solution[new_pos-1], new_solution[new_pos]\n\n    return new_solution\n\n",
        "score": [
            6.132520542402044,
            7.15068497434713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            fronts.append(i)\n\n    if fronts:\n        selected_idx = np.random.choice(fronts)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    segment_len = min(5, N // 3)\n    a = np.random.randint(N - segment_len)\n    b = a + segment_len\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos], new_solution[new_pos-1] = new_solution[new_pos-1], new_solution[new_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment inversion, node relocation, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, N-1)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.566362536733099,
            7.207776883931704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, N-1)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and edge reconnection with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i > 0 and j < N-1:\n            new_solution[i], new_solution[j+1] = new_solution[j+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.569466035213875,
            8.462864989110534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i > 0 and j < N-1:\n            new_solution[i], new_solution[j+1] = new_solution[j+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection criterion, then applies a hybrid local search combining segment rotation, node swapping, and edge exchange with dynamic probabilistic checks to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    if np.random.rand() < 0.4 and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.549970186296292,
            7.485700242206792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    if np.random.rand() < 0.4 and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining node chain inversion, segment rotation, and adaptive edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives, axis=0)\n        crowding_distances = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n            crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n            crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    crowding_distances[sorted_indices[i, obj_idx]] += 0\n                else:\n                    crowding_distances[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            chain_length = np.random.randint(1, min(5, b - a))\n            new_solution[a:a+chain_length] = new_solution[a:a+chain_length][::-1]\n            new_solution[b-chain_length+1:b+1] = new_solution[b-chain_length+1:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start_pos = np.random.randint(0, N - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start_pos:start_pos+segment_length] = np.roll(segment, rotation)\n\n    if np.random.rand() < 0.3:\n        node1, node2 = np.random.choice(N, size=2, replace=False)\n        if abs(node1 - node2) > 1:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            8.119457184301863,
            10.748796568865787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives, axis=0)\n        crowding_distances = np.zeros(len(archive))\n\n        for obj_idx in range(2):\n            sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n            crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n            crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    crowding_distances[sorted_indices[i, obj_idx]] += 0\n                else:\n                    crowding_distances[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            chain_length = np.random.randint(1, min(5, b - a))\n            new_solution[a:a+chain_length] = new_solution[a:a+chain_length][::-1]\n            new_solution[b-chain_length+1:b+1] = new_solution[b-chain_length+1:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start_pos = np.random.randint(0, N - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start_pos:start_pos+segment_length] = np.roll(segment, rotation)\n\n    if np.random.rand() < 0.3:\n        node1, node2 = np.random.choice(N, size=2, replace=False)\n        if abs(node1 - node2) > 1:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hyperbolic combination of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probability thresholds to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 1 / (1 + norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.552467869975372,
            8.210929934520923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 1 / (1 + norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining edge insertion and segment rotation with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [objectives]  # For simplicity, assume all solutions are non-dominated\n    crowding_distances = np.zeros(len(archive))\n\n    for front in fronts:\n        if len(front) > 0:\n            sorted_front = front[np.argsort(front[:, 0])]\n            crowding_distances[np.argsort(front[:, 0])] = np.linspace(0, 1, len(front))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.3 + 0.4 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        # Edge insertion\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n        insert_pos = np.random.randint(0, len(new_solution) - len(segment) + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution = np.concatenate([new_solution[:a], np.roll(segment, rotation), new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            10.439019048835457,
            10.669193256900702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [objectives]  # For simplicity, assume all solutions are non-dominated\n    crowding_distances = np.zeros(len(archive))\n\n    for front in fronts:\n        if len(front) > 0:\n            sorted_front = front[np.argsort(front[:, 0])]\n            crowding_distances[np.argsort(front[:, 0])] = np.linspace(0, 1, len(front))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.3 + 0.4 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        # Edge insertion\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n        insert_pos = np.random.randint(0, len(new_solution) - len(segment) + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution = np.concatenate([new_solution[:a], np.roll(segment, rotation), new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.5 for each objective), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks for feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.847059966637404,
            6.102882078810089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized crowding distance metric to promote diversity, then applies a hybrid local search combining adaptive edge swapping and segment rotation that considers both objective spaces simultaneously to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized_obj[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (normalized_obj[sorted_idx[i+1], m] - normalized_obj[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive edge swapping and segment rotation\n    if np.random.rand() < 0.5:\n        # Adaptive edge swapping\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N-1)) % N\n        k = (j + np.random.randint(1, N-1)) % N\n\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n\n        # Check if the swap is valid\n        if (j - i) % N > 1 and (k - j) % N > 1:\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        shift = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], shift)\n\n    return new_solution\n\n",
        "score": [
            10.142605473356845,
            9.444566393632128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized_obj[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (normalized_obj[sorted_idx[i+1], m] - normalized_obj[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive edge swapping and segment rotation\n    if np.random.rand() < 0.5:\n        # Adaptive edge swapping\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N-1)) % N\n        k = (j + np.random.randint(1, N-1)) % N\n\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n\n        # Check if the swap is valid\n        if (j - i) % N > 1 and (k - j) % N > 1:\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        shift = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance criterion, then applies a hybrid local search combining adaptive k-opt moves, dynamic node insertion, and conditional segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive k-opt move (k=3 or 4)\n    if np.random.rand() < 0.6:\n        k = np.random.choice([3, 4])\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        segment = new_solution[indices[0]:indices[-1]+1]\n        k_perm = np.random.permutation(segment)\n        new_segment = np.concatenate([new_solution[:indices[0]], k_perm, new_solution[indices[-1]+1:]])\n\n        # Evaluate the move\n        original_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N)) + \\\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        new_cost = sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(N)) + \\\n                  sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(N))\n\n        if new_cost < original_cost:\n            new_solution = new_segment\n\n    # Dynamic node insertion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            node = new_solution[i]\n            new_segment = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n            # Evaluate the move\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            new_cost = (distance_matrix_1[new_segment[i-1], new_segment[i]] +\n                       distance_matrix_1[new_segment[i], new_segment[i+1]] +\n                       distance_matrix_1[new_segment[j], new_segment[(j+1)%N]] +\n                       distance_matrix_2[new_segment[i-1], new_segment[i]] +\n                       distance_matrix_2[new_segment[i], new_segment[i+1]] +\n                       distance_matrix_2[new_segment[j], new_segment[(j+1)%N]])\n\n            if new_cost < original_cost:\n                new_solution = new_segment\n\n    # Conditional segment inversion with objective-aware selection\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            inverted_segment = segment[::-1]\n\n            # Evaluate the inversion\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            inverted_cost = (distance_matrix_1[new_solution[i-1], inverted_segment[0]] +\n                           distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], inverted_segment[0]] +\n                           distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%N]])\n\n            if inverted_cost < original_cost:\n                new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            6.100244357391359,
            5.880065125712198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive k-opt move (k=3 or 4)\n    if np.random.rand() < 0.6:\n        k = np.random.choice([3, 4])\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        segment = new_solution[indices[0]:indices[-1]+1]\n        k_perm = np.random.permutation(segment)\n        new_segment = np.concatenate([new_solution[:indices[0]], k_perm, new_solution[indices[-1]+1:]])\n\n        # Evaluate the move\n        original_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N)) + \\\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        new_cost = sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(N)) + \\\n                  sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(N))\n\n        if new_cost < original_cost:\n            new_solution = new_segment\n\n    # Dynamic node insertion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            node = new_solution[i]\n            new_segment = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n            # Evaluate the move\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            new_cost = (distance_matrix_1[new_segment[i-1], new_segment[i]] +\n                       distance_matrix_1[new_segment[i], new_segment[i+1]] +\n                       distance_matrix_1[new_segment[j], new_segment[(j+1)%N]] +\n                       distance_matrix_2[new_segment[i-1], new_segment[i]] +\n                       distance_matrix_2[new_segment[i], new_segment[i+1]] +\n                       distance_matrix_2[new_segment[j], new_segment[(j+1)%N]])\n\n            if new_cost < original_cost:\n                new_solution = new_segment\n\n    # Conditional segment inversion with objective-aware selection\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            inverted_segment = segment[::-1]\n\n            # Evaluate the inversion\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            inverted_cost = (distance_matrix_1[new_solution[i-1], inverted_segment[0]] +\n                           distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], inverted_segment[0]] +\n                           distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%N]])\n\n            if inverted_cost < original_cost:\n                new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that prioritizes solutions with balanced improvement potential in both objectives, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path shifting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.abs(norm_objectives[:, 0] - norm_objectives[:, 1])\n    base_solution = archive[np.argmin(balance_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            # Evaluate insertion\n            if new_pos > 0 and new_pos < N-1:\n                original_cost = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] +\n                                distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] +\n                                distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                                distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]])\n                new_cost = (distance_matrix_1[new_solution[new_pos-1], node] +\n                           distance_matrix_1[node, new_solution[new_pos+1]] +\n                           distance_matrix_2[new_solution[new_pos-1], node] +\n                           distance_matrix_2[node, new_solution[new_pos+1]])\n\n                if new_cost >= original_cost and np.random.rand() < 0.3:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Conditional path shifting\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shifted_path = np.concatenate([new_solution[k:2*k], path])\n\n        # Evaluate shifting\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        shifted_cost = (distance_matrix_1[new_solution[-1], shifted_path[0]] +\n                       distance_matrix_1[shifted_path[-1], new_solution[k]] +\n                       distance_matrix_2[new_solution[-1], shifted_path[0]] +\n                       distance_matrix_2[shifted_path[-1], new_solution[k]])\n\n        if shifted_cost < original_cost:\n            new_solution[:2*k] = shifted_path\n\n    return new_solution\n\n",
        "score": [
            7.819711269170017,
            7.384216402610914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.abs(norm_objectives[:, 0] - norm_objectives[:, 1])\n    base_solution = archive[np.argmin(balance_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            # Evaluate insertion\n            if new_pos > 0 and new_pos < N-1:\n                original_cost = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] +\n                                distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] +\n                                distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                                distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]])\n                new_cost = (distance_matrix_1[new_solution[new_pos-1], node] +\n                           distance_matrix_1[node, new_solution[new_pos+1]] +\n                           distance_matrix_2[new_solution[new_pos-1], node] +\n                           distance_matrix_2[node, new_solution[new_pos+1]])\n\n                if new_cost >= original_cost and np.random.rand() < 0.3:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    # Conditional path shifting\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shifted_path = np.concatenate([new_solution[k:2*k], path])\n\n        # Evaluate shifting\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        shifted_cost = (distance_matrix_1[new_solution[-1], shifted_path[0]] +\n                       distance_matrix_1[shifted_path[-1], new_solution[k]] +\n                       distance_matrix_2[new_solution[-1], shifted_path[0]] +\n                       distance_matrix_2[shifted_path[-1], new_solution[k]])\n\n        if shifted_cost < original_cost:\n            new_solution[:2*k] = shifted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective weighting that adapts to the solution's dominance in the Pareto front, then applies a hybrid local search combining segment rotation, node exchange, and partial path reversal with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_counts = np.sum((objectives[:, None, :] <= objectives) & (objectives[:, None, :] != objectives), axis=2).sum(axis=1)\n    weights = 1 / (1 + dominated_counts)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.989807866034731,
            6.968456351437291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_counts = np.sum((objectives[:, None, :] <= objectives) & (objectives[:, None, :] != objectives), axis=2).sum(axis=1)\n    weights = 1 / (1 + dominated_counts)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining segment rotation, node inversion, and adaptive edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    archive_sorted = [archive[i] for i in sorted_indices]\n    crowding_distances = np.zeros(len(archive_sorted))\n    for i in range(1, len(archive_sorted)-1):\n        crowding_distances[i] = (objectives[i+1, 0] - objectives[i-1, 0]) + (objectives[i+1, 1] - objectives[i-1, 1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            8.203828187698866,
            7.282404942142225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    archive_sorted = [archive[i] for i in sorted_indices]\n    crowding_distances = np.zeros(len(archive_sorted))\n    for i in range(1, len(archive_sorted)-1):\n        crowding_distances[i] = (objectives[i+1, 0] - objectives[i-1, 0]) + (objectives[i+1, 1] - objectives[i-1, 1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominance_scores = np.sum(objectives < objectives[None, :], axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Edge swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i > 0 and j < N-1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.785218504932269,
            7.9094350754364395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominance_scores = np.sum(objectives < objectives[None, :], axis=1)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Edge swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i > 0 and j < N-1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted product of normalized objectives with fixed weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Fixed weights for weighted product\n    weight1 = 0.6\n    weight2 = 0.4\n\n    scores = (weight1 * norm_obj1) * (weight2 * norm_obj2)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            8.722327491065727,
            6.461826081084567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Fixed weights for weighted product\n    weight1 = 0.6\n    weight2 = 0.4\n\n    scores = (weight1 * norm_obj1) * (weight2 * norm_obj2)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.5 + 0.2 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized combined objective score with adaptive weights that emphasize the objective with higher variance, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    obj_vars = objectives.std(axis=0)\n    weights = obj_vars / obj_vars.sum()\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.251008271966794,
            6.119452386173771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    obj_vars = objectives.std(axis=0)\n    weights = obj_vars / obj_vars.sum()\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node insertion, and edge swapping with probabilistic checks to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_nodes = len(set(sol[:len(sol)//2]))\n        diversity_scores.append(unique_nodes)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        rotated = np.concatenate([segment[c-b:], segment[:c-b]])\n        new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.7:\n        # Node insertion with position adjustment\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(N)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        # Edge swapping\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.530117005359547,
            7.556621007903354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_nodes = len(set(sol[:len(sol)//2]))\n        diversity_scores.append(unique_nodes)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        rotated = np.concatenate([segment[c-b:], segment[:c-b]])\n        new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.7:\n        # Node insertion with position adjustment\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(N)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        # Edge swapping\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance analysis, then applies a hybrid local search combining adaptive segment rotation, node insertion with edge evaluation, and probabilistic inversion of critical segments to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        rotation = np.random.randint(1, min(10, b - a + 1))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidate_positions = [i for i in range(N) if i != old_pos and (i == 0 or new_solution[i-1] != node) and (i == N-1 or new_solution[i+1] != node)]\n\n        if candidate_positions:\n            best_pos = None\n            best_score = float('inf')\n\n            for pos in candidate_positions:\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, old_pos)\n                temp_solution = np.insert(temp_solution, pos, node)\n\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                score = 0.4 * cost1 + 0.6 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            if best_pos is not None:\n                new_solution = np.delete(new_solution, old_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if np.random.rand() < 0.3 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%N]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n\n            cost_after = (distance_matrix_1[new_solution[a-1], segment[-1]] +\n                         distance_matrix_1[segment[0], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[-1]] +\n                         distance_matrix_2[segment[0], new_solution[(b+1)%N]])\n\n            if cost_after < cost_before:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.289446545499131,
            6.099681195500561
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        rotation = np.random.randint(1, min(10, b - a + 1))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        candidate_positions = [i for i in range(N) if i != old_pos and (i == 0 or new_solution[i-1] != node) and (i == N-1 or new_solution[i+1] != node)]\n\n        if candidate_positions:\n            best_pos = None\n            best_score = float('inf')\n\n            for pos in candidate_positions:\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, old_pos)\n                temp_solution = np.insert(temp_solution, pos, node)\n\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                score = 0.4 * cost1 + 0.6 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            if best_pos is not None:\n                new_solution = np.delete(new_solution, old_pos)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if np.random.rand() < 0.3 and N > 4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%N]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n\n            cost_after = (distance_matrix_1[new_solution[a-1], segment[-1]] +\n                         distance_matrix_1[segment[0], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[-1]] +\n                         distance_matrix_2[segment[0], new_solution[(b+1)%N]])\n\n            if cost_after < cost_before:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives that adapts to the solution's position in the Pareto front, then applies a hybrid local search combining segment inversion, node transposition, and probabilistic edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = objectives.max(axis=0) - objectives.min(axis=0)\n    weights = crowding_dist / crowding_dist.sum() if crowding_dist.sum() > 0 else [0.5, 0.5]\n    combined_scores = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N//2)) % N\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.755688793964552,
            5.691934368535739
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = objectives.max(axis=0) - objectives.min(axis=0)\n    weights = crowding_dist / crowding_dist.sum() if crowding_dist.sum() > 0 else [0.5, 0.5]\n    combined_scores = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N//2)) % N\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on dominance ranking and applies a hybrid local search combining edge insertion and segment inversion with dynamic operator selection to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Dynamic operator selection\n    operator_prob = np.random.rand()\n\n    if operator_prob < 0.4:\n        # Edge insertion\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n    elif operator_prob < 0.8:\n        # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Double bridge move\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:a], new_solution[b:c], new_solution[a:b],\n            new_solution[c:d], new_solution[d:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            5.940043559720414,
            6.201237054063471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Dynamic operator selection\n    operator_prob = np.random.rand()\n\n    if operator_prob < 0.4:\n        # Edge insertion\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n    elif operator_prob < 0.8:\n        # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Double bridge move\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:a], new_solution[b:c], new_solution[a:b],\n            new_solution[c:d], new_solution[d:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Evaluate insertion\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n            new_cost = (distance_matrix_1[new_solution[j-1], node] +\n                        distance_matrix_1[node, new_solution[(j+1)%N]] +\n                        distance_matrix_2[new_solution[j-1], node] +\n                        distance_matrix_2[node, new_solution[(j+1)%N]])\n\n            if new_cost >= original_cost:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                          distance_matrix_1[path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], path[0]] +\n                          distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            6.143794286433276,
            5.98414235899334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Evaluate insertion\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n            new_cost = (distance_matrix_1[new_solution[j-1], node] +\n                        distance_matrix_1[node, new_solution[(j+1)%N]] +\n                        distance_matrix_2[new_solution[j-1], node] +\n                        distance_matrix_2[node, new_solution[(j+1)%N]])\n\n            if new_cost >= original_cost:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                          distance_matrix_1[path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], path[0]] +\n                          distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score (weighted by solution age and objective diversity), then applies a hybrid local search combining adaptive segment inversion, node swapping with objective-aware selection, and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + np.std(np.array([s[1] for s in archive]))))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        inverted_segment = np.concatenate([segment[k:], segment[:k][::-1]])\n        new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if obj1_diff + obj2_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            obj1_diff = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], segment[0]] -\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], segment[0]] -\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n\n            if obj1_diff + obj2_diff < 0:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            7.5179957484791915,
            6.505097283782392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + np.std(np.array([s[1] for s in archive]))))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        inverted_segment = np.concatenate([segment[k:], segment[:k][::-1]])\n        new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if obj1_diff + obj2_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            obj1_diff = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], segment[0]] -\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%N]])\n            obj2_diff = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], segment[0]] -\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n\n            if obj1_diff + obj2_diff < 0:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamically adjusted score combining objectives with 60% weight for the first objective and 40% for the second, then applies a hybrid local search including segment reversal, node relocation, and edge inversion with probabilistic checks to balance feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.83701281331884,
            8.013189007821543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel local search combining adaptive node clustering and inter-cluster permutation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution that is different from the best one\n        archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n        selected = archive[np.random.choice(min(3, len(archive)))][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive node clustering and inter-cluster permutation\n    if N > 3:\n        # Cluster nodes based on their positions in both spaces\n        cluster_size = max(2, N // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, N, cluster_size)]\n\n        # Permute clusters with probability based on their size\n        for i in range(len(clusters)):\n            if np.random.rand() < 0.5 * (len(clusters[i]) / N):\n                j = np.random.randint(len(clusters))\n                if i != j:\n                    clusters[i], clusters[j] = clusters[j], clusters[i]\n\n        # Reconstruct solution from permuted clusters\n        new_solution = np.concatenate(clusters)\n\n        # Apply local refinement within clusters\n        for cluster in clusters:\n            if len(cluster) > 2 and np.random.rand() < 0.3:\n                i, j = sorted(np.random.choice(len(cluster), size=2, replace=False))\n                cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    # Final local optimization\n    if np.random.rand() < 0.6:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            # Evaluate potential swap\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.226745902195341,
            6.147714685049289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution that is different from the best one\n        archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n        selected = archive[np.random.choice(min(3, len(archive)))][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive node clustering and inter-cluster permutation\n    if N > 3:\n        # Cluster nodes based on their positions in both spaces\n        cluster_size = max(2, N // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, N, cluster_size)]\n\n        # Permute clusters with probability based on their size\n        for i in range(len(clusters)):\n            if np.random.rand() < 0.5 * (len(clusters[i]) / N):\n                j = np.random.randint(len(clusters))\n                if i != j:\n                    clusters[i], clusters[j] = clusters[j], clusters[i]\n\n        # Reconstruct solution from permuted clusters\n        new_solution = np.concatenate(clusters)\n\n        # Apply local refinement within clusters\n        for cluster in clusters:\n            if len(cluster) > 2 and np.random.rand() < 0.3:\n                i, j = sorted(np.random.choice(len(cluster), size=2, replace=False))\n                cluster[i], cluster[j] = cluster[j], cluster[i]\n\n    # Final local optimization\n    if np.random.rand() < 0.6:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            # Evaluate potential swap\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of normalized objective values, then applies a hybrid local search combining segment rotation, node swapping, and adaptive edge insertion to generate a neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dynamic_weights = np.random.dirichlet([1, 1])\n    combined_scores = norm_objectives[:, 0] * dynamic_weights[0] + norm_objectives[:, 1] * dynamic_weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != pos:\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.806888041400775,
            6.481792178909816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dynamic_weights = np.random.dirichlet([1, 1])\n    combined_scores = norm_objectives[:, 0] * dynamic_weights[0] + norm_objectives[:, 1] * dynamic_weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != pos:\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining node insertion, edge exchange, and probabilistic segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i+1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if b - a > 1 and c - b > 1:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n\n    return new_solution\n\n",
        "score": [
            9.316890859117242,
            7.875321184043784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i+1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if b - a > 1 and c - b > 1:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novelty-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and adaptive edge swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    novelty_scores = np.max(objectives, axis=0) - objectives\n    weights = novelty_scores / (np.sum(novelty_scores, axis=0, keepdims=True) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0, 0] + objectives[:, 1] * weights[0, 1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n        if np.random.rand() < 0.3 and j > 0 and j < N-1:\n            new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            10.525445063600696,
            10.63249649824353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    novelty_scores = np.max(objectives, axis=0) - objectives\n    weights = novelty_scores / (np.sum(novelty_scores, axis=0, keepdims=True) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0, 0] + objectives[:, 1] * weights[0, 1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n        if np.random.rand() < 0.3 and j > 0 and j < N-1:\n            new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity measures, then applies a hybrid local search combining segment insertion and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    diversity = np.array([len(set(sol)) for sol, _ in archive])\n    scores = obj_values / (diversity + 1e-6)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.5:\n        # Segment insertion\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    else:\n        # Node swapping\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.369207941484651,
            5.778567926842948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj_values = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    diversity = np.array([len(set(sol)) for sol, _ in archive])\n    scores = obj_values / (diversity + 1e-6)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Adaptive local search operator selection\n    if np.random.rand() < 0.5:\n        # Segment insertion\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    else:\n        # Node swapping\n        a, b = np.random.choice(N, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The new algorithm selects a solution from the archive using a dynamic weighting scheme that prioritizes under-explored objective regions, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = [x[1][0] for x in archive]\n    obj2_vals = [x[1][1] for x in archive]\n    obj1_range = max(obj1_vals) - min(obj1_vals)\n    obj2_range = max(obj2_vals) - min(obj2_vals)\n\n    weight1 = 0.7 if obj1_range > obj2_range else 0.3\n    weight2 = 1 - weight1\n\n    selected = min(archive, key=lambda x: weight1*x[1][0] + weight2*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment reversal + node swapping\n    if np.random.rand() < 0.6:  # 60% chance for segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional node swapping if beneficial\n    if np.random.rand() < 0.3:  # 30% chance for additional swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n        total_cost = cost1 + cost2\n\n        orig_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N))\n        orig_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N))\n        orig_total = orig_cost1 + orig_cost2\n\n        if total_cost < orig_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.994878808001261,
            5.4804701941569745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_vals = [x[1][0] for x in archive]\n    obj2_vals = [x[1][1] for x in archive]\n    obj1_range = max(obj1_vals) - min(obj1_vals)\n    obj2_range = max(obj2_vals) - min(obj2_vals)\n\n    weight1 = 0.7 if obj1_range > obj2_range else 0.3\n    weight2 = 1 - weight1\n\n    selected = min(archive, key=lambda x: weight1*x[1][0] + weight2*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment reversal + node swapping\n    if np.random.rand() < 0.6:  # 60% chance for segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional node swapping if beneficial\n    if np.random.rand() < 0.3:  # 30% chance for additional swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n        total_cost = cost1 + cost2\n\n        orig_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N))\n        orig_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N))\n        orig_total = orig_cost1 + orig_cost2\n\n        if total_cost < orig_total:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective selection, then applies a hybrid local search combining segment inversion and node swapping with adaptive probabilities, while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity_scores = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(diversity_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment inversion with node swapping\n    if np.random.rand() < 0.6:\n        # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n    else:\n        # Node swapping with distance-based selection\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap improves diversity\n        original_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if np.random.rand() < 0.7 or (abs(new_dist1 - new_dist2) > abs(original_dist1 - original_dist2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.984869330091808,
            5.79650044406678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    diversity_scores = np.abs(obj1 - obj2)\n    selected_idx = np.argmax(diversity_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment inversion with node swapping\n    if np.random.rand() < 0.6:\n        # Segment inversion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n    else:\n        # Node swapping with distance-based selection\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap improves diversity\n        original_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if np.random.rand() < 0.7 or (abs(new_dist1 - new_dist2) > abs(original_dist1 - original_dist2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamically weighted objective score that balances diversity and convergence, then applies a hybrid local search combining adaptive segment rotation, node transposition, and conditional edge reversal with enhanced acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    weights = np.std(costs, axis=0) / np.mean(costs, axis=0)\n    weights = weights / np.sum(weights)\n\n    archive.sort(key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with probability based on solution quality\n    quality_score = (weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]) / np.mean(costs)\n    if np.random.rand() < 0.5 * quality_score:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with enhanced acceptance criteria\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost <= original_cost * 1.1:  # Allow slight cost increase\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal with probability based on segment length\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment_length = j - i + 1\n        if segment_length > 2 and segment_length < N/2:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost <= original_cost * 1.05:  # Allow small cost increase\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.486411840865416,
            6.410988798508834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    weights = np.std(costs, axis=0) / np.mean(costs, axis=0)\n    weights = weights / np.sum(weights)\n\n    archive.sort(key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with probability based on solution quality\n    quality_score = (weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]) / np.mean(costs)\n    if np.random.rand() < 0.5 * quality_score:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with enhanced acceptance criteria\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost <= original_cost * 1.1:  # Allow slight cost increase\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal with probability based on segment length\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment_length = j - i + 1\n        if segment_length > 2 and segment_length < N/2:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost <= original_cost * 1.05:  # Allow small cost increase\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance criterion, then applies a hybrid local search combining multi-segment reordering with adaptive node insertion and conditional path rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol in archive:\n        dominated = False\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        non_dominated.sort(key=lambda x: -(x[1][0] + x[1][1]))\n        base_solution = non_dominated[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment reordering\n    if np.random.rand() < 0.7:\n        num_segments = np.random.randint(2, min(5, N//3))\n        segment_indices = sorted(np.random.choice(range(1, N-1), num_segments, replace=False))\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.5:\n        i = np.random.randint(1, N-1)\n        j = np.random.randint(1, N-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Conditional path rotation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        rotation_point = np.random.randint(0, k)\n        rotated = np.concatenate([new_solution[rotation_point:k], new_solution[:rotation_point]])\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated[0]] +\n                        distance_matrix_1[rotated[k-rotation_point-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated[0]] +\n                        distance_matrix_2[rotated[k-rotation_point-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated\n\n    return new_solution\n\n",
        "score": [
            8.303482089268446,
            7.160901400625173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol in archive:\n        dominated = False\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        non_dominated.sort(key=lambda x: -(x[1][0] + x[1][1]))\n        base_solution = non_dominated[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-segment reordering\n    if np.random.rand() < 0.7:\n        num_segments = np.random.randint(2, min(5, N//3))\n        segment_indices = sorted(np.random.choice(range(1, N-1), num_segments, replace=False))\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.5:\n        i = np.random.randint(1, N-1)\n        j = np.random.randint(1, N-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Conditional path rotation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        rotation_point = np.random.randint(0, k)\n        rotated = np.concatenate([new_solution[rotation_point:k], new_solution[:rotation_point]])\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated[0]] +\n                        distance_matrix_1[rotated[k-rotation_point-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated[0]] +\n                        distance_matrix_2[rotated[k-rotation_point-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with adaptive weights, then applies a hybrid local search combining 3-opt and segment reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    if max1 != min1:\n        norm_obj1 = (obj1 - min1) / (max1 - min1)\n    else:\n        norm_obj1 = np.ones_like(obj1)\n    if max2 != min2:\n        norm_obj2 = (obj2 - min2) / (max2 - min2)\n    else:\n        norm_obj2 = np.ones_like(obj2)\n\n    # Adaptive weights based on objective ranges\n    range1 = max1 - min1\n    range2 = max2 - min2\n    total_range = range1 + range2\n    if total_range > 0:\n        weight1 = range1 / total_range\n        weight2 = range2 / total_range\n    else:\n        weight1 = 0.5\n        weight2 = 0.5\n\n    scores = weight1 * norm_obj1 + weight2 * norm_obj2\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic local search operator selection\n    if np.random.rand() < 0.4 + 0.3 * weight1:  # Higher probability for 3-opt when first objective is more important\n        # 3-opt\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        if a == b or b == c or a == c:\n            return new_solution\n\n        # Check if 3-opt creates valid tour\n        if (new_solution[(a-1)%N] == new_solution[b] or new_solution[(a-1)%N] == new_solution[c] or\n            new_solution[a] == new_solution[(b-1)%N] or new_solution[a] == new_solution[(c-1)%N] or\n            new_solution[b] == new_solution[(c-1)%N] or new_solution[b] == new_solution[a]):\n            return new_solution\n\n        # Perform 3-opt\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric that prioritizes solutions in less crowded regions of the objective space, then applies a novel \"node chain rearrangement\" local search operator that moves sequences of nodes between random positions while preserving tour validity and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n        crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            idx = sorted_indices[i, obj_idx]\n            crowding_distances[idx] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with lowest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain rearrangement\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    chain_length = min(5, b - a)  # Limit chain length to prevent excessive changes\n    if chain_length > 1:\n        chain = new_solution[a:a+chain_length]\n        new_pos = np.random.randint(0, N - chain_length)\n        if new_pos >= a:\n            new_pos += chain_length\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a+chain_length:new_pos],\n            chain,\n            new_solution[new_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            9.842825119280967,
            9.236044370677845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_distances[sorted_indices[0, obj_idx]] = np.inf\n        crowding_distances[sorted_indices[-1, obj_idx]] = np.inf\n        range_obj = sorted_obj[-1] - sorted_obj[0]\n        if range_obj == 0:\n            continue\n        for i in range(1, len(archive)-1):\n            idx = sorted_indices[i, obj_idx]\n            crowding_distances[idx] += (sorted_obj[i+1] - sorted_obj[i-1]) / range_obj\n\n    # Select solution with lowest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node chain rearrangement\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    chain_length = min(5, b - a)  # Limit chain length to prevent excessive changes\n    if chain_length > 1:\n        chain = new_solution[a:a+chain_length]\n        new_pos = np.random.randint(0, N - chain_length)\n        if new_pos >= a:\n            new_pos += chain_length\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a+chain_length:new_pos],\n            chain,\n            new_solution[new_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection strategy that prioritizes solutions with better combined objective scores, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity while incorporating a novel \"objective-aware\" perturbation mechanism that dynamically adjusts the search based on the relative improvement potential in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    ranked_indices = np.argsort(combined_scores)\n    selection_prob = np.exp(-np.arange(len(archive)) / 2.0)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(ranked_indices, p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            delta1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[-1]]) - (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_1[segment[-1], segment[1]])\n            delta2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[-1]]) - (distance_matrix_2[segment[0], segment[-1]] + distance_matrix_2[segment[-1], segment[1]])\n            if (delta1 < 0 or delta2 < 0) and np.random.rand() < 0.8:\n                new_solution[a:b+1] = reversed_segment\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                delta1 = distance_matrix_1[new_solution[new_pos-2], new_solution[new_pos]] + distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] - distance_matrix_1[new_solution[new_pos-2], new_solution[new_pos-1]] - distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos+1]]\n                delta2 = distance_matrix_2[new_solution[new_pos-2], new_solution[new_pos]] + distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]] - distance_matrix_2[new_solution[new_pos-2], new_solution[new_pos-1]] - distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos+1]]\n                if (delta1 < 0 or delta2 < 0) and np.random.rand() < 0.7:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.005319274046622,
            7.649506221968922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    ranked_indices = np.argsort(combined_scores)\n    selection_prob = np.exp(-np.arange(len(archive)) / 2.0)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(ranked_indices, p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            delta1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[-1]]) - (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_1[segment[-1], segment[1]])\n            delta2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[-1]]) - (distance_matrix_2[segment[0], segment[-1]] + distance_matrix_2[segment[-1], segment[1]])\n            if (delta1 < 0 or delta2 < 0) and np.random.rand() < 0.8:\n                new_solution[a:b+1] = reversed_segment\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                delta1 = distance_matrix_1[new_solution[new_pos-2], new_solution[new_pos]] + distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] - distance_matrix_1[new_solution[new_pos-2], new_solution[new_pos-1]] - distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos+1]]\n                delta2 = distance_matrix_2[new_solution[new_pos-2], new_solution[new_pos]] + distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]] - distance_matrix_2[new_solution[new_pos-2], new_solution[new_pos-1]] - distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos+1]]\n                if (delta1 < 0 or delta2 < 0) and np.random.rand() < 0.7:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.410972004000388,
            5.612202811021727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining segment swapping and node transposition with probabilistic checks to ensure feasibility while maintaining solution quality across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding[sorted_indices[sorted_order[0]]] = float('inf')\n        crowding[sorted_indices[sorted_order[-1]]] = float('inf')\n        for j in range(1, len(archive)-1):\n            if sorted_objectives[sorted_order[-1], i] != sorted_objectives[sorted_order[0], i]:\n                crowding[sorted_indices[sorted_order[j]]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[sorted_order[-1], i] - sorted_objectives[sorted_order[0], i])\n\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment swap + node transposition\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        c, d = sorted(np.random.choice(N, size=2, replace=False))\n        if a < c <= b and b - a == d - c:\n            new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    if np.random.rand() < 0.5:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            8.98743339818624,
            10.497325351550694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding[sorted_indices[sorted_order[0]]] = float('inf')\n        crowding[sorted_indices[sorted_order[-1]]] = float('inf')\n        for j in range(1, len(archive)-1):\n            if sorted_objectives[sorted_order[-1], i] != sorted_objectives[sorted_order[0], i]:\n                crowding[sorted_indices[sorted_order[j]]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[sorted_order[-1], i] - sorted_objectives[sorted_order[0], i])\n\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: segment swap + node transposition\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        c, d = sorted(np.random.choice(N, size=2, replace=False))\n        if a < c <= b and b - a == d - c:\n            new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    if np.random.rand() < 0.5:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of objective scores, then applies a hybrid local search combining segment rotation, node insertion with edge swapping, and probabilistic node reversal with feasibility checks to generate diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1.0, 1.0])\n    combined_scores = norm_objectives[:, 0] * weights[0] + norm_objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.761957726318723,
            10.245270305132067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1.0, 1.0])\n    combined_scores = norm_objectives[:, 0] * weights[0] + norm_objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score, then applies a novel local search combining adaptive segment permutation with objective-aware node swapping and conditional path rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment permutation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        permuted_segment = np.random.permutation(segment)\n\n        # Evaluate permutation based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        permuted_cost = (distance_matrix_1[new_solution[a-1], permuted_segment[0]] +\n                         distance_matrix_1[permuted_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], permuted_segment[0]] +\n                         distance_matrix_2[permuted_segment[-1], new_solution[(b+1)%N]])\n\n        if permuted_cost < original_cost:\n            new_solution[a:b+1] = permuted_segment\n\n    # Objective-aware node swapping with adaptive probability\n    swap_prob = min(0.8, 0.3 + 0.5 * (archive[0][1][0] + archive[0][1][1]) / (max_obj1 + max_obj2))\n    if np.random.rand() < swap_prob:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path rotation\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        rotated_path = np.roll(path, np.random.randint(1, k))\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                         distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                         distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n",
        "score": [
            6.497413148724741,
            6.299818803985838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment permutation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        permuted_segment = np.random.permutation(segment)\n\n        # Evaluate permutation based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        permuted_cost = (distance_matrix_1[new_solution[a-1], permuted_segment[0]] +\n                         distance_matrix_1[permuted_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], permuted_segment[0]] +\n                         distance_matrix_2[permuted_segment[-1], new_solution[(b+1)%N]])\n\n        if permuted_cost < original_cost:\n            new_solution[a:b+1] = permuted_segment\n\n    # Objective-aware node swapping with adaptive probability\n    swap_prob = min(0.8, 0.3 + 0.5 * (archive[0][1][0] + archive[0][1][1]) / (max_obj1 + max_obj2))\n    if np.random.rand() < swap_prob:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path rotation\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        rotated_path = np.roll(path, np.random.randint(1, k))\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                         distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                         distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on the Pareto front dominance and applies a hybrid local search combining segment rotation, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and explore diverse regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                dominated[i] = True\n                break\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            k = np.random.randint(1, b - a)\n            segment = new_solution[a:b+1]\n            rotated = np.concatenate([segment[k:], segment[:k]])\n            new_solution[a:b+1] = rotated\n\n    # Node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Edge swapping\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and a > 0 and b < N - 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.813926293081663,
            6.849135709092704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                dominated[i] = True\n                break\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            k = np.random.randint(1, b - a)\n            segment = new_solution[a:b+1]\n            rotated = np.concatenate([segment[k:], segment[:k]])\n            new_solution[a:b+1] = rotated\n\n    # Node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Edge swapping\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and a > 0 and b < N - 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score using inverse weights, then applies a hybrid local search with adaptive probabilities for node relocation and segment reversal, ensuring feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    min_obj = objectives.min(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    weights = np.random.uniform(0.2, 0.8)\n    scores = (1 - weights) * normalized_obj[:, 0] + weights * normalized_obj[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = (1 - weights) * cost1 + weights * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.826607793228881,
            6.605187393800346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    min_obj = objectives.min(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    weights = np.random.uniform(0.2, 0.8)\n    scores = (1 - weights) * normalized_obj[:, 0] + weights * normalized_obj[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = (1 - weights) * cost1 + weights * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with equal weights (0.5 for each objective), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.968902650809417,
            6.061484192774147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection with adaptive weights, then applies a hybrid local search combining node swapping, segment rotation, and probabilistic edge flipping with feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment rotation\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.183774465168374,
            6.371281571547307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search\n    if np.random.rand() < 0.5:\n        # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment rotation\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j and abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining 3-opt, node insertion with edge optimization, and adaptive segment swapping to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        i, j, k = sorted(np.random.choice(N, size=3, replace=False))\n        if j - i > 1 and k - j > 1:\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(N-1):\n            candidate = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            cost1 = distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = distance_matrix_2[candidate[-1], candidate[0]]\n            for i in range(N-1):\n                cost1 += distance_matrix_1[candidate[i], candidate[i+1]]\n                cost2 += distance_matrix_2[candidate[i], candidate[i+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment_length = min(5, b - a)\n        if segment_length > 1:\n            new_solution[a:a+segment_length] = new_solution[a:a+segment_length][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.116959310637558,
            9.076543064420571
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        i, j, k = sorted(np.random.choice(N, size=3, replace=False))\n        if j - i > 1 and k - j > 1:\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(N-1):\n            candidate = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            cost1 = distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = distance_matrix_2[candidate[-1], candidate[0]]\n            for i in range(N-1):\n                cost1 += distance_matrix_1[candidate[i], candidate[i+1]]\n                cost2 += distance_matrix_2[candidate[i], candidate[i+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment_length = min(5, b - a)\n        if segment_length > 1:\n            new_solution[a:a+segment_length] = new_solution[a:a+segment_length][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining Pareto dominance and objective diversity, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dominance and diversity scores\n    dominance_scores = []\n    diversity_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n        diversity_scores.append(obj[0] * obj[1])\n\n    # Combine scores and select promising solution\n    combined_scores = [d + div for d, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            5.394969316527699,
            6.566129315427194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dominance and diversity scores\n    dominance_scores = []\n    diversity_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n        diversity_scores.append(obj[0] * obj[1])\n\n    # Combine scores and select promising solution\n    combined_scores = [d + div for d, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The new algorithm selects a solution from the archive using a diversity-aware selection mechanism that balances both objectives, then applies a novel local search combining adaptive segment rotation, distance-aware node insertion, and objective-weighted edge swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        diversity_scores = crowding_dist * (objectives[:, 0] + objectives[:, 1])\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Distance-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        candidates = np.random.choice(N-1, size=3, replace=False)\n        best_pos = None\n        min_cost = float('inf')\n\n        for pos in candidates:\n            cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Objective-weighted edge swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference with weights\n            weight1 = 0.4\n            weight2 = 0.6\n            cost_diff = (weight1 * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                   distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                   distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                                   distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                                   distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]) +\n                        weight2 * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                                   distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                                   distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                                   distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                                   distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                                   distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]))\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.157232600043052,
            6.827928690984672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        diversity_scores = crowding_dist * (objectives[:, 0] + objectives[:, 1])\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Distance-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        candidates = np.random.choice(N-1, size=3, replace=False)\n        best_pos = None\n        min_cost = float('inf')\n\n        for pos in candidates:\n            cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Objective-weighted edge swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference with weights\n            weight1 = 0.4\n            weight2 = 0.6\n            cost_diff = (weight1 * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                   distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                   distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                                   distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                                   distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]) +\n                        weight2 * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                                   distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                                   distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                                   distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                                   distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                                   distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]))\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective balance (adjusting weights based on solution diversity) and applies a hybrid local search combining segment permutation, node exchange, and probabilistic edge flipping to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        diversity = np.std(objectives, axis=0)\n        weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else [0.5, 0.5]\n    else:\n        weights = [0.5, 0.5]\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.concatenate([segment[b-a:], segment[:b-a]])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N//2)) % N\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.119622924533024,
            5.8499909492854165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        diversity = np.std(objectives, axis=0)\n        weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else [0.5, 0.5]\n    else:\n        weights = [0.5, 0.5]\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.concatenate([segment[b-a:], segment[:b-a]])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(1, N//2)) % N\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted objective score (adaptively adjusting weights between 60% and 40% for the first and second objectives) and applies a hybrid local search combining segment reversal, node relocation, and edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weight1 = 0.6 if np.random.rand() < 0.5 else 0.4\n    weight2 = 1 - weight1\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.007821697376846,
            5.935552997498181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weight1 = 0.6 if np.random.rand() < 0.5 else 0.4\n    weight2 = 1 - weight1\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized Pareto dominance score, then applies a hybrid local search combining node insertion and segment rotation with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:  # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n",
        "score": [
            6.49172186168218,
            5.819684043090602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Node insertion\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:  # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining Pareto dominance and objective diversity, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dominance and diversity scores\n    dominance_scores = []\n    diversity_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n        diversity_scores.append(obj[0] * obj[1])\n\n    # Combine scores and select promising solution\n    combined_scores = [d + div for d, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining objective diversity and solution quality, then applies a novel local search combining adaptive segment inversion with objective-aware node relocation and conditional path swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Hybrid selection criterion combining diversity and quality\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    quality_scores = np.sum(objectives, axis=1)\n    combined_scores = diversity_scores[0] * objectives[:, 0] + diversity_scores[1] * objectives[:, 1] - quality_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        inverted_cost = (distance_matrix_1[new_solution[a-1], inverted_segment[0]] +\n                        distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], inverted_segment[0]] +\n                        distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%N]])\n\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware node relocation\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path swapping\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path1 = new_solution[:k]\n        path2 = new_solution[k:2*k]\n\n        # Evaluate swap\n        original_cost = (distance_matrix_1[new_solution[-1], path1[0]] +\n                         distance_matrix_1[path1[-1], path2[0]] +\n                         distance_matrix_1[path2[-1], new_solution[2*k]] +\n                         distance_matrix_2[new_solution[-1], path1[0]] +\n                         distance_matrix_2[path1[-1], path2[0]] +\n                         distance_matrix_2[path2[-1], new_solution[2*k]])\n        swapped_cost = (distance_matrix_1[new_solution[-1], path2[0]] +\n                        distance_matrix_1[path2[-1], path1[0]] +\n                        distance_matrix_1[path1[-1], new_solution[2*k]] +\n                        distance_matrix_2[new_solution[-1], path2[0]] +\n                        distance_matrix_2[path2[-1], path1[0]] +\n                        distance_matrix_2[path1[-1], new_solution[2*k]])\n\n        if swapped_cost < original_cost:\n            new_solution[:k], new_solution[k:2*k] = new_solution[k:2*k], new_solution[:k]\n\n    return new_solution\n\n",
        "score": [
            9.174920521117294,
            10.130875843528695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Hybrid selection criterion combining diversity and quality\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    quality_scores = np.sum(objectives, axis=1)\n    combined_scores = diversity_scores[0] * objectives[:, 0] + diversity_scores[1] * objectives[:, 1] - quality_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        inverted_cost = (distance_matrix_1[new_solution[a-1], inverted_segment[0]] +\n                        distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], inverted_segment[0]] +\n                        distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%N]])\n\n        if inverted_cost < original_cost:\n            new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware node relocation\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path swapping\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path1 = new_solution[:k]\n        path2 = new_solution[k:2*k]\n\n        # Evaluate swap\n        original_cost = (distance_matrix_1[new_solution[-1], path1[0]] +\n                         distance_matrix_1[path1[-1], path2[0]] +\n                         distance_matrix_1[path2[-1], new_solution[2*k]] +\n                         distance_matrix_2[new_solution[-1], path1[0]] +\n                         distance_matrix_2[path1[-1], path2[0]] +\n                         distance_matrix_2[path2[-1], new_solution[2*k]])\n        swapped_cost = (distance_matrix_1[new_solution[-1], path2[0]] +\n                        distance_matrix_1[path2[-1], path1[0]] +\n                        distance_matrix_1[path1[-1], new_solution[2*k]] +\n                        distance_matrix_2[new_solution[-1], path2[0]] +\n                        distance_matrix_2[path2[-1], path1[0]] +\n                        distance_matrix_2[path1[-1], new_solution[2*k]])\n\n        if swapped_cost < original_cost:\n            new_solution[:k], new_solution[k:2*k] = new_solution[k:2*k], new_solution[:k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining segment reversal, node insertion, and edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != pos:\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 2:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.674918119173224,
            8.538208036034845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != pos:\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 2:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment inversion, node insertion, and edge reversal with adaptive probabilities, ensuring feasibility and exploring the solution space through a combination of diverse moves and objective-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive) - 1):\n        crowding_distances[sorted_indices[i]] = (\n            (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) +\n            (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n        )\n    crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[:max(1, len(archive) // 3)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.206148180373404,
            6.519337826305517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive) - 1):\n        crowding_distances[sorted_indices[i]] = (\n            (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) +\n            (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n        )\n    crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[:max(1, len(archive) // 3)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The new algorithm selects a solution from the archive using a crowding distance-based selection, then applies a hybrid local search combining node insertion, edge exchange, and probabilistic segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    if np.random.rand() < 0.4:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.953038815455333,
            7.684040808003198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    if np.random.rand() < 0.4:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment reversal with probabilistic edge insertion, adaptive node relocation with edge swapping, and a novel segment rotation with diversity-aware probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic edge insertion\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive node relocation with edge swapping\n    if np.random.rand() < 0.5 + 0.3 * (crowding_distances[np.argmax(crowding_distances)] / (np.max(crowding_distances) + 1e-8)):\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment rotation with diversity-aware probability\n    if np.random.rand() < 0.3 + 0.4 * (np.std(objectives) / (np.mean(objectives) + 1e-8)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    return new_solution\n\n",
        "score": [
            9.96297314252187,
            9.630337388328162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic edge insertion\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive node relocation with edge swapping\n    if np.random.rand() < 0.5 + 0.3 * (crowding_distances[np.argmax(crowding_distances)] / (np.max(crowding_distances) + 1e-8)):\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment rotation with diversity-aware probability\n    if np.random.rand() < 0.3 + 0.4 * (np.std(objectives) / (np.mean(objectives) + 1e-8)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired score with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with dynamic probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        ranks[i] = dominated\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.866315918410209,
            6.802892659141828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        ranks[i] = dominated\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection, then applies a hybrid local search combining segment reversal with probabilistic node insertion, adaptive segment rotation, and a novel segment merging operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_scores = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_scores[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    base_solution = archive[np.argmax(crowding_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic node insertion\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3 and b - a > 2:\n                node = np.random.choice(new_solution[a:b+1])\n                pos = np.random.randint(a, b)\n                new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.3 + 0.4 * (crowding_scores[np.argmax(crowding_scores)] / np.max(crowding_scores)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Novel segment merging\n    if np.random.rand() < 0.2 and N > 4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            9.950524391842873,
            9.494724423694656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_scores = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_scores[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    base_solution = archive[np.argmax(crowding_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic node insertion\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3 and b - a > 2:\n                node = np.random.choice(new_solution[a:b+1])\n                pos = np.random.randint(a, b)\n                new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.3 + 0.4 * (crowding_scores[np.argmax(crowding_scores)] / np.max(crowding_scores)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Novel segment merging\n    if np.random.rand() < 0.2 and N > 4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-inspired selection, then applies a hybrid local search combining segment rotation, node insertion, and path reversal with dynamic probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    archive_sorted = [archive[i] for i in sorted_indices]\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        crowding_distances[1:-1] += (objectives_sorted[2:, i] - objectives_sorted[:-2, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i] + 1e-8)\n\n    base_solution = archive_sorted[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.578579339232606,
            7.81778566060671
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    archive_sorted = [archive[i] for i in sorted_indices]\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        crowding_distances[1:-1] += (objectives_sorted[2:, i] - objectives_sorted[:-2, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i] + 1e-8)\n\n    base_solution = archive_sorted[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with adjusted weights (0.5 for first objective and 0.5 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.032559530435452,
            5.837097064528885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto dominance-based selection, then applies a hybrid local search combining segment reversal with a probabilistic edge swap and a novel node insertion strategy that prioritizes improving the worst-performing objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            7.069431215793441,
            6.630196246197527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid objective score that combines both objectives with dynamic weights, then applies a novel local search combining probabilistic segment merging, adaptive node insertion, and conditional path reordering with feasibility checks to explore the solution space while maintaining tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    range1 = np.ptp(obj1)\n    range2 = np.ptp(obj2)\n    weight1 = 1.0 / (1.0 + range1) if range1 > 0 else 0.5\n    weight2 = 1.0 / (1.0 + range2) if range2 > 0 else 0.5\n\n    # Select solution based on hybrid score\n    scores = weight1 * obj1 + weight2 * obj2\n    base_solution = archive[np.argmin(scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Probabilistic segment merging\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        merged_segment = np.concatenate([segment2, segment1])\n\n        # Check feasibility and apply if beneficial\n        original_cost = (distance_matrix_1[new_solution[a-1], segment1[0]] +\n                         distance_matrix_1[segment1[-1], segment2[0]] +\n                         distance_matrix_1[segment2[-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[a-1], segment1[0]] +\n                         distance_matrix_2[segment1[-1], segment2[0]] +\n                         distance_matrix_2[segment2[-1], new_solution[c]])\n\n        merged_cost = (distance_matrix_1[new_solution[a-1], segment2[0]] +\n                      distance_matrix_1[segment2[-1], segment1[0]] +\n                      distance_matrix_1[segment1[-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[a-1], segment2[0]] +\n                      distance_matrix_2[segment2[-1], segment1[0]] +\n                      distance_matrix_2[segment1[-1], new_solution[c]])\n\n        if merged_cost < original_cost:\n            new_solution[a:c] = merged_segment\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Conditional path reordering\n    if np.random.rand() < 0.4:\n        k = np.random.randint(3, N//2)\n        path = new_solution[:k]\n        reordered_path = np.concatenate([path[1:], [path[0]]])\n\n        # Evaluate reordering\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n\n        reordered_cost = (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_1[reordered_path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_2[reordered_path[-1], new_solution[k]])\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n",
        "score": [
            5.88837099901298,
            5.929770824763276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    range1 = np.ptp(obj1)\n    range2 = np.ptp(obj2)\n    weight1 = 1.0 / (1.0 + range1) if range1 > 0 else 0.5\n    weight2 = 1.0 / (1.0 + range2) if range2 > 0 else 0.5\n\n    # Select solution based on hybrid score\n    scores = weight1 * obj1 + weight2 * obj2\n    base_solution = archive[np.argmin(scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Probabilistic segment merging\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        merged_segment = np.concatenate([segment2, segment1])\n\n        # Check feasibility and apply if beneficial\n        original_cost = (distance_matrix_1[new_solution[a-1], segment1[0]] +\n                         distance_matrix_1[segment1[-1], segment2[0]] +\n                         distance_matrix_1[segment2[-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[a-1], segment1[0]] +\n                         distance_matrix_2[segment1[-1], segment2[0]] +\n                         distance_matrix_2[segment2[-1], new_solution[c]])\n\n        merged_cost = (distance_matrix_1[new_solution[a-1], segment2[0]] +\n                      distance_matrix_1[segment2[-1], segment1[0]] +\n                      distance_matrix_1[segment1[-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[a-1], segment2[0]] +\n                      distance_matrix_2[segment2[-1], segment1[0]] +\n                      distance_matrix_2[segment1[-1], new_solution[c]])\n\n        if merged_cost < original_cost:\n            new_solution[a:c] = merged_segment\n\n    # Adaptive node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Conditional path reordering\n    if np.random.rand() < 0.4:\n        k = np.random.randint(3, N//2)\n        path = new_solution[:k]\n        reordered_path = np.concatenate([path[1:], [path[0]]])\n\n        # Evaluate reordering\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n\n        reordered_cost = (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_1[reordered_path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_2[reordered_path[-1], new_solution[k]])\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity metric that combines Pareto dominance and hypervolume contribution, then applies a hybrid local search combining adaptive segment swapping with probabilistic node insertion and edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        base_index = np.random.choice(pareto_front)\n    else:\n        base_index = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[base_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(N - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            else:\n                new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a))\n\n    return new_solution\n\n",
        "score": [
            6.9057396709236105,
            6.737610228227019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        base_index = np.random.choice(pareto_front)\n    else:\n        base_index = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[base_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(N - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            else:\n                new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives using a weighted sum, then applies a hybrid local search combining adaptive segment rotation with objective-aware node insertion and conditional path reshuffling to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if np.random.rand() < 0.5 else [0.4, 0.6]\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Conditional path reshuffling\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shuffled_path = np.random.permutation(path)\n\n        # Evaluate shuffling\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        shuffled_cost = (distance_matrix_1[new_solution[-1], shuffled_path[0]] +\n                         distance_matrix_1[shuffled_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], shuffled_path[0]] +\n                         distance_matrix_2[shuffled_path[-1], new_solution[k]])\n\n        if shuffled_cost < original_cost:\n            new_solution[:k] = shuffled_path\n\n    return new_solution\n\n",
        "score": [
            5.8220574664903415,
            6.290786405476036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if np.random.rand() < 0.5 else [0.4, 0.6]\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Conditional path reshuffling\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        shuffled_path = np.random.permutation(path)\n\n        # Evaluate shuffling\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        shuffled_cost = (distance_matrix_1[new_solution[-1], shuffled_path[0]] +\n                         distance_matrix_1[shuffled_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], shuffled_path[0]] +\n                         distance_matrix_2[shuffled_path[-1], new_solution[k]])\n\n        if shuffled_cost < original_cost:\n            new_solution[:k] = shuffled_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired scoring, then applies a hybrid local search combining a novel segment rotation operator with probabilistic edge swaps and node insertions to generate a neighbor solution with improved diversity and quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        pareto_scores[i] = dominated\n\n    base_solution = archive[np.argmin(pareto_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1 and np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.98206591096546,
            7.5632539255050215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        pareto_scores[i] = dominated\n\n    base_solution = archive[np.argmin(pareto_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1 and np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.678733823516097,
            6.312686110122009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-based selection criterion, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity, while incorporating distance-based neighborhood exploration to guide the search toward more promising regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        neighbors = [i for i in range(N) if i != old_pos and (distance_matrix_1[node, new_solution[i]] < np.percentile(distance_matrix_1[node], 25) or distance_matrix_2[node, new_solution[i]] < np.percentile(distance_matrix_2[node], 25))]\n        if neighbors:\n            new_pos = np.random.choice(neighbors)\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.5 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.167073398220527,
            8.828156666395639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        neighbors = [i for i in range(N) if i != old_pos and (distance_matrix_1[node, new_solution[i]] < np.percentile(distance_matrix_1[node], 25) or distance_matrix_2[node, new_solution[i]] < np.percentile(distance_matrix_2[node], 25))]\n        if neighbors:\n            new_pos = np.random.choice(neighbors)\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.5 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining edge insertion and segment shifting with adaptive probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objs = objectives[sorted_idx]\n\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objs[:, i])\n        sorted_objs_sorted = sorted_objs[sorted_order]\n        crowding[sorted_order[1:-1]] += (sorted_objs_sorted[2:, i] - sorted_objs_sorted[:-2, i]) / (sorted_objs_sorted[-1, i] - sorted_objs_sorted[0, i] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Edge insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[a]\n\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, a)\n        candidate = np.insert(candidate, b, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        if (cost1 + cost2) < (sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(N)) +\n                              sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(N))):\n            new_solution = candidate\n    else:  # Segment shifting\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        if (cost1 + cost2) < (sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(N)) +\n                              sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(N))):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            10.212795554458685,
            10.58719596180833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objs = objectives[sorted_idx]\n\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objs[:, i])\n        sorted_objs_sorted = sorted_objs[sorted_order]\n        crowding[sorted_order[1:-1]] += (sorted_objs_sorted[2:, i] - sorted_objs_sorted[:-2, i]) / (sorted_objs_sorted[-1, i] - sorted_objs_sorted[0, i] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Edge insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[a]\n\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, a)\n        candidate = np.insert(candidate, b, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        if (cost1 + cost2) < (sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(N)) +\n                              sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(N))):\n            new_solution = candidate\n    else:  # Segment shifting\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n\n        if (cost1 + cost2) < (sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(N)) +\n                              sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(N))):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(sorted_objectives))\n\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1][0] - sorted_objectives[i-1][0]) + (sorted_objectives[i+1][1] - sorted_objectives[i-1][1])\n\n    selected_index = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j < N-1:\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            4.491230507309145,
            10.119803927626558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(sorted_objectives))\n\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1][0] - sorted_objectives[i-1][0]) + (sorted_objectives[i+1][1] - sorted_objectives[i-1][1])\n\n    selected_index = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j < N-1:\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective twice as much as the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.89306204513346,
            7.436696520476107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment reversal, node insertion, and adaptive edge swapping with probabilistic checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1)\n\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.336897764423762,
            8.875364905040907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1)\n\n    if np.random.rand() < 0.3 and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment crossover, node insertion with probabilistic edge reversal, and a novel segment shuffle with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_idx, i]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment crossover with adaptive probability\n    if np.random.rand() < 0.4 + 0.3 * (crowding_distances[np.argmax(crowding_distances)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            other_solution = archive[np.random.choice(len(archive))][0]\n            other_segment = other_solution[np.isin(other_solution, segment)]\n            if len(other_segment) > 0:\n                new_solution[a:b+1] = other_segment[:min(len(segment), len(other_segment))]\n\n    # Node insertion with probabilistic edge reversal\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n        if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-2:\n            new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment shuffle with adaptive probability\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[np.argmax(crowding_distances)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            6.581724299522891,
            6.374618265029282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_idx, i]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-8)\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment crossover with adaptive probability\n    if np.random.rand() < 0.4 + 0.3 * (crowding_distances[np.argmax(crowding_distances)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            other_solution = archive[np.random.choice(len(archive))][0]\n            other_segment = other_solution[np.isin(other_solution, segment)]\n            if len(other_segment) > 0:\n                new_solution[a:b+1] = other_segment[:min(len(segment), len(other_segment))]\n\n    # Node insertion with probabilistic edge reversal\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n        if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-2:\n            new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment shuffle with adaptive probability\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[np.argmax(crowding_distances)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1]\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        left = objectives[sorted_indices[i-1]]\n        right = objectives[sorted_indices[i+1]]\n        crowding_distances[sorted_indices[i]] = np.sum(np.abs(objectives[sorted_indices[i]] - left) + np.abs(objectives[sorted_indices[i]] - right))\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.6994894180611375,
            6.741186863840574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        left = objectives[sorted_indices[i-1]]\n        right = objectives[sorted_indices[i+1]]\n        crowding_distances[sorted_indices[i]] = np.sum(np.abs(objectives[sorted_indices[i]] - left) + np.abs(objectives[sorted_indices[i]] - right))\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The new algorithm selects a solution from the archive based on an adaptive crowding distance metric, then applies a hybrid local search combining dynamic segment shuffling, probabilistic node insertion, and a novel edge contraction operator with adaptive temperature-based acceptance to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    N = len(archive[0][0])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sorted_idx = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_idx == i)[0][0]\n        if rank == 0 or rank == len(archive)-1:\n            crowding_dist[i] = np.inf\n        else:\n            crowding_dist[i] = (objectives[sorted_idx[rank+1], 0] - objectives[sorted_idx[rank-1], 0]) / (objectives[:, 0].max() - objectives[:, 0].min() + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic segment shuffling\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        segments = np.array_split(new_solution, k)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Edge contraction with adaptive temperature\n    temp = 1.0 - np.mean(crowding_dist) / (np.max(crowding_dist) + 1e-8)\n    if np.random.rand() < 0.2 * temp:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b] = np.concatenate([new_solution[a:a+1], new_solution[b-1:b]])\n\n    return new_solution\n\n",
        "score": [
            8.59605976714176,
            9.292692304080534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    N = len(archive[0][0])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sorted_idx = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_idx == i)[0][0]\n        if rank == 0 or rank == len(archive)-1:\n            crowding_dist[i] = np.inf\n        else:\n            crowding_dist[i] = (objectives[sorted_idx[rank+1], 0] - objectives[sorted_idx[rank-1], 0]) / (objectives[:, 0].max() - objectives[:, 0].min() + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic segment shuffling\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        segments = np.array_split(new_solution, k)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Edge contraction with adaptive temperature\n    temp = 1.0 - np.mean(crowding_dist) / (np.max(crowding_dist) + 1e-8)\n    if np.random.rand() < 0.2 * temp:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b] = np.concatenate([new_solution[a:a+1], new_solution[b-1:b]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining segment rotation and node swapping with adaptive probabilities, ensuring feasibility while preserving diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        dominates = 0\n        dominated_by = 0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj[0] <= other_obj[0] and obj[1] < other_obj[1]) or (obj[0] < other_obj[0] and obj[1] <= other_obj[1]):\n                dominates += 1\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                dominated_by += 1\n        pareto_scores.append(dominates - dominated_by)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with segment rotation and node swapping\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n    else:\n        # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.937204675862117,
            6.997294758209792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        dominates = 0\n        dominated_by = 0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj[0] <= other_obj[0] and obj[1] < other_obj[1]) or (obj[0] < other_obj[0] and obj[1] <= other_obj[1]):\n                dominates += 1\n            if (obj[0] >= other_obj[0] and obj[1] > other_obj[1]) or (obj[0] > other_obj[0] and obj[1] >= other_obj[1]):\n                dominated_by += 1\n        pareto_scores.append(dominates - dominated_by)\n    selected_idx = np.argmax(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with segment rotation and node swapping\n    if np.random.rand() < 0.5:\n        # Segment rotation\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n    else:\n        # Node swapping\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment insertion and node swap with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for _, obj in archive])\n    selection_scores = 0.7 * objectives[:, 0] + 0.3 * objectives[:, 1] - 0.2 * diversity_scores\n    selected_idx = np.argmin(selection_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:  # Node swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.241546353556435,
            7.937214875348636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for _, obj in archive])\n    selection_scores = 0.7 * objectives[:, 0] + 0.3 * objectives[:, 1] - 0.2 * diversity_scores\n    selected_idx = np.argmin(selection_scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.5:  # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:  # Node swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection, then applies a hybrid local search combining segment reversal, node insertion, and edge swaps with adaptive probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        j = (i + 1) % N\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.rand() < 0.3:\n                k = (i + 2) % N\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            6.994259626998291,
            6.405050074193059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        j = (i + 1) % N\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.rand() < 0.3:\n                k = (i + 2) % N\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.34817956505157,
            5.754165201401132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score that dynamically adjusts weights based on the relative magnitudes of the objectives, then applies a novel hybrid local search combining adaptive segment rotation, objective-aware node insertion, and conditional path reversal with probabilistic checks to ensure feasibility while promoting diversity in exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Dynamic weight adjustment based on objective magnitudes\n    obj1_vals = [x[1][0] for x in archive]\n    obj2_vals = [x[1][1] for x in archive]\n    mean_obj1, mean_obj2 = np.mean(obj1_vals), np.mean(obj2_vals)\n    weight1 = mean_obj2 / (mean_obj1 + mean_obj2)\n    weight2 = mean_obj1 / (mean_obj1 + mean_obj2)\n\n    # Select solution based on dynamic weighted score\n    scores = [weight1 * x[1][0] + weight2 * x[1][1] for x in archive]\n    base_solution = archive[np.argmin(scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            # Evaluate insertion\n            if new_pos > 0 and new_pos < N-1:\n                cost_diff = (distance_matrix_1[new_solution[new_pos-1], node] +\n                            distance_matrix_1[node, new_solution[new_pos+1]] -\n                            distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] -\n                            distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] +\n                            distance_matrix_2[new_solution[new_pos-1], node] +\n                            distance_matrix_2[node, new_solution[new_pos+1]] -\n                            distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] -\n                            distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]])\n\n                if cost_diff > 0 and np.random.rand() < 0.3:\n                    new_solution = np.concatenate([new_solution[:old_pos], [node], new_solution[old_pos:]])\n\n    # Conditional path reversal with diversity check\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal with diversity factor\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                        distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                        distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        diversity_factor = len(np.unique(new_solution[:k])) / k\n        if (reversed_cost < original_cost) or (diversity_factor < 0.7 and np.random.rand() < 0.2):\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            5.691656227399241,
            6.462990480534822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Dynamic weight adjustment based on objective magnitudes\n    obj1_vals = [x[1][0] for x in archive]\n    obj2_vals = [x[1][1] for x in archive]\n    mean_obj1, mean_obj2 = np.mean(obj1_vals), np.mean(obj2_vals)\n    weight1 = mean_obj2 / (mean_obj1 + mean_obj2)\n    weight2 = mean_obj1 / (mean_obj1 + mean_obj2)\n\n    # Select solution based on dynamic weighted score\n    scores = [weight1 * x[1][0] + weight2 * x[1][1] for x in archive]\n    base_solution = archive[np.argmin(scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            # Evaluate insertion\n            if new_pos > 0 and new_pos < N-1:\n                cost_diff = (distance_matrix_1[new_solution[new_pos-1], node] +\n                            distance_matrix_1[node, new_solution[new_pos+1]] -\n                            distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] -\n                            distance_matrix_1[new_solution[new_pos], new_solution[new_pos+1]] +\n                            distance_matrix_2[new_solution[new_pos-1], node] +\n                            distance_matrix_2[node, new_solution[new_pos+1]] -\n                            distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] -\n                            distance_matrix_2[new_solution[new_pos], new_solution[new_pos+1]])\n\n                if cost_diff > 0 and np.random.rand() < 0.3:\n                    new_solution = np.concatenate([new_solution[:old_pos], [node], new_solution[old_pos:]])\n\n    # Conditional path reversal with diversity check\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal with diversity factor\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                        distance_matrix_1[path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], path[0]] +\n                        distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                        distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                        distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        diversity_factor = len(np.unique(new_solution[:k])) / k\n        if (reversed_cost < original_cost) or (diversity_factor < 0.7 and np.random.rand() < 0.2):\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions, then applies a hybrid local search combining segment rotation, node insertion with edge swapping, and probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.choice([i for i in range(N) if i != old_pos])\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n        if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n            if np.random.rand() < 0.5:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n            else:\n                new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.172099148128769,
            8.048780064355228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.choice([i for i in range(N) if i != old_pos])\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n        if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n            if np.random.rand() < 0.5:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n            else:\n                new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 and N > 3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-dominated sorting approach to prioritize Pareto-front solutions, then applies a hybrid local search combining segment reversal, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability, while leveraging the distance matrices to guide the search toward improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        base_solution = archive[np.random.choice(pareto_front)][0].copy()\n    else:\n        base_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            segment_cost1 = np.sum(distance_matrix_1[segment[:-1], segment[1:]])\n            segment_cost2 = np.sum(distance_matrix_2[segment[:-1], segment[1:]])\n            reversed_segment = segment[::-1]\n            reversed_cost1 = np.sum(distance_matrix_1[reversed_segment[:-1], reversed_segment[1:]])\n            reversed_cost2 = np.sum(distance_matrix_2[reversed_segment[:-1], reversed_segment[1:]])\n            if (reversed_cost1 < segment_cost1 and reversed_cost2 < segment_cost2) or (np.random.rand() < 0.2):\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            6.866259054757897,
            6.74463551087815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        base_solution = archive[np.random.choice(pareto_front)][0].copy()\n    else:\n        base_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            segment_cost1 = np.sum(distance_matrix_1[segment[:-1], segment[1:]])\n            segment_cost2 = np.sum(distance_matrix_2[segment[:-1], segment[1:]])\n            reversed_segment = segment[::-1]\n            reversed_cost1 = np.sum(distance_matrix_1[reversed_segment[:-1], reversed_segment[1:]])\n            reversed_cost2 = np.sum(distance_matrix_2[reversed_segment[:-1], reversed_segment[1:]])\n            if (reversed_cost1 < segment_cost1 and reversed_cost2 < segment_cost2) or (np.random.rand() < 0.2):\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment relocation, node inversion, and edge swapping with adaptive probabilistic checks to ensure feasibility and explore the solution space more effectively while maintaining diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    N = len(objectives)\n\n    if N > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(N)\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, N-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0] + 1e-8)\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        for i in range(1, N-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives.max(axis=0)[1] - objectives.min(axis=0)[1] + 1e-8)\n\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N_nodes = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N_nodes, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b].copy()\n            np.random.shuffle(segment)\n            new_solution[a:b] = segment\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N_nodes, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N_nodes, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if np.random.rand() < 0.3:\n                new_solution[a], new_solution[b-1] = new_solution[b-1], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.009480212107482,
            6.978563711965174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    N = len(objectives)\n\n    if N > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(N)\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, N-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0] + 1e-8)\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        for i in range(1, N-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives.max(axis=0)[1] - objectives.min(axis=0)[1] + 1e-8)\n\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N_nodes = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N_nodes, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b].copy()\n            np.random.shuffle(segment)\n            new_solution[a:b] = segment\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N_nodes, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N_nodes, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if np.random.rand() < 0.3:\n                new_solution[a], new_solution[b-1] = new_solution[b-1], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining segment rotation, node swapping, and adaptive edge flipping with probabilistic checks to ensure feasibility and exploration of diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            flipped = segment[::-1]\n            for i in range(len(segment)):\n                if np.random.rand() < 0.5:\n                    flipped[i] = segment[i]\n            new_solution[a:b+1] = flipped\n\n    return new_solution\n\n",
        "score": [
            8.112137389491652,
            7.032122418178723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            flipped = segment[::-1]\n            for i in range(len(segment)):\n                if np.random.rand() < 0.5:\n                    flipped[i] = segment[i]\n            new_solution[a:b+1] = flipped\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment rotation, node insertion, and probabilistic edge swaps with feasibility checks to generate diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += objectives_sorted[i+1, 1] - objectives_sorted[i-1, 1]\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N-1)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.7:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.250451254858155,
            8.0339105659591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    objectives_sorted = objectives[sorted_indices]\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += objectives_sorted[i+1, 1] - objectives_sorted[i-1, 1]\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N-1)\n        new_solution = np.concatenate([new_solution[k:], new_solution[:k]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and np.random.rand() < 0.7:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score incorporating both objective values and their relative improvement potential, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability, while also incorporating a diversity-aware segment inversion based on the distance matrices to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    min_obj = np.min(objectives, axis=0)\n    improvement_potential = (objectives - min_obj) / (np.max(objectives, axis=0) - min_obj + 1e-10)\n    combined_scores = np.mean(improvement_potential, axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)]):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)]):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            dist1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            dist2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            if dist1 > dist2:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.054307532323362,
            6.248834505904753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    min_obj = np.min(objectives, axis=0)\n    improvement_potential = (objectives - min_obj) / (np.max(objectives, axis=0) - min_obj + 1e-10)\n    combined_scores = np.mean(improvement_potential, axis=1)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)]):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)]):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            dist1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            dist2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            if dist1 > dist2:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that prioritizes the less explored objective, then applies a hybrid local search combining adaptive segment reversal with objective-biased node insertion and dynamic path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_mean = np.mean([x[1][0] for x in archive]) if archive else 1.0\n    obj2_mean = np.mean([x[1][1] for x in archive]) if archive else 1.0\n    exploration_weight = 0.7 if obj1_mean < obj2_mean else 0.3\n    archive.sort(key=lambda x: (x[1][0]/obj1_mean * exploration_weight + x[1][1]/obj2_mean * (1-exploration_weight)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective bias\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate with objective bias\n        obj1_diff = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] -\n                     distance_matrix_1[new_solution[a-1], segment[0]] -\n                     distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) * exploration_weight\n        obj2_diff = (distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]] -\n                     distance_matrix_2[new_solution[a-1], segment[0]] -\n                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]) * (1-exploration_weight)\n\n        if obj1_diff + obj2_diff < 0:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-biased node insertion\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            # Remove node and insert at position i\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, i, node)\n\n            # Evaluate insertion\n            obj1_diff = (distance_matrix_1[new_solution[i-1], node] +\n                         distance_matrix_1[node, new_solution[(i+1)%(N-1)]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%(N-1)]]) * exploration_weight\n            obj2_diff = (distance_matrix_2[new_solution[i-1], node] +\n                         distance_matrix_2[node, new_solution[(i+1)%(N-1)]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%(N-1)]]) * (1-exploration_weight)\n\n            if obj1_diff + obj2_diff >= 0:\n                # Revert if not beneficial\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n                new_solution = np.insert(new_solution, j, new_solution[i])\n                new_solution = np.delete(new_solution, i+1)\n\n    # Dynamic path inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//3)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate with dynamic threshold\n        obj1_diff = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                     distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[-1], path[0]] -\n                     distance_matrix_1[path[-1], new_solution[k]]) * exploration_weight\n        obj2_diff = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                     distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                     distance_matrix_2[new_solution[-1], path[0]] -\n                     distance_matrix_2[path[-1], new_solution[k]]) * (1-exploration_weight)\n\n        if obj1_diff + obj2_diff < -0.1 * (obj1_mean + obj2_mean):\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            4.822067020005523,
            8.064221529294091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_mean = np.mean([x[1][0] for x in archive]) if archive else 1.0\n    obj2_mean = np.mean([x[1][1] for x in archive]) if archive else 1.0\n    exploration_weight = 0.7 if obj1_mean < obj2_mean else 0.3\n    archive.sort(key=lambda x: (x[1][0]/obj1_mean * exploration_weight + x[1][1]/obj2_mean * (1-exploration_weight)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective bias\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate with objective bias\n        obj1_diff = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] -\n                     distance_matrix_1[new_solution[a-1], segment[0]] -\n                     distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) * exploration_weight\n        obj2_diff = (distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]] -\n                     distance_matrix_2[new_solution[a-1], segment[0]] -\n                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]) * (1-exploration_weight)\n\n        if obj1_diff + obj2_diff < 0:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-biased node insertion\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            # Remove node and insert at position i\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, i, node)\n\n            # Evaluate insertion\n            obj1_diff = (distance_matrix_1[new_solution[i-1], node] +\n                         distance_matrix_1[node, new_solution[(i+1)%(N-1)]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%(N-1)]]) * exploration_weight\n            obj2_diff = (distance_matrix_2[new_solution[i-1], node] +\n                         distance_matrix_2[node, new_solution[(i+1)%(N-1)]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%(N-1)]]) * (1-exploration_weight)\n\n            if obj1_diff + obj2_diff >= 0:\n                # Revert if not beneficial\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n                new_solution = np.insert(new_solution, j, new_solution[i])\n                new_solution = np.delete(new_solution, i+1)\n\n    # Dynamic path inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//3)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate with dynamic threshold\n        obj1_diff = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                     distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[-1], path[0]] -\n                     distance_matrix_1[path[-1], new_solution[k]]) * exploration_weight\n        obj2_diff = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                     distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                     distance_matrix_2[new_solution[-1], path[0]] -\n                     distance_matrix_2[path[-1], new_solution[k]]) * (1-exploration_weight)\n\n        if obj1_diff + obj2_diff < -0.1 * (obj1_mean + obj2_mean):\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a hybrid local search combining edge swaps, segment rotations, and probabilistic node insertions to generate diverse and high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        i, j, k = np.random.choice(N, size=3, replace=False)\n        if abs(i - j) > 1 and abs(j - k) > 1:\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            8.246852662926772,
            7.899599697928862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.5:\n        i, j, k = np.random.choice(N, size=3, replace=False)\n        if abs(i - j) > 1 and abs(j - k) > 1:\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation with adaptive probability, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    objectives_sorted = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        min_obj = np.min(objectives_sorted[:, i])\n        max_obj = np.max(objectives_sorted[:, i])\n        if max_obj == min_obj:\n            crowding_distances += 1.0\n        else:\n            normalized = (objectives_sorted[:, i] - min_obj) / (max_obj - min_obj)\n            crowding_distances += normalized\n\n    combined_scores = crowding_distances * (objectives_sorted[:, 0] + objectives_sorted[:, 1])\n    base_solution = archive[sorted_indices[np.argmax(combined_scores)]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4 + 0.3 * (combined_scores[np.argmax(combined_scores)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[np.argmax(combined_scores)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.410537933242505,
            10.698452549285157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    objectives_sorted = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        min_obj = np.min(objectives_sorted[:, i])\n        max_obj = np.max(objectives_sorted[:, i])\n        if max_obj == min_obj:\n            crowding_distances += 1.0\n        else:\n            normalized = (objectives_sorted[:, i] - min_obj) / (max_obj - min_obj)\n            crowding_distances += normalized\n\n    combined_scores = crowding_distances * (objectives_sorted[:, 0] + objectives_sorted[:, 1])\n    base_solution = archive[sorted_indices[np.argmax(combined_scores)]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4 + 0.3 * (combined_scores[np.argmax(combined_scores)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[np.argmax(combined_scores)] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware selection probability, then applies a hybrid local search combining segment reversal, adaptive node insertion, and probabilistic edge reversal with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                if not (objectives[i, 0] == objectives[j, 0] and objectives[i, 1] == objectives[j, 1]):\n                    dominance_counts[i] += 1\n    selection_probs = 1 / (1 + dominance_counts)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if j - i > 1:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.007874410534266,
            6.655212031894434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                if not (objectives[i, 0] == objectives[j, 0] and objectives[i, 1] == objectives[j, 1]):\n                    dominance_counts[i] += 1\n    selection_probs = 1 / (1 + dominance_counts)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if j - i > 1:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with lower combined objective values, then applies a hybrid local search combining adaptive node insertion with objective-aware segment reversal and conditional path rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], 1) + max(x[1][1], 1)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node insertion with objective-aware selection\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-aware segment reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Conditional path rotation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N//3)\n        rotated_path = np.roll(new_solution[:k], 1)\n\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n",
        "score": [
            8.45986928901458,
            8.690292924268105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], 1) + max(x[1][1], 1)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node insertion with objective-aware selection\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-aware segment reversal\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Conditional path rotation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N//3)\n        rotated_path = np.roll(new_solution[:k], 1)\n\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost:\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The new algorithm selects a solution from the archive based on a fitness-aware selection criterion, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-8)\n    weights = fitness_scores / np.sum(fitness_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n            if np.random.rand() < 0.3 and i > 0 and j < N-1:\n                new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.79893980269798,
            6.594923694298951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-8)\n    weights = fitness_scores / np.sum(fitness_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with edge swapping\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n            if np.random.rand() < 0.3 and i > 0 and j < N-1:\n                new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier dominance score combined with adaptive segment exchange and probabilistic node insertion, then applies a hybrid local search combining segment crossover with adaptive segment reversal and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                pareto_front[i] = False\n                break\n    if np.any(pareto_front):\n        candidates = [i for i, is_pareto in enumerate(pareto_front) if is_pareto]\n    else:\n        candidates = list(range(len(archive)))\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selection_scores = crowding_distances + 0.3 * np.sum(objectives, axis=1)\n    selected_idx = np.random.choice(candidates) if len(candidates) > 1 else candidates[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment crossover with adaptive segment reversal\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        c, d = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            if np.random.rand() < 0.4:\n                segment1 = segment1[::-1]\n                segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Edge insertion with probabilistic selection\n    if np.random.rand() < 0.3:\n        u, v = np.random.choice(new_solution, size=2, replace=False)\n        u_pos = np.where(new_solution == u)[0][0]\n        v_pos = np.where(new_solution == v)[0][0]\n        if abs(u_pos - v_pos) > 1:\n            if np.random.rand() < 0.5:\n                new_solution = np.roll(new_solution, -u_pos)\n                new_solution = np.insert(new_solution, 1, new_solution[-1])\n                new_solution = np.roll(new_solution, u_pos)\n            else:\n                new_solution = np.roll(new_solution, -v_pos)\n                new_solution = np.insert(new_solution, 1, new_solution[-1])\n                new_solution = np.roll(new_solution, v_pos)\n\n    return new_solution\n\n",
        "score": [
            7.492121852319986,
            7.322020178231888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                pareto_front[i] = False\n                break\n    if np.any(pareto_front):\n        candidates = [i for i, is_pareto in enumerate(pareto_front) if is_pareto]\n    else:\n        candidates = list(range(len(archive)))\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selection_scores = crowding_distances + 0.3 * np.sum(objectives, axis=1)\n    selected_idx = np.random.choice(candidates) if len(candidates) > 1 else candidates[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment crossover with adaptive segment reversal\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        c, d = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1 and d - c > 1:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            if np.random.rand() < 0.4:\n                segment1 = segment1[::-1]\n                segment2 = segment2[::-1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Edge insertion with probabilistic selection\n    if np.random.rand() < 0.3:\n        u, v = np.random.choice(new_solution, size=2, replace=False)\n        u_pos = np.where(new_solution == u)[0][0]\n        v_pos = np.where(new_solution == v)[0][0]\n        if abs(u_pos - v_pos) > 1:\n            if np.random.rand() < 0.5:\n                new_solution = np.roll(new_solution, -u_pos)\n                new_solution = np.insert(new_solution, 1, new_solution[-1])\n                new_solution = np.roll(new_solution, u_pos)\n            else:\n                new_solution = np.roll(new_solution, -v_pos)\n                new_solution = np.insert(new_solution, 1, new_solution[-1])\n                new_solution = np.roll(new_solution, v_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid objective score combining normalized objectives and dominance rank, then applies a novel local search combining segment transposition with probabilistic node insertion and adaptive edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj1 = objectives[:, 0] / np.max(objectives[:, 0])\n    normalized_obj2 = objectives[:, 1] / np.max(objectives[:, 1])\n\n    # Calculate dominance rank\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominance[i] += 1\n\n    combined_scores = normalized_obj1 * 0.5 + normalized_obj2 * 0.5 - dominance * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment transposition\n    if np.random.rand() < 0.45:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.3 + 0.4 * (1 - normalized_obj1[np.argmin(combined_scores)]):\n        i = np.random.randint(N)\n        j = (i + 1) % N\n        k = (j + 1) % N\n        if distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]] < distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            10.404872070893017,
            10.634528168289298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj1 = objectives[:, 0] / np.max(objectives[:, 0])\n    normalized_obj2 = objectives[:, 1] / np.max(objectives[:, 1])\n\n    # Calculate dominance rank\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominance[i] += 1\n\n    combined_scores = normalized_obj1 * 0.5 + normalized_obj2 * 0.5 - dominance * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment transposition\n    if np.random.rand() < 0.45:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Probabilistic node insertion\n    if np.random.rand() < 0.6:\n        node = new_solution[np.random.randint(N)]\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.3 + 0.4 * (1 - normalized_obj1[np.argmin(combined_scores)]):\n        i = np.random.randint(N)\n        j = (i + 1) % N\n        k = (j + 1) % N\n        if distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]] < distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection considering both objectives, then applies a hybrid local search combining segment rotation, node insertion with inversion, and adaptive edge swapping with dynamic probability checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(min(3, len(archive)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.5 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.156870456371566,
            10.682104883255475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(min(3, len(archive)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n            if np.random.rand() < 0.5 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated[i] = True\n                break\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = non_dominated_indices[np.random.choice(len(non_dominated_indices))]\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.895719321976745,
            7.2663139356687125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated[i] = True\n                break\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = non_dominated_indices[np.random.choice(len(non_dominated_indices))]\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5 and N > 3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n",
        "score": [
            4.60736924906,
            10.26400497372948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-aware selection strategy, then applies a novel local search operator that combines segment transposition with adaptive probabilistic node swapping and edge-based inversion to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    if np.random.rand() < 0.6:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n        if np.random.rand() < 0.3:\n            if pos1 > 0 and pos2 > 0:\n                new_solution[pos1-1], new_solution[pos2-1] = new_solution[pos2-1], new_solution[pos1-1]\n            if pos1 < N-1 and pos2 < N-1:\n                new_solution[pos1+1], new_solution[pos2+1] = new_solution[pos2+1], new_solution[pos1+1]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            else:\n                new_solution[a:b+1] = np.concatenate([new_solution[b:a:-1], [new_solution[a]]])\n\n    return new_solution\n\n",
        "score": [
            7.420747828134565,
            6.894164685417111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    if np.random.rand() < 0.6:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n        if np.random.rand() < 0.3:\n            if pos1 > 0 and pos2 > 0:\n                new_solution[pos1-1], new_solution[pos2-1] = new_solution[pos2-1], new_solution[pos1-1]\n            if pos1 < N-1 and pos2 < N-1:\n                new_solution[pos1+1], new_solution[pos2+1] = new_solution[pos2+1], new_solution[pos1+1]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            else:\n                new_solution[a:b+1] = np.concatenate([new_solution[b:a:-1], [new_solution[a]]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamically adjusted trade-off between objectives, then applies a hybrid local search combining segment rotation, edge swapping, and adaptive node insertion to generate a neighbor solution while ensuring feasibility and promoting diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        std_dev = np.std(objectives, axis=0)\n        weights = std_dev / np.sum(std_dev)\n    else:\n        weights = np.array([0.5, 0.5])\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive operations\n    operation = np.random.choice(['rotate', 'swap', 'insert'], p=[0.4, 0.3, 0.3])\n\n    if operation == 'rotate':\n        a = np.random.randint(N)\n        k = np.random.randint(1, N)\n        new_solution = np.concatenate([new_solution[a:], new_solution[:a]])\n\n    elif operation == 'swap':\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'insert':\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.088631374191484,
            5.731033419680667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        std_dev = np.std(objectives, axis=0)\n        weights = std_dev / np.sum(std_dev)\n    else:\n        weights = np.array([0.5, 0.5])\n\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive operations\n    operation = np.random.choice(['rotate', 'swap', 'insert'], p=[0.4, 0.3, 0.3])\n\n    if operation == 'rotate':\n        a = np.random.randint(N)\n        k = np.random.randint(1, N)\n        new_solution = np.concatenate([new_solution[a:], new_solution[:a]])\n\n    elif operation == 'swap':\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'insert':\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal, node insertion, and adaptive edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        crowding_distances = np.zeros(len(objectives))\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives) - 1):\n            crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution = np.insert(new_solution, j, new_solution[i])\n        new_solution = np.delete(new_solution, i + (1 if i < j else 0))\n\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.rand() < 0.3:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n                new_solution[j-1], new_solution[j] = new_solution[j], new_solution[j-1]\n\n    return new_solution\n\n",
        "score": [
            8.45573783339006,
            9.98693192821709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        crowding_distances = np.zeros(len(objectives))\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives) - 1):\n            crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution = np.insert(new_solution, j, new_solution[i])\n        new_solution = np.delete(new_solution, i + (1 if i < j else 0))\n\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.rand() < 0.3:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n                new_solution[j-1], new_solution[j] = new_solution[j], new_solution[j-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n",
        "score": [
            6.051948985144374,
            5.600676384129802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The new algorithm selects a solution from the archive using a score function that combines objectives with adaptive weights and applies a hybrid local search that prioritizes segment reversal with adaptive probabilities to generate diverse neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    alpha = np.random.uniform(0.4, 0.6)\n    scores = [alpha * obj[0] + (1 - alpha) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.4:  # Lower probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = alpha * cost1 + (1 - alpha) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal with adaptive segment length\n        segment_length = np.random.randint(2, min(5, N//2))\n        a = np.random.randint(N - segment_length + 1)\n        b = a + segment_length - 1\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.780452405383123,
            6.476663732193723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    alpha = np.random.uniform(0.4, 0.6)\n    scores = [alpha * obj[0] + (1 - alpha) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.4:  # Lower probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = alpha * cost1 + (1 - alpha) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal with adaptive segment length\n        segment_length = np.random.randint(2, min(5, N//2))\n        a = np.random.randint(N - segment_length + 1)\n        b = a + segment_length - 1\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired ranking, then applies a hybrid local search combining segment rotation, node swapping, and adaptive edge insertion with dynamic probabilistic checks to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        ranks[i] = dominated\n\n    base_solution = archive[np.argmin(ranks)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            7.272110043977971,
            7.617046008842777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated += 1\n        ranks[i] = dominated\n\n    base_solution = archive[np.argmin(ranks)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.4:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score while applying a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.820911251229378,
            5.437982603815841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware selection, then applies a hybrid local search combining segment reversal with adaptive swapping, node insertion with probabilistic edge flipping, and a novel segment shifting with dynamic probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[j+1], i] != objectives[sorted_indices[j-1], i]:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive swapping\n    if np.random.rand() < 0.4 + 0.3 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                swap_pos = np.random.randint(a, b)\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    # Node insertion with probabilistic edge flipping\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment shifting with dynamic probability\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            9.43633935755827,
            10.05516097754127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[j+1], i] != objectives[sorted_indices[j-1], i]:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive swapping\n    if np.random.rand() < 0.4 + 0.3 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                swap_pos = np.random.randint(a, b)\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    # Node insertion with probabilistic edge flipping\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment shifting with dynamic probability\n    if np.random.rand() < 0.3 + 0.2 * (crowding_distances[selected_idx] / np.max(crowding_distances)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = np.random.randint(len(new_solution)+1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment rotation, node insertion, and edge crossover with adaptive probability checks to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        objectives = np.array([x[1] for x in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        crowding_distances = np.zeros(len(archive))\n        crowding_distances[0] = crowding_distances[-1] = float('inf')\n\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] = (\n                (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) +\n                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n            )\n\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4 and N > 3:\n        i, j = sorted(np.random.choice(range(1, N-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.158227623585736,
            5.697552165502463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        objectives = np.array([x[1] for x in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        crowding_distances = np.zeros(len(archive))\n        crowding_distances[0] = crowding_distances[-1] = float('inf')\n\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] = (\n                (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) +\n                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n            )\n\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotated = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4 and N > 3:\n        i, j = sorted(np.random.choice(range(1, N-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            10.362927120535325,
            4.36751843854373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score combining both objectives with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks, while also incorporating a novel \"node cluster relocation\" operator that moves entire clusters of nodes between segments to improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.5 if std_dev[0] > std_dev[1] else 0.3\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+cluster_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - cluster_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.7590781906683155,
            5.207220973497582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.5 if std_dev[0] > std_dev[1] else 0.3\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+cluster_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - cluster_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on combined objective score\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, min(5, b-a+1))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_pos = (i + 1) % N\n\n            # Calculate cost difference\n            cost_diff = (distance_matrix_1[new_solution[i], node] +\n                         distance_matrix_1[node, new_solution[new_pos]] -\n                         distance_matrix_1[new_solution[i], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[i], node] +\n                         distance_matrix_2[node, new_solution[new_pos]] -\n                         distance_matrix_2[new_solution[i], new_solution[new_pos]])\n\n            if cost_diff < 0:\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(8, N//2))\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            6.439183326869049,
            5.703588908066958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on combined objective score\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, min(5, b-a+1))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                       distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                       distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_pos = (i + 1) % N\n\n            # Calculate cost difference\n            cost_diff = (distance_matrix_1[new_solution[i], node] +\n                         distance_matrix_1[node, new_solution[new_pos]] -\n                         distance_matrix_1[new_solution[i], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[i], node] +\n                         distance_matrix_2[node, new_solution[new_pos]] -\n                         distance_matrix_2[new_solution[i], new_solution[new_pos]])\n\n            if cost_diff < 0:\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(8, N//2))\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives with adaptive weights, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with probabilistic checks to ensure feasibility while exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    adaptive_weights = np.random.uniform(0.3, 0.7, size=2)\n    adaptive_weights /= np.sum(adaptive_weights)\n    combined_scores = norm_objectives[:, 0] * adaptive_weights[0] + norm_objectives[:, 1] * adaptive_weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.126082961379151,
            6.099587956824782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    adaptive_weights = np.random.uniform(0.3, 0.7, size=2)\n    adaptive_weights /= np.sum(adaptive_weights)\n    combined_scores = norm_objectives[:, 0] * adaptive_weights[0] + norm_objectives[:, 1] * adaptive_weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware ranking metric that prioritizes solutions in less-congested regions of the Pareto front, then applies a novel local search combining adaptive segment rotation, multi-objective-aware node insertion, and conditional path concatenation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(objectives[0])):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_indices[sorted_order[0]]] = float('inf')\n        crowding_distances[sorted_indices[sorted_order[-1]]] = float('inf')\n        for j in range(1, len(sorted_order)-1):\n            idx = sorted_indices[sorted_order[j]]\n            crowding_distances[idx] += (sorted_objectives[sorted_order[j+1], i] -\n                                       sorted_objectives[sorted_order[j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if cost_diff < 0:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    # Conditional path concatenation\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path1 = new_solution[:k]\n        path2 = new_solution[k:2*k]\n        concatenated_path = np.concatenate([path1, path2[::-1]])\n\n        # Evaluate concatenation\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        concatenated_cost = (distance_matrix_1[path1[-1], path2[0]] +\n                             distance_matrix_1[path2[-1], new_solution[2*k]] +\n                             distance_matrix_2[path1[-1], path2[0]] +\n                             distance_matrix_2[path2[-1], new_solution[2*k]])\n\n        if concatenated_cost < original_cost:\n            new_solution[:2*k] = concatenated_path\n\n    return new_solution\n\n",
        "score": [
            6.011426229424789,
            10.506004618122354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(objectives[0])):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_indices[sorted_order[0]]] = float('inf')\n        crowding_distances[sorted_indices[sorted_order[-1]]] = float('inf')\n        for j in range(1, len(sorted_order)-1):\n            idx = sorted_indices[sorted_order[j]]\n            crowding_distances[idx] += (sorted_objectives[sorted_order[j+1], i] -\n                                       sorted_objectives[sorted_order[j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if cost_diff < 0:\n                new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    # Conditional path concatenation\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path1 = new_solution[:k]\n        path2 = new_solution[k:2*k]\n        concatenated_path = np.concatenate([path1, path2[::-1]])\n\n        # Evaluate concatenation\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        concatenated_cost = (distance_matrix_1[path1[-1], path2[0]] +\n                             distance_matrix_1[path2[-1], new_solution[2*k]] +\n                             distance_matrix_2[path1[-1], path2[0]] +\n                             distance_matrix_2[path2[-1], new_solution[2*k]])\n\n        if concatenated_cost < original_cost:\n            new_solution[:2*k] = concatenated_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score (prioritizing solutions with better normalized objective values and higher diversity), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(normalized_obj[:, None, :] - normalized_obj[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n    combined_scores = np.sum(normalized_obj, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.3:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n",
        "score": [
            6.876049020567241,
            7.772848311539981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(np.abs(normalized_obj[:, None, :] - normalized_obj[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n    combined_scores = np.sum(normalized_obj, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.3:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The new algorithm selects a solution from the archive using a hypervolume-based selection criterion, then applies a hybrid local search combining segment reversal with probabilistic edge swaps and adaptive node insertion, ensuring feasibility through dynamic constraint checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        dominated = (objectives[:, 0] <= objectives[i, 0]) & (objectives[:, 1] <= objectives[i, 1])\n        dominated = dominated & ~np.eye(len(archive), dtype=bool)\n        if np.any(dominated):\n            continue\n        contrib = (ref_point[0] - objectives[i, 0]) * (ref_point[1] - objectives[i, 1])\n        hv_contributions.append((contrib, i))\n    if not hv_contributions:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        _, selected_idx = max(hv_contributions)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment reversal with dynamic length\n        seg_length = min(N//2, max(2, int(np.random.exponential(N/4))))\n        a = np.random.randint(N - seg_length + 1)\n        b = a + seg_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if np.random.rand() < 0.7:\n        # Probabilistic edge swap\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a > 0 and b < N-1 and new_solution[a-1] != new_solution[b] and new_solution[b+1] != new_solution[a]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        # Adaptive node insertion\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos and abs(new_pos - old_pos) > 1:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.934264003077155,
            6.731303710147465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        dominated = (objectives[:, 0] <= objectives[i, 0]) & (objectives[:, 1] <= objectives[i, 1])\n        dominated = dominated & ~np.eye(len(archive), dtype=bool)\n        if np.any(dominated):\n            continue\n        contrib = (ref_point[0] - objectives[i, 0]) * (ref_point[1] - objectives[i, 1])\n        hv_contributions.append((contrib, i))\n    if not hv_contributions:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        _, selected_idx = max(hv_contributions)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.5:\n        # Segment reversal with dynamic length\n        seg_length = min(N//2, max(2, int(np.random.exponential(N/4))))\n        a = np.random.randint(N - seg_length + 1)\n        b = a + seg_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if np.random.rand() < 0.7:\n        # Probabilistic edge swap\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a > 0 and b < N-1 and new_solution[a-1] != new_solution[b] and new_solution[b+1] != new_solution[a]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.4:\n        # Adaptive node insertion\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos and abs(new_pos - old_pos) > 1:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance aware score that prioritizes solutions with better objective ratios, then applies a hybrid local search combining adaptive segment rotation with objective-weighted node insertion and conditional path inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf')))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Evaluate rotation based on weighted objectives\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        rotated_cost = (weight * (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                                 distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                                    distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]]))\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-weighted node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate weighted cost difference\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion with objective weights\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        inverted_cost = (weight * (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                                  distance_matrix_1[inverted_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                                    distance_matrix_2[inverted_path[-1], new_solution[k]]))\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            4.402102636978989,
            9.904082565578397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf')))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Evaluate rotation based on weighted objectives\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        rotated_cost = (weight * (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                                 distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                                    distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]]))\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-weighted node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate weighted cost difference\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion with objective weights\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        inverted_cost = (weight * (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                                  distance_matrix_1[inverted_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                                    distance_matrix_2[inverted_path[-1], new_solution[k]]))\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score (prioritizing solutions with better balanced objective values), then applies a hybrid local search combining segment reversal, node insertion, and adaptive edge swaps with probabilistic checks to ensure feasibility and exploration of diverse search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i+1:j] = np.roll(new_solution[i+1:j], 1)\n\n    if np.random.rand() < 0.4:\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        if a < b < c:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[a], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            6.515387739333661,
            7.5994128032793355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i+1:j] = np.roll(new_solution[i+1:j], 1)\n\n    if np.random.rand() < 0.4:\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        if a < b < c:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[a], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware objective score while applying a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection criterion, then applies a hybrid local search combining segment transposition with probabilistic node insertion, followed by a novel edge-based crossover operator that preserves feasibility while exploring the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a1, a2 = sorted(np.random.choice(N, size=2, replace=False))\n        b1, b2 = sorted(np.random.choice(N, size=2, replace=False))\n        segment_a = new_solution[a1:a2+1]\n        segment_b = new_solution[b1:b2+1]\n        new_solution = np.concatenate([new_solution[:a1], segment_b, new_solution[a2+1:b1], segment_a, new_solution[b2+1:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.617478934741438,
            9.716614841863748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a1, a2 = sorted(np.random.choice(N, size=2, replace=False))\n        b1, b2 = sorted(np.random.choice(N, size=2, replace=False))\n        segment_a = new_solution[a1:a2+1]\n        segment_b = new_solution[b1:b2+1]\n        new_solution = np.concatenate([new_solution[:a1], segment_b, new_solution[a2+1:b1], segment_a, new_solution[b2+1:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid objective score combining Pareto dominance and objective-space diversity, then applies a novel local search combining segment permutation, node insertion with probabilistic edge reversal, and segment rotation with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3 + 0.3 * (objectives[selected_idx][0] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    return new_solution\n\n",
        "score": [
            7.299243668148729,
            6.6907583163817765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) > 0:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3 + 0.3 * (objectives[selected_idx][0] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a Pareto-dominance aware score that prioritizes solutions with better objective ratios, then applies a hybrid local search combining adaptive segment rotation with objective-weighted node insertion and conditional path inversion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf')))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Evaluate rotation based on weighted objectives\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        rotated_cost = (weight * (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                                 distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                                    distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]]))\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-weighted node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate weighted cost difference\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion with objective weights\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        inverted_cost = (weight * (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                                  distance_matrix_1[inverted_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                                    distance_matrix_2[inverted_path[-1], new_solution[k]]))\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective ratio analysis that adapts weights between objectives based on their relative performance, then applies a hybrid local search combining adaptive segment shuffling with objective-aware node swapping and conditional path reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-8)\n    sorted_indices = np.argsort(ratios)\n    base_solution = archive[sorted_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        shuffled_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                 distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                    distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        if shuffled_cost < original_cost:\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                      distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                      distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        reversed_cost = (weight * (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                                  distance_matrix_1[reversed_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                                    distance_matrix_2[reversed_path[-1], new_solution[k]]))\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            4.5559020636736065,
            10.182530526032552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-8)\n    sorted_indices = np.argsort(ratios)\n    base_solution = archive[sorted_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        shuffled_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                 distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                    distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        if shuffled_cost < original_cost:\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                   distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                   distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                      distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                      distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        reversed_cost = (weight * (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                                  distance_matrix_1[reversed_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                                    distance_matrix_2[reversed_path[-1], new_solution[k]]))\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score (prioritizing solutions that are not dominated by many others), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilistic checks that consider both objective improvements and solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                non_dominated[i] = False\n                break\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.linalg.norm(objectives - objectives[i], axis=1))\n    combined_scores = np.where(non_dominated, diversity_scores, np.inf)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.792568491301103,
            6.470531023521902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                non_dominated[i] = False\n                break\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.linalg.norm(objectives - objectives[i], axis=1))\n    combined_scores = np.where(non_dominated, diversity_scores, np.inf)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions, then applies a hybrid local search combining segment reversal, node insertion, and probabilistic edge swaps with feasibility checks to maintain solution validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j != (i+1) % N) and (j != (i-1+N) % N):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.258537815313858,
            9.622438737411937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j != (i+1) % N) and (j != (i-1+N) % N):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection with adaptive weights, then applies a hybrid local search combining segment rotation, node insertion with inversion, and probabilistic edge swapping to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj <= obj).all() and (other_obj < obj).any():\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.153882238326396,
            6.966444771648395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj <= obj).all() and (other_obj < obj).any():\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = np.random.choice(N, size=3, replace=False)\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-based selection with dynamic weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    crowding = np.zeros(len(archive))\n    for obj in range(2):\n        sorted_indices = np.argsort(objectives[:, obj])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj] - objectives[sorted_indices[i-1], obj]) / (objectives[sorted_indices[-1], obj] - objectives[sorted_indices[0], obj] + 1e-10)\n\n    combined_scores = fronts[:, 0] * 0.3 + fronts[:, 1] * 0.7 + crowding * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.382603622826176,
            5.522132486865174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    crowding = np.zeros(len(archive))\n    for obj in range(2):\n        sorted_indices = np.argsort(objectives[:, obj])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj] - objectives[sorted_indices[i-1], obj]) / (objectives[sorted_indices[-1], obj] - objectives[sorted_indices[0], obj] + 1e-10)\n\n    combined_scores = fronts[:, 0] * 0.3 + fronts[:, 1] * 0.7 + crowding * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-based selection, then applies a hybrid local search combining segment rotation, node insertion, and edge swapping with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_indices = fronts[:, obj_idx]\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], obj_idx] != objectives[sorted_indices[i-1], obj_idx]:\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx])\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.587425664070887,
            8.10580385332647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    fronts = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_indices = fronts[:, obj_idx]\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], obj_idx] != objectives[sorted_indices[i-1], obj_idx]:\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx])\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of dominance depth and objective-space distance, then applies a novel local search combining segment permutation with adaptive node insertion and probabilistic edge flipping to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated_counts[i] += 1\n    distances = np.array([np.linalg.norm(x[1]) for x in archive])\n    combined_scores = dominated_counts * 0.5 + distances * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.45:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1].copy()\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.35 and new_pos > 0:\n                if distance_matrix_1[new_solution[new_pos-1], node] + distance_matrix_1[node, new_solution[(new_pos+1)%N]] < distance_matrix_1[new_solution[new_pos-1], new_solution[(new_pos+1)%N]]:\n                    new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    return new_solution\n\n",
        "score": [
            6.728877194320953,
            6.601832612592694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated_counts[i] += 1\n    distances = np.array([np.linalg.norm(x[1]) for x in archive])\n    combined_scores = dominated_counts * 0.5 + distances * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.45:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 2:\n            segment = new_solution[a:b+1].copy()\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.35 and new_pos > 0:\n                if distance_matrix_1[new_solution[new_pos-1], node] + distance_matrix_1[node, new_solution[(new_pos+1)%N]] < distance_matrix_1[new_solution[new_pos-1], new_solution[(new_pos+1)%N]]:\n                    new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that prioritizes the less optimized objective, then applies a novel local search combining adaptive segment reversal with objective-aware node insertion and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the largest difference between objectives\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Verify feasibility\n            if len(np.unique(new_solution)) == N:\n                # Calculate cost difference for both objectives\n                cost_diff = (distance_matrix_1[new_solution[j-1], node] +\n                             distance_matrix_1[node, new_solution[(j+1)%N]] -\n                             distance_matrix_1[new_solution[j-1], new_solution[(j+1)%N]] +\n                             distance_matrix_2[new_solution[j-1], node] +\n                             distance_matrix_2[node, new_solution[(j+1)%N]] -\n                             distance_matrix_2[new_solution[j-1], new_solution[(j+1)%N]])\n\n                if cost_diff > 0:\n                    # Revert if no improvement\n                    new_solution = np.delete(new_solution, j)\n                    new_solution = np.insert(new_solution, i, node)\n            else:\n                # Revert if infeasible\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            7.048268437074176,
            6.619781888433415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the largest difference between objectives\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Verify feasibility\n            if len(np.unique(new_solution)) == N:\n                # Calculate cost difference for both objectives\n                cost_diff = (distance_matrix_1[new_solution[j-1], node] +\n                             distance_matrix_1[node, new_solution[(j+1)%N]] -\n                             distance_matrix_1[new_solution[j-1], new_solution[(j+1)%N]] +\n                             distance_matrix_2[new_solution[j-1], node] +\n                             distance_matrix_2[node, new_solution[(j+1)%N]] -\n                             distance_matrix_2[new_solution[j-1], new_solution[(j+1)%N]])\n\n                if cost_diff > 0:\n                    # Revert if no improvement\n                    new_solution = np.delete(new_solution, j)\n                    new_solution = np.insert(new_solution, i, node)\n            else:\n                # Revert if infeasible\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of crowding distance and dominance count, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probabilities to ensure feasibility and exploration of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-8)\n\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1] and\n                    (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1])):\n                    dominance[i] += 1\n\n    scores = crowding * 0.6 - dominance * 0.4\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != j-1 and i != j+1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.022164923939918,
            9.003337109198565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-8)\n\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1] and\n                    (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1])):\n                    dominance[i] += 1\n\n    scores = crowding * 0.6 - dominance * 0.4\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and i != j-1 and i != j+1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective values and solution quality, then applies a novel local search combining adaptive segment insertion with objective-aware node rotation and conditional path fragmentation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\n",
        "score": [
            5.139445534491379,
            7.535243848208315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing non-dominated solutions and their neighbors) and applies a hybrid local search combining segment reversal, node insertion, and edge swapping with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[ranks[0]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j < N-1:\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            6.103258126764633,
            5.777461236260012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[ranks[0]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j < N-1:\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search combining segment rotation, node swapping with path optimization, and probabilistic edge swapping to ensure feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    combined_scores = crowding_distances * 0.7 + (1 - np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 0] * 0.2 + np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 1] * 0.1)\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if np.random.rand() < 0.4:\n            path = new_solution[(i+1)%N:(j+1)%N] if i < j else new_solution[(j+1)%N:(i+1)%N]\n            if len(path) > 2:\n                path_costs = np.array([distance_matrix_1[path[k], path[(k+1)%len(path)]] + distance_matrix_2[path[k], path[(k+1)%len(path)]] for k in range(len(path))])\n                best_pos = np.argmin(path_costs)\n                if best_pos != 0:\n                    new_path = np.roll(path, -best_pos)\n                    if i < j:\n                        new_solution[(i+1)%N:(j+1)%N] = new_path\n                    else:\n                        new_solution[(j+1)%N:(i+1)%N] = new_path\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] < distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.888885936126628,
            9.427603043500737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    combined_scores = crowding_distances * 0.7 + (1 - np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 0] * 0.2 + np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 1] * 0.1)\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if np.random.rand() < 0.4:\n            path = new_solution[(i+1)%N:(j+1)%N] if i < j else new_solution[(j+1)%N:(i+1)%N]\n            if len(path) > 2:\n                path_costs = np.array([distance_matrix_1[path[k], path[(k+1)%len(path)]] + distance_matrix_2[path[k], path[(k+1)%len(path)]] for k in range(len(path))])\n                best_pos = np.argmin(path_costs)\n                if best_pos != 0:\n                    new_path = np.roll(path, -best_pos)\n                    if i < j:\n                        new_solution[(i+1)%N:(j+1)%N] = new_path\n                    else:\n                        new_solution[(j+1)%N:(i+1)%N] = new_path\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] < distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective values and solution quality, then applies a novel local search combining adaptive segment insertion with objective-aware node rotation and conditional path fragmentation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria selection score combining objective values and structural diversity, then applies a hybrid local search combining adaptive path merging with objective-aware node swapping and probabilistic edge reconfiguration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity = np.array([len(set(x[0])) for x in archive])\n    combined_scores = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5 + diversity * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive path merging\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        segment1 = new_solution[:k]\n        segment2 = new_solution[k:]\n        merged = np.concatenate([segment1, segment2[::-1]])\n        cost1 = sum(distance_matrix_1[merged[k-1], merged[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[merged[k-1], merged[k]] for k in range(N))\n        if cost1 * 0.5 + cost2 * 0.5 < sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N)) * 0.5 + sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N)) * 0.5:\n            new_solution = merged\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if new_cost1 * 0.6 + new_cost2 * 0.4 < cost1 * 0.6 + cost2 * 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge reconfiguration\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N-1)\n        if np.random.rand() < 0.5:\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n        else:\n            new_solution[k-1], new_solution[k] = new_solution[k], new_solution[k-1]\n\n    return new_solution\n\n",
        "score": [
            6.163128157738607,
            6.741315459722698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity = np.array([len(set(x[0])) for x in archive])\n    combined_scores = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5 + diversity * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive path merging\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        segment1 = new_solution[:k]\n        segment2 = new_solution[k:]\n        merged = np.concatenate([segment1, segment2[::-1]])\n        cost1 = sum(distance_matrix_1[merged[k-1], merged[k]] for k in range(N))\n        cost2 = sum(distance_matrix_2[merged[k-1], merged[k]] for k in range(N))\n        if cost1 * 0.5 + cost2 * 0.5 < sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(N)) * 0.5 + sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(N)) * 0.5:\n            new_solution = merged\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if new_cost1 * 0.6 + new_cost2 * 0.4 < cost1 * 0.6 + cost2 * 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge reconfiguration\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N-1)\n        if np.random.rand() < 0.5:\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n        else:\n            new_solution[k-1], new_solution[k] = new_solution[k], new_solution[k-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic crowding distance metric, then applies a hybrid local search combining segment inversion, node insertion, and edge swapping with adaptive probability checks to ensure feasibility and diversity while prioritizing non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0] + 1e-8)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i+1) % N != j and (j+1) % N != i:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.796718332143826,
            9.7488760314874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0] + 1e-8)\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.delete(new_solution, old_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i+1) % N != j and (j+1) % N != i:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective values and solution quality, then applies a novel local search combining adaptive segment insertion with objective-aware node rotation and conditional path fragmentation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective and diversity score, then applies a hybrid local search combining adaptive segment rearrangement, objective-biased node swapping, and conditional path reordering with probabilistic segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    combined_scores = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5\n    diversity_scores = np.array([np.sum(np.diff(x[0])**2) for x in archive])\n    selection_scores = combined_scores + diversity_scores * 0.3\n    base_solution = archive[np.argmin(selection_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.5 + cost2 * 0.5\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    if np.random.rand() < 0.6:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        cost1 = (distance_matrix_1[new_solution[pos1-1], node2] + distance_matrix_1[node2, new_solution[pos1+1 if pos1 < N-1 else 0]] +\n                distance_matrix_1[new_solution[pos2-1], node1] + distance_matrix_1[node1, new_solution[pos2+1 if pos2 < N-1 else 0]] -\n                distance_matrix_1[new_solution[pos1-1], node1] - distance_matrix_1[node1, new_solution[pos1+1 if pos1 < N-1 else 0]] -\n                distance_matrix_1[new_solution[pos2-1], node2] - distance_matrix_1[node2, new_solution[pos2+1 if pos2 < N-1 else 0]])\n        cost2 = (distance_matrix_2[new_solution[pos1-1], node2] + distance_matrix_2[node2, new_solution[pos1+1 if pos1 < N-1 else 0]] +\n                distance_matrix_2[new_solution[pos2-1], node1] + distance_matrix_2[node1, new_solution[pos2+1 if pos2 < N-1 else 0]] -\n                distance_matrix_2[new_solution[pos1-1], node1] - distance_matrix_2[node1, new_solution[pos1+1 if pos1 < N-1 else 0]] -\n                distance_matrix_2[new_solution[pos2-1], node2] - distance_matrix_2[node2, new_solution[pos2+1 if pos2 < N-1 else 0]])\n\n        if cost1 * 0.5 + cost2 * 0.5 < 0:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        new_segment = segment[::-1] if np.random.rand() < 0.5 else np.roll(segment, np.random.randint(1, k))\n        cost1 = (distance_matrix_1[new_solution[-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.5 + cost2 * 0.5 < 0:\n            new_solution[:k] = new_segment\n\n    return new_solution\n\n",
        "score": [
            6.145571927701348,
            6.191056639415276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    combined_scores = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5\n    diversity_scores = np.array([np.sum(np.diff(x[0])**2) for x in archive])\n    selection_scores = combined_scores + diversity_scores * 0.3\n    base_solution = archive[np.argmin(selection_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.5 + cost2 * 0.5\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    if np.random.rand() < 0.6:\n        node1, node2 = np.random.choice(new_solution, size=2, replace=False)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n        cost1 = (distance_matrix_1[new_solution[pos1-1], node2] + distance_matrix_1[node2, new_solution[pos1+1 if pos1 < N-1 else 0]] +\n                distance_matrix_1[new_solution[pos2-1], node1] + distance_matrix_1[node1, new_solution[pos2+1 if pos2 < N-1 else 0]] -\n                distance_matrix_1[new_solution[pos1-1], node1] - distance_matrix_1[node1, new_solution[pos1+1 if pos1 < N-1 else 0]] -\n                distance_matrix_1[new_solution[pos2-1], node2] - distance_matrix_1[node2, new_solution[pos2+1 if pos2 < N-1 else 0]])\n        cost2 = (distance_matrix_2[new_solution[pos1-1], node2] + distance_matrix_2[node2, new_solution[pos1+1 if pos1 < N-1 else 0]] +\n                distance_matrix_2[new_solution[pos2-1], node1] + distance_matrix_2[node1, new_solution[pos2+1 if pos2 < N-1 else 0]] -\n                distance_matrix_2[new_solution[pos1-1], node1] - distance_matrix_2[node1, new_solution[pos1+1 if pos1 < N-1 else 0]] -\n                distance_matrix_2[new_solution[pos2-1], node2] - distance_matrix_2[node2, new_solution[pos2+1 if pos2 < N-1 else 0]])\n\n        if cost1 * 0.5 + cost2 * 0.5 < 0:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        new_segment = segment[::-1] if np.random.rand() < 0.5 else np.roll(segment, np.random.randint(1, k))\n        cost1 = (distance_matrix_1[new_solution[-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.5 + cost2 * 0.5 < 0:\n            new_solution[:k] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective values and solution quality, then applies a novel local search combining adaptive segment insertion with objective-aware node rotation and conditional path fragmentation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted dominance score that prioritizes diversity and objective balance, then applies a hybrid local search combining adaptive path reversal with objective-aware segment swapping and conditional node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) / (1 + np.sum(np.abs(np.diff(x[0])))))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.4 + cost2 * 0.6\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        reversed_segment = segment[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], reversed_segment[0]] +\n                distance_matrix_1[reversed_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], reversed_segment[0]] +\n                distance_matrix_2[reversed_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.4 + cost2 * 0.6 < 0:\n            new_solution[:k] = reversed_segment\n\n    if np.random.rand() < 0.2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.063988254808041,
            5.421604791048785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) / (1 + np.sum(np.abs(np.diff(x[0])))))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.4 + cost2 * 0.6\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        reversed_segment = segment[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], reversed_segment[0]] +\n                distance_matrix_1[reversed_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], reversed_segment[0]] +\n                distance_matrix_2[reversed_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.4 + cost2 * 0.6 < 0:\n            new_solution[:k] = reversed_segment\n\n    if np.random.rand() < 0.2:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective values and solution quality, then applies a novel local search combining adaptive segment insertion with objective-aware node rotation and conditional path fragmentation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            candidate_solution = np.insert(candidate.copy(), i, segment)\n\n            cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware node rotation\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//3)\n        segment = new_solution[:k]\n        rotated_segment = np.roll(segment, np.random.randint(1, k))\n\n        cost1 = (distance_matrix_1[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_1[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], segment[0]] -\n                distance_matrix_1[segment[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], rotated_segment[0]] +\n                distance_matrix_2[rotated_segment[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], segment[0]] -\n                distance_matrix_2[segment[-1], new_solution[k]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[:k] = rotated_segment\n\n    # Conditional path fragmentation\n    if np.random.rand() < 0.3:\n        k = np.random.randint(3, N//2)\n        fragment = new_solution[k:k+np.random.randint(2, min(5, N-k))]\n        fragment_pos = np.where(np.isin(new_solution, fragment))[0]\n\n        if len(fragment_pos) > 1:\n            new_solution = np.concatenate([new_solution[:fragment_pos[0]],\n                                         fragment[::-1],\n                                         new_solution[fragment_pos[-1]+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining adaptive segment reversal with objective-balanced node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Objective-balanced node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n        cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.2:\n        k = np.random.randint(3, N//2)\n        path = new_solution[k:k+np.random.randint(2, min(6, N-k))]\n        path_pos = np.where(np.isin(new_solution, path))[0]\n\n        if len(path_pos) > 1:\n            new_solution[path_pos[0]:path_pos[-1]+1] = new_solution[path_pos[-1]:path_pos[0]-1:-1]\n\n    return new_solution\n\n",
        "score": [
            5.294541379840874,
            7.403120741909403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + np.sum(np.diff(x[0])**2)))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Objective-balanced node swapping\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%N]])\n        cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n        if cost1 * 0.6 + cost2 * 0.4 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.2:\n        k = np.random.randint(3, N//2)\n        path = new_solution[k:k+np.random.randint(2, min(6, N-k))]\n        path_pos = np.where(np.isin(new_solution, path))[0]\n\n        if len(path_pos) > 1:\n            new_solution[path_pos[0]:path_pos[-1]+1] = new_solution[path_pos[-1]:path_pos[0]-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This new algorithm selects a solution from the archive based on an adaptive objective score that prioritizes solutions with high crowding distance and balanced objectives, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with dynamic probabilities to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices_1 = np.argsort(objectives[:, 0])\n    sorted_indices_2 = np.argsort(objectives[:, 1])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices_1[i]] += (objectives[sorted_indices_1[i+1], 0] - objectives[sorted_indices_1[i-1], 0]) / (objectives[sorted_indices_1[-1], 0] - objectives[sorted_indices_1[0], 0])\n        crowding_distances[sorted_indices_2[i]] += (objectives[sorted_indices_2[i+1], 1] - objectives[sorted_indices_2[i-1], 1]) / (objectives[sorted_indices_2[-1], 1] - objectives[sorted_indices_2[0], 1])\n    combined_scores = objectives[:, 0] * 0.4 + objectives[:, 1] * 0.4 + crowding_distances * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.6:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.198997396376513,
            5.415950870840465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices_1 = np.argsort(objectives[:, 0])\n    sorted_indices_2 = np.argsort(objectives[:, 1])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices_1[i]] += (objectives[sorted_indices_1[i+1], 0] - objectives[sorted_indices_1[i-1], 0]) / (objectives[sorted_indices_1[-1], 0] - objectives[sorted_indices_1[0], 0])\n        crowding_distances[sorted_indices_2[i]] += (objectives[sorted_indices_2[i+1], 1] - objectives[sorted_indices_2[i-1], 1]) / (objectives[sorted_indices_2[-1], 1] - objectives[sorted_indices_2[0], 1])\n    combined_scores = objectives[:, 0] * 0.4 + objectives[:, 1] * 0.4 + crowding_distances * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.6:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier-aware selection criterion, then applies a hybrid local search combining node sequence reversal with probabilistic segment swapping and adaptive edge reinsertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(objectives[:, 0] + objectives[:, 1])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node sequence reversal with probabilistic segment swapping\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                c, d = sorted(np.random.choice(N, size=2, replace=False))\n                if d - c > 1 and c != a and d != b:\n                    temp = new_solution[c:d+1].copy()\n                    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n                    new_solution = np.concatenate([new_solution[:a], temp, new_solution[a:]])\n\n    # Adaptive edge reinsertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if distance_matrix_1[new_solution[new_pos-1], node] + distance_matrix_1[node, new_solution[new_pos+1]] < distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos+1]]:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.616149227414551,
            6.8717678428185796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(objectives[:, 0] + objectives[:, 1])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node sequence reversal with probabilistic segment swapping\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            if np.random.rand() < 0.3:\n                c, d = sorted(np.random.choice(N, size=2, replace=False))\n                if d - c > 1 and c != a and d != b:\n                    temp = new_solution[c:d+1].copy()\n                    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n                    new_solution = np.concatenate([new_solution[:a], temp, new_solution[a:]])\n\n    # Adaptive edge reinsertion\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if distance_matrix_1[new_solution[new_pos-1], node] + distance_matrix_1[node, new_solution[new_pos+1]] < distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos+1]]:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a Pareto-dominance aware score that prioritizes solutions with better objective ratios, then applies a hybrid local search combining adaptive segment rotation with objective-weighted node insertion and conditional path inversion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf')))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Evaluate rotation based on weighted objectives\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        rotated_cost = (weight * (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                                 distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                                    distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]]))\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-weighted node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate weighted cost difference\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion with objective weights\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        inverted_cost = (weight * (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                                  distance_matrix_1[inverted_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                                    distance_matrix_2[inverted_path[-1], new_solution[k]]))\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines objective ratios and Pareto efficiency, then applies a novel local search combining adaptive segment shuffling with objective-balanced node relocations and conditional path reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf'), x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment shuffling\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Objective-balanced node relocations\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.3, 0.7)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path reordering\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reordered_path = np.roll(path, np.random.randint(1, len(path)))\n\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        reordered_cost = (weight * (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                                   distance_matrix_1[reordered_path[-1], new_solution[k]]) +\n                         (1-weight) * (distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                                      distance_matrix_2[reordered_path[-1], new_solution[k]]))\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n",
        "score": [
            5.126149642824152,
            10.520925901909225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf'), x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment shuffling\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Objective-balanced node relocations\n    if np.random.rand() < 0.8:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.3, 0.7)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path reordering\n    if np.random.rand() < 0.6:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reordered_path = np.roll(path, np.random.randint(1, len(path)))\n\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        reordered_cost = (weight * (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                                   distance_matrix_1[reordered_path[-1], new_solution[k]]) +\n                         (1-weight) * (distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                                      distance_matrix_2[reordered_path[-1], new_solution[k]]))\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            cost_diff = (distance_matrix_1[new_solution[new_pos-1], node] +\n                         distance_matrix_1[node, new_solution[(new_pos+1)%N]] +\n                         distance_matrix_2[new_solution[new_pos-1], node] +\n                         distance_matrix_2[node, new_solution[(new_pos+1)%N]] -\n                         distance_matrix_1[new_solution[old_pos-1], node] -\n                         distance_matrix_1[node, new_solution[(old_pos+1)%N]] -\n                         distance_matrix_2[new_solution[old_pos-1], node] -\n                         distance_matrix_2[node, new_solution[(old_pos+1)%N]])\n\n            if cost_diff < 0 and np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reordered_path = np.random.permutation(path)\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reordered_cost = (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_1[reordered_path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_2[reordered_path[-1], new_solution[k]])\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n",
        "score": [
            6.044629407931845,
            6.225817748509117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n            cost_diff = (distance_matrix_1[new_solution[new_pos-1], node] +\n                         distance_matrix_1[node, new_solution[(new_pos+1)%N]] +\n                         distance_matrix_2[new_solution[new_pos-1], node] +\n                         distance_matrix_2[node, new_solution[(new_pos+1)%N]] -\n                         distance_matrix_1[new_solution[old_pos-1], node] -\n                         distance_matrix_1[node, new_solution[(old_pos+1)%N]] -\n                         distance_matrix_2[new_solution[old_pos-1], node] -\n                         distance_matrix_2[node, new_solution[(old_pos+1)%N]])\n\n            if cost_diff < 0 and np.random.rand() < 0.3:\n                new_solution[new_pos], new_solution[(new_pos+1)%N] = new_solution[(new_pos+1)%N], new_solution[new_pos]\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reordered_path = np.random.permutation(path)\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reordered_cost = (distance_matrix_1[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_1[reordered_path[-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[-1], reordered_path[0]] +\n                          distance_matrix_2[reordered_path[-1], new_solution[k]])\n\n        if reordered_cost < original_cost:\n            new_solution[:k] = reordered_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{The new algorithm selects a solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and select solution with best combined objective\n    max_obj1 = max(x[1][0] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b-a+1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, k)\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n            # Calculate cost difference\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[(j-1)%N], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[(j-1)%N], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[(j-1)%N], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[(j-1)%N], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if cost_diff >= 0:\n                # Revert if no improvement\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            6.565521037640902,
            5.569406087108741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and select solution with best combined objective\n    max_obj1 = max(x[1][0] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b-a+1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, k)\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n            # Calculate cost difference\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[(j-1)%N], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[(j-1)%N], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[(j-1)%N], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[(j-1)%N], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n            if cost_diff >= 0:\n                # Revert if no improvement\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing non-dominated solutions and their neighbors) and applies a hybrid local search combining segment reversal, node insertion, and edge swapping with adaptive probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[ranks[0]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j < N-1:\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-based selection and applies a hybrid local search combining segment reversal, node insertion, and edge swapping with adaptive probabilistic checks, while also incorporating a novel 'k-swap' operator for higher-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, 4)\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        new_solution[indices] = new_solution[indices[::-1]]\n\n    return new_solution\n\n",
        "score": [
            9.327035467731612,
            8.479187014369371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, 4)\n        indices = sorted(np.random.choice(N, size=k, replace=False))\n        new_solution[indices] = new_solution[indices[::-1]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that prioritizes underperforming objectives, then applies a hybrid local search combining adaptive segment reversal with objective-aware node insertion and conditional path rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalized objective score prioritizing underperforming objectives\n    min_obj1 = min(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    archive.sort(key=lambda x: (x[1][0]/min_obj1 + x[1][1]/min_obj2))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost * 0.95:  # More aggressive acceptance\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Evaluate insertion\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]])\n\n            if new_cost > original_cost:  # Revert if worse\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//3)\n        rotated_path = np.roll(new_solution[:k], 1)\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost * 1.05:  # More lenient acceptance\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n",
        "score": [
            10.536932526686718,
            10.6280897704004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalized objective score prioritizing underperforming objectives\n    min_obj1 = min(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    archive.sort(key=lambda x: (x[1][0]/min_obj1 + x[1][1]/min_obj2))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost * 0.95:  # More aggressive acceptance\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Evaluate insertion\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]])\n\n            if new_cost > original_cost:  # Revert if worse\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//3)\n        rotated_path = np.roll(new_solution[:k], 1)\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n        rotated_cost = (distance_matrix_1[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_1[rotated_path[-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[-1], rotated_path[0]] +\n                        distance_matrix_2[rotated_path[-1], new_solution[k]])\n\n        if rotated_cost < original_cost * 1.05:  # More lenient acceptance\n            new_solution[:k] = rotated_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection, then applies a hybrid local search combining segment rotation, adaptive node insertion, and probabilistic edge swapping to explore the solution space while maintaining feasibility and promoting diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_solution = archive[np.random.choice(non_dominated)][0].copy()\n    else:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            insert_pos = min(new_pos, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != 0 or b != N-1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.403580773052326,
            7.92061311823454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_solution = archive[np.random.choice(non_dominated)][0].copy()\n    else:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            insert_pos = min(new_pos, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != 0 or b != N-1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance score, then applies a novel local search combining adaptive segment reinsertion with path inversion and conditional node chain reversal, while ensuring feasibility through a hybrid of multi-objective aware edge swaps and probabilistic segment rotations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid multi-objective edge swap\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]) - \\\n                      (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[j]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%N]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]) - \\\n                      (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[j]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%N]])\n\n        if (cost_change1 + cost_change2) < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        pos = np.random.randint(0, N - k)\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos+k]] +\n                       distance_matrix_1[new_solution[pos+k-1], new_solution[pos]] -\n                       distance_matrix_1[new_solution[pos-1], new_solution[pos]] -\n                       distance_matrix_1[new_solution[pos+k-1], new_solution[pos+k]])\n\n        cost_change2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos+k]] +\n                       distance_matrix_2[new_solution[pos+k-1], new_solution[pos]] -\n                       distance_matrix_2[new_solution[pos-1], new_solution[pos]] -\n                       distance_matrix_2[new_solution[pos+k-1], new_solution[pos+k]])\n\n        if (cost_change1 + cost_change2) < 0:\n            segment = new_solution[pos:pos+k]\n            new_solution[pos:pos+k] = np.roll(segment, np.random.randint(1, k))\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.randint(0, N)\n        pos = np.random.randint(0, N-1)\n\n        if pos != node and pos != (node-1)%N:\n            # Calculate cost change for both objectives\n            cost_change1 = (distance_matrix_1[new_solution[pos-1], new_solution[node]] +\n                          distance_matrix_1[new_solution[node], new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n            cost_change2 = (distance_matrix_2[new_solution[pos-1], new_solution[node]] +\n                          distance_matrix_2[new_solution[node], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            if (cost_change1 + cost_change2) < 0:\n                node_val = new_solution[node]\n                new_solution = np.delete(new_solution, node)\n                new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            5.55593484622293,
            7.057815070680716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid multi-objective edge swap\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]) - \\\n                      (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[j]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%N]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]) - \\\n                      (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[j]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%N]])\n\n        if (cost_change1 + cost_change2) < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, min(5, N//2))\n        pos = np.random.randint(0, N - k)\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos+k]] +\n                       distance_matrix_1[new_solution[pos+k-1], new_solution[pos]] -\n                       distance_matrix_1[new_solution[pos-1], new_solution[pos]] -\n                       distance_matrix_1[new_solution[pos+k-1], new_solution[pos+k]])\n\n        cost_change2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos+k]] +\n                       distance_matrix_2[new_solution[pos+k-1], new_solution[pos]] -\n                       distance_matrix_2[new_solution[pos-1], new_solution[pos]] -\n                       distance_matrix_2[new_solution[pos+k-1], new_solution[pos+k]])\n\n        if (cost_change1 + cost_change2) < 0:\n            segment = new_solution[pos:pos+k]\n            new_solution[pos:pos+k] = np.roll(segment, np.random.randint(1, k))\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.4:\n        node = np.random.randint(0, N)\n        pos = np.random.randint(0, N-1)\n\n        if pos != node and pos != (node-1)%N:\n            # Calculate cost change for both objectives\n            cost_change1 = (distance_matrix_1[new_solution[pos-1], new_solution[node]] +\n                          distance_matrix_1[new_solution[node], new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n            cost_change2 = (distance_matrix_2[new_solution[pos-1], new_solution[node]] +\n                          distance_matrix_2[new_solution[node], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            if (cost_change1 + cost_change2) < 0:\n                node_val = new_solution[node]\n                new_solution = np.delete(new_solution, node)\n                new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score combining both objectives with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks, while also incorporating a novel \"node cluster relocation\" operator that moves entire clusters of nodes between segments to improve both objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.5 if std_dev[0] > std_dev[1] else 0.3\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+cluster_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - cluster_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic objective score that combines both objectives with adaptive weights, then applies a novel local search combining adaptive segment rotation, objective-aware node insertion, and conditional path inversion with probabilistic checks, while incorporating a novel \"node sequence reshuffling\" operator that reorders multiple nodes in a segment to improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.6 if std_dev[0] > std_dev[1] else 0.4\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        shuffled_segment = np.random.permutation(segment)\n        new_solution[:k] = shuffled_segment\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.7620681869823605,
            7.249693676184103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.6 if std_dev[0] > std_dev[1] else 0.4\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[a:b+1] = rotated_segment\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        segment = new_solution[:k]\n        shuffled_segment = np.random.permutation(segment)\n        new_solution[:k] = shuffled_segment\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominated_count[j] += 1\n    non_dominated_indices = np.where(dominated_count == 0)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.0419880191098585,
            6.507358237806283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominated_count[j] += 1\n    non_dominated_indices = np.where(dominated_count == 0)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{The new algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity, while also incorporating a novel segment swapping operator to further explore the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 3:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 0 and d - c > 0:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            8.028419538387485,
            8.801942885706527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.3 and N > 3:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        if b - a > 0 and d - c > 0:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware combined objective score, then applies a hybrid local search combining segment rotation, node insertion with path optimization, and probabilistic edge swapping to ensure feasibility and exploration of diverse regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.mean(np.abs(norm_objectives - np.mean(norm_objectives, axis=0)), axis=1)\n    combined_scores = 0.5 * norm_objectives[:, 0] + 0.5 * norm_objectives[:, 1] - 0.2 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:]])\n        if np.random.rand() < 0.2:\n            for i in range(1, N-1):\n                if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]) > \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]):\n                    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and j != (i+1)%N:\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.987837316444938,
            6.872057169545608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.mean(np.abs(norm_objectives - np.mean(norm_objectives, axis=0)), axis=1)\n    combined_scores = 0.5 * norm_objectives[:, 0] + 0.5 * norm_objectives[:, 1] - 0.2 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.3:\n        k = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, k)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:]])\n        if np.random.rand() < 0.2:\n            for i in range(1, N-1):\n                if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]) > \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]):\n                    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and j != (i+1)%N:\n            if np.random.rand() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    combined_scores = crowding_distances * 0.7 + (1 - np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 0] / (len(archive) - 1)) * 0.3\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.51753553312906,
            9.939705655873793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n    combined_scores = crowding_distances * 0.7 + (1 - np.argsort(np.argsort(objectives, axis=0), axis=0)[:, 0] / (len(archive) - 1)) * 0.3\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal, edge exchange, and probabilistic node insertion with feasibility checks to generate diverse and high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if sorted_objectives[j+1, i] != sorted_objectives[j-1, i]:\n                crowding_distances[sorted_order[j]] += (sorted_objectives[j+1, i] - sorted_objectives[j-1, i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            4.844656802225991,
            10.311051683429518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if sorted_objectives[j+1, i] != sorted_objectives[j-1, i]:\n                crowding_distances[sorted_order[j]] += (sorted_objectives[j+1, i] - sorted_objectives[j-1, i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i < N-1 and j > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic objective score combining both objectives with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks, while also incorporating a novel \"node cluster relocation\" operator that moves entire clusters of nodes between segments to improve both objectives simultaneously.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    weight1 = 0.5 if std_dev[0] > std_dev[1] else 0.3\n    weight2 = 1 - weight1\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+cluster_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - cluster_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance aware selection criterion, then applies a novel \"objective-balanced edge crossover\" operator that combines segments from two randomly selected solutions while preserving feasibility, and uses a dynamic objective-based node permutation strategy to further refine the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Objective-balanced edge crossover\n    if len(archive) > 1 and np.random.rand() < 0.6:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n        crossover_point = np.random.randint(1, N-1)\n        new_solution = np.concatenate([base_solution[:crossover_point], other_solution[crossover_point:]])\n\n        # Repair to ensure all nodes are visited exactly once\n        missing_nodes = set(range(N)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Dynamic objective-based node permutation\n    if np.random.rand() < 0.7:\n        obj_weights = objectives.std(axis=0)\n        obj_weights = obj_weights / obj_weights.sum()\n\n        for i in range(N):\n            if np.random.rand() < 0.3:\n                swap_candidates = []\n                for j in range(N):\n                    if i != j:\n                        # Calculate potential improvement in both objectives\n                        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]])\n\n                        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n                        improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2\n                        if improvement < 0:\n                            swap_candidates.append((j, improvement))\n\n                if swap_candidates:\n                    best_j, _ = min(swap_candidates, key=lambda x: x[1])\n                    new_solution[i], new_solution[best_j] = new_solution[best_j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.169637436724889,
            7.865362747418704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Objective-balanced edge crossover\n    if len(archive) > 1 and np.random.rand() < 0.6:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0].copy()\n        crossover_point = np.random.randint(1, N-1)\n        new_solution = np.concatenate([base_solution[:crossover_point], other_solution[crossover_point:]])\n\n        # Repair to ensure all nodes are visited exactly once\n        missing_nodes = set(range(N)) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Dynamic objective-based node permutation\n    if np.random.rand() < 0.7:\n        obj_weights = objectives.std(axis=0)\n        obj_weights = obj_weights / obj_weights.sum()\n\n        for i in range(N):\n            if np.random.rand() < 0.3:\n                swap_candidates = []\n                for j in range(N):\n                    if i != j:\n                        # Calculate potential improvement in both objectives\n                        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]])\n\n                        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_2[new_solution[i], new_solution[(i+1)%N]])\n\n                        improvement = obj_weights[0] * delta1 + obj_weights[1] * delta2\n                        if improvement < 0:\n                            swap_candidates.append((j, improvement))\n\n                if swap_candidates:\n                    best_j, _ = min(swap_candidates, key=lambda x: x[1])\n                    new_solution[i], new_solution[best_j] = new_solution[best_j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance-aware dominance score, then applies a hybrid local search combining adaptive segment relocation with objective-balanced path inversion and dynamic node chain reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[i] = (archive[i+1][1][0] - archive[i-1][1][0]) / (archive[-1][1][0] - archive[0][1][0]) + \\\n                     (archive[i+1][1][1] - archive[i-1][1][1]) / (archive[-1][1][1] - archive[0][1][1])\n\n    # Select solution with highest crowding distance (most in the middle of the Pareto front)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-balanced path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//3)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if (cost1 + cost2) / (cost1 * cost2) < 0:  # Balanced improvement\n            new_solution[:k] = inverted_path\n\n    # Dynamic node chain reversal\n    if np.random.rand() < 0.3:\n        chain_length = np.random.randint(2, min(5, N//4))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if (cost1 + cost2) < 0 and abs(cost1 - cost2) < max(cost1, cost2) * 0.2:  # Balanced and significant improvement\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n",
        "score": [
            8.492643237302138,
            8.36476935448707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[i] = (archive[i+1][1][0] - archive[i-1][1][0]) / (archive[-1][1][0] - archive[0][1][0]) + \\\n                     (archive[i+1][1][1] - archive[i-1][1][1]) / (archive[-1][1][1] - archive[0][1][1])\n\n    # Select solution with highest crowding distance (most in the middle of the Pareto front)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-balanced path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//3)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if (cost1 + cost2) / (cost1 * cost2) < 0:  # Balanced improvement\n            new_solution[:k] = inverted_path\n\n    # Dynamic node chain reversal\n    if np.random.rand() < 0.3:\n        chain_length = np.random.randint(2, min(5, N//4))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if (cost1 + cost2) < 0 and abs(cost1 - cost2) < max(cost1, cost2) * 0.2:  # Balanced and significant improvement\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{The new algorithm selects solutions from the archive based on a diversity-aware objective score that balances dominance and non-dominated rank, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity, while incorporating a new segment crossover operation to preserve structural properties.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            dominated = 0\n            for j in range(len(archive)):\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                    dominated += 1\n            ranks[i] = dominated\n        base_solution = archive[np.argmin(ranks)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.6 and N > 4:\n        split1 = np.random.randint(1, N-2)\n        split2 = np.random.randint(split1+1, N-1)\n        new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    return new_solution\n\n",
        "score": [
            6.7317773957275335,
            7.526008124624185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    if len(archive) > 1:\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            dominated = 0\n            for j in range(len(archive)):\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                    dominated += 1\n            ranks[i] = dominated\n        base_solution = archive[np.argmin(ranks)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    if np.random.rand() < 0.6 and N > 4:\n        split1 = np.random.randint(1, N-2)\n        split2 = np.random.randint(split1+1, N-1)\n        new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a Pareto-dominance aware score that prioritizes solutions with better objective ratios, then applies a hybrid local search combining adaptive segment rotation with objective-weighted node insertion and conditional path inversion to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0]/x[1][1] if x[1][1] != 0 else float('inf')))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Evaluate rotation based on weighted objectives\n        weight = np.random.uniform(0.3, 0.7)\n        original_cost = (weight * (distance_matrix_1[new_solution[a-1], segment[0]] +\n                                  distance_matrix_1[segment[-1], new_solution[(b+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[a-1], segment[0]] +\n                                     distance_matrix_2[segment[-1], new_solution[(b+1)%N]]))\n        rotated_cost = (weight * (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                                 distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                                    distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]]))\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-weighted node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate weighted cost difference\n            weight = np.random.uniform(0.4, 0.6)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                  distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] -\n                                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                  distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]))\n\n            if cost_diff < 0:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion with objective weights\n        weight = np.random.uniform(0.2, 0.8)\n        original_cost = (weight * (distance_matrix_1[new_solution[-1], path[0]] +\n                                  distance_matrix_1[path[-1], new_solution[k]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[-1], path[0]] +\n                                     distance_matrix_2[path[-1], new_solution[k]]))\n        inverted_cost = (weight * (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                                  distance_matrix_1[inverted_path[-1], new_solution[k]]) +\n                       (1-weight) * (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                                    distance_matrix_2[inverted_path[-1], new_solution[k]]))\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-based selection criterion, then applies a hybrid local search combining adaptive segment shuffling, objective-aware node swapping, and probabilistic path inversion with feasibility checks to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment shuffling\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.3, 0.7)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                                 distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                                     distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                                     distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]))\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n        new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            6.596817314476349,
            7.794354554399188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment shuffling\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            weight = np.random.uniform(0.3, 0.7)\n            cost_diff = (weight * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                 distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                                 distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                                 distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                                 distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]) +\n                        (1-weight) * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                     distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                                     distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                                     distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                                     distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                                     distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]))\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n        new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic crowding distance metric that balances both objectives, then applies a hybrid local search combining segment rotation, node swapping, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity while leveraging both distance matrices for improved neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a = np.random.randint(N)\n        shift = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, shift, axis=0)\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if np.random.rand() < 0.5:\n        u, v = np.random.choice(N, size=2, replace=False)\n        if u > v:\n            u, v = v, u\n        segment = new_solution[u:v+1]\n        if len(segment) > 2:\n            k = np.random.randint(1, len(segment)-1)\n            new_solution[u:v+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n",
        "score": [
            7.310039894217973,
            9.084408267476594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    base_solution = archive[np.argmax(crowding_dist)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a = np.random.randint(N)\n        shift = np.random.randint(1, N)\n        new_solution = np.roll(new_solution, shift, axis=0)\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if np.random.rand() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if np.random.rand() < 0.5:\n        u, v = np.random.choice(N, size=2, replace=False)\n        if u > v:\n            u, v = v, u\n        segment = new_solution[u:v+1]\n        if len(segment) > 2:\n            k = np.random.randint(1, len(segment)-1)\n            new_solution[u:v+1] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score that considers both objective values and solution structure, then applies a hybrid local search combining segment swapping, node insertion, and probabilistic edge flipping with adaptive checks to ensure feasibility and exploration of diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(norm_objectives, axis=1)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5 + 0.3 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    return new_solution\n\n",
        "score": [
            6.245625564899123,
            6.286135483196279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(norm_objectives, axis=1)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5 + 0.3 * diversity_scores\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b, c, d = sorted(np.random.choice(N, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    return new_solution\n\n"
    }
]