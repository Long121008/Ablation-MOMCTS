[
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance measure to promote diversity, then applies a hybrid local search combining node relocation and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding = [0] * len(archive)\n        for i in range(2):\n            sorted_idx = sorted(range(len(archive)), key=lambda x: archive[x][1][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (archive[sorted_idx[j+1]][1][i] - archive[sorted_idx[j-1]][1][i]) / (archive[sorted_idx[-1]][1][i] - archive[sorted_idx[0]][1][i])\n        base_idx = np.argmax(crowding)\n    else:\n        base_idx = 0\n    base_solution = archive[base_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: node relocation + edge reversal\n    if np.random.rand() < 0.7:  # 70% chance for relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for edge reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.398611415506409,
            5.191416454747967
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with alternating segment reversal and edge contraction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Alternating segment reversal\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with node reordering\n    if np.random.rand() < 0.5:\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            new_solution[i] = node_j\n            new_solution[j] = node_i\n\n    # Node reordering with alternating segments\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            6.325400618025214,
            5.7434767355675245
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, node chain insertion, and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node chain insertion\n    if np.random.rand() < 0.3:\n        chain_length = min(3, N // 2)\n        chain = np.random.choice(new_solution, size=chain_length, replace=False)\n        pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:]])\n        new_solution = np.unique(new_solution)\n\n    # Edge reversal with feasibility check\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j - i) > 1:\n            new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n",
        "score": [
            6.231663226219714,
            6.107997658428222
        ]
    }
]