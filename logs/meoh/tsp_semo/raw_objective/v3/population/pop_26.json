[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            10.362927120535325,
            4.36751843854373
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n",
        "score": [
            6.051948985144374,
            5.600676384129802
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.678733823516097,
            6.312686110122009
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score while applying a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.820911251229378,
            5.437982603815841
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n",
        "score": [
            4.60736924906,
            10.26400497372948
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    }
]