[
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.2639558858526865,
            6.456350947292165
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.446352880272228,
            6.4478337409255095
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and solution diversity, then applies a novel 3-opt-like local search with a guided diversification step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful modification\n\n    # Step 1: Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Step 2: Recombine segments in a novel way\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Guided diversification - swap nodes based on distance matrices\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    return new_order\n\n",
        "score": [
            6.638091370909896,
            6.868138406096367
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion with a distance-aware swap, prioritizing solutions with non-dominated objectives and leveraging both distance matrices to guide the search for improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: multi-segment inversion + distance-aware swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Multi-segment inversion\n    seg_length = max(2, n // 4)\n    start = random.randint(0, n - seg_length - 1)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Distance-aware swap\n    if n >= 4:\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.1184091247001025,
            6.7379645120966485
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining segment rotation and alternating path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    weighted_scores = np.array([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid local search: segment rotation + alternating path reversal\n    if n > 3:\n        # Segment rotation: move a segment to a different position\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Alternating path reversal: reverse every alternate segment\n        for i in range(2, n, 4):\n            if i + 1 < n:\n                new_solution[i:i+2] = new_solution[i:i+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.3523383024578175,
            8.976304681616655
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining adaptive segment relocation and partial tour reconstruction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    centroid = objectives.mean(axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential insertion points based on both objectives\n        insertion_scores = []\n        for i in range(n):\n            if i >= a and i <= b:\n                insertion_scores.append(-float('inf'))\n                continue\n\n            # Calculate cost for both objectives\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n            elif i == n-1:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n\n            # Score based on both objectives (weighted by segment length)\n            score = - (cost1 + cost2) / (b - a + 1)\n            insertion_scores.append(score)\n\n        # Select best insertion point\n        best_i = np.argmax(insertion_scores)\n        if best_i < a:\n            new_solution = np.concatenate([new_solution[:best_i+1], segment, new_solution[best_i+1:a], new_solution[b+1:]])\n        elif best_i > b:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:best_i+1], segment, new_solution[best_i+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Partial tour reconstruction: reverse segments with probability based on their length\n        for _ in range(min(3, n//2)):\n            c, d = sorted(random.sample(range(n), 2))\n            if random.random() < 0.5 * (d - c + 1) / n:\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.4454656218727635,
            7.410546466004641
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search combining node relocation and edge swapping to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance to select a solution in less explored regions\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives, axis=0)\n        crowding_distance = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            for j in range(1, len(archive)-1):\n                crowding_distance[sorted_indices[j, i]] += (objectives[sorted_indices[j+1, i], i] - objectives[sorted_indices[j-1, i], i]) / (objectives[sorted_indices[-1, i], i] - objectives[sorted_indices[0, i], i] + 1e-6)\n\n        selected_idx = np.argmax(crowding_distance)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: node relocation + edge swapping\n    if n > 3:\n        # Node relocation: move a random node to a new position\n        a, b = random.sample(range(1, n), 2)\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n        # Edge swapping: swap two random edges\n        c, d = sorted(random.sample(range(1, n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            8.081271322251432,
            8.389968258747013
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator combining edge swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate normalized objectives to select a solution with high potential\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        # Select a solution with high potential (high trade-off between objectives)\n        tradeoff = normalized[:, 0] * normalized[:, 1]\n        selected_idx = np.argmax(tradeoff)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge swapping + segment rotation\n    if n > 3:\n        # Select two distinct random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge swapping: swap two edges between i and j, and k and l\n        if i != k and j != l:\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        # Segment rotation: rotate a segment between two random positions\n        m, p = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[m:p+1]\n        rotation_point = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation_point:], segment[:rotation_point]])\n        new_solution[m:p+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            10.468177984765227,
            10.588042137223267
        ]
    }
]