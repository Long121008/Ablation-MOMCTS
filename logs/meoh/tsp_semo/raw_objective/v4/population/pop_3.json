[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search combining node relocation with a dynamic segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Determine insertion position based on both distance matrices\n        costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        # Insert at position that minimizes the combined cost\n        insert_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply dynamic segment inversion based on cost improvement\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost difference for inversion\n        prev_node = new_solution[start-1]\n        next_node = new_solution[end+1] if (end+1) < n else new_solution[0]\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.04906705731445,
            6.297187779186287
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a randomized edge-swap and segment-reversal hybrid operator to generate a neighbor solution while ensuring feasibility, and balances exploration and exploitation by leveraging both objective-specific distance matrices to guide the search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good trade-off between objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with objective guidance\n    if n > 3:\n        # Choose a segment to reverse based on high edge cost\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        # Decide reversal based on combined distance cost\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (permutation)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.696815469537818,
            6.918070498217975
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by evaluating the Pareto front dominance and applies a hybrid local search combining segment reversal, edge insertion, and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search: segment reversal + edge insertion + node swapping\n        # Select a random segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a randomly selected edge elsewhere\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Perform a node swap based on distance matrices\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, size=2, replace=False)\n            cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n            cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n            if cost_diff_1 < 0 or cost_diff_2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.067152390715623,
            6.669355048841335
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment insertion with a randomized edge reversal operator, guided by objective-specific distance matrices to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good trade-off between objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment insertion\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n        segment = new_solution[i:j+1]\n\n        # Find insertion point with minimum combined cost\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos >= i and pos <= j:\n                continue\n            cost = 0\n            if pos > 0:\n                cost += distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_2[new_solution[pos-1], segment[0]]\n            if pos < n - 1:\n                cost += distance_matrix_1[segment[-1], new_solution[pos+1]] + distance_matrix_2[segment[-1], new_solution[pos+1]]\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:best_pos+1], segment, new_solution[best_pos+1:]])\n\n    # Randomized edge reversal\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            6.242811150455532,
            7.085493655804008
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the Pareto dominance or crowding distance, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a randomly selected edge elsewhere\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.81732381730226,
            7.03853118445488
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines edge insertion, segment reversal, and adaptive k-opt moves to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we use a simple random selection with bias toward better objectives)\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_nodes = len(base_solution)\n    if n_nodes < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive k-opt move (k between 2 and 4)\n        k = random.randint(2, 4)\n        if k == 2:\n            # Edge insertion\n            i, j = random.sample(range(n_nodes), 2)\n            new_solution = np.roll(new_solution, -i)\n            new_solution[1] = new_solution[j]\n            new_solution = np.roll(new_solution, i)\n        elif k == 3:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 4-opt move (more complex)\n            a, b, c, d = sorted(random.sample(range(n_nodes), 4))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    return new_solution\n\n",
        "score": [
            6.468414571910298,
            7.394024026180258
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment rotation, adaptive node insertion, and guided edge swapping to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (biased toward better objectives and diverse solutions)\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    if n_nodes < 4:\n        # For small tours, perform a simple rotation\n        new_solution = np.roll(new_solution, 1)\n    else:\n        # Hybrid local search: segment rotation + adaptive node insertion + guided edge swapping\n        # Segment rotation\n        k = random.randint(2, min(5, n_nodes - 1))\n        rotation_point = random.randint(0, n_nodes - k)\n        new_solution[rotation_point:rotation_point+k] = np.roll(new_solution[rotation_point:rotation_point+k], 1)\n\n        # Adaptive node insertion\n        i, j = random.sample(range(n_nodes), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Guided edge swapping based on distance matrices\n        for _ in range(2):\n            i, j = random.sample(range(n_nodes), 2)\n            cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n_nodes]]) - \\\n                         (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]])\n            cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n_nodes]]) - \\\n                         (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]])\n            if (cost_diff_1 < 0 and cost_diff_2 < 0) or (random.random() < 0.3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n_nodes:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the hybrid operation fails\n        new_solution = np.roll(new_solution, 1)\n\n    return new_solution\n\n",
        "score": [
            7.147564083304377,
            6.991080797357006
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by evaluating both objective values and spatial diversity, then applies a hybrid local search combining adaptive segment rotation, node reinsertion with spatial awareness, and conditional edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objective values and diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search: adaptive segment rotation + node reinsertion + conditional edge swapping\n        # Select a random segment to rotate\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Reinsert a randomly selected node based on spatial distance\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n\n        # Calculate spatial distances to determine insertion position\n        if insert_pos > 0:\n            prev_node = new_solution[insert_pos-1]\n            next_node = new_solution[insert_pos] if insert_pos < len(new_solution) else new_solution[0]\n            dist1 = np.sqrt((instance[node, 0] - instance[prev_node, 0])**2 + (instance[node, 1] - instance[prev_node, 1])**2 +\n                           (instance[node, 2] - instance[prev_node, 2])**2 + (instance[node, 3] - instance[prev_node, 3])**2)\n            dist2 = np.sqrt((instance[node, 0] - instance[next_node, 0])**2 + (instance[node, 1] - instance[next_node, 1])**2 +\n                           (instance[node, 2] - instance[next_node, 2])**2 + (instance[node, 3] - instance[next_node, 3])**2)\n            if dist1 < dist2:\n                insert_pos = insert_pos - 1 if insert_pos > 0 else len(new_solution)\n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Conditional edge swapping based on both distance matrices\n        if np.random.rand() < 0.3:\n            i, j = np.random.choice(n, size=2, replace=False)\n            cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n            cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n            if (cost_diff_1 < 0 and cost_diff_2 < 0) or (np.random.rand() < 0.2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the hybrid operation fails\n        start = np.random.randint(0, n - 1)\n        end = np.random.randint(start + 1, n)\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    return new_solution\n\n",
        "score": [
            7.237405912401373,
            6.979972869091835
        ]
    },
    {
        "algorithm": "{A hybrid local search heuristic that selects a solution from the archive based on Pareto front dominance and applies a novel three-phase perturbation: first a segment reversal, then a guided insertion based on objective improvement, followed by a multi-edge swap to refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution on the Pareto front if possible\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Identify Pareto front solutions\n        pareto_indices = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                              (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_indices.append(i)\n        if pareto_indices:\n            selected_idx = np.random.choice(pareto_indices)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Phase 2: Guided insertion\n    if n > 4:\n        # Find the worst node to relocate\n        worst_node = -1\n        worst_cost = 0\n        for i in range(n):\n            prev = (i - 1) % n\n            next_node = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[prev], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[next_node]]\n            cost2 = distance_matrix_2[new_solution[prev], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[next_node]]\n            total_cost = cost1 + cost2\n            if total_cost > worst_cost:\n                worst_cost = total_cost\n                worst_node = i\n\n        if worst_node != -1:\n            # Find best insertion point\n            best_improvement = 0\n            best_insert = -1\n            node = new_solution[worst_node]\n\n            for i in range(n):\n                if i == worst_node or i == (worst_node - 1) % n:\n                    continue\n                prev = (i - 1) % n\n                next_node = (i + 1) % n\n\n                old_cost1 = distance_matrix_1[new_solution[prev], node] + distance_matrix_1[node, new_solution[next_node]]\n                new_cost1 = distance_matrix_1[new_solution[prev], new_solution[next_node]]\n                improvement1 = old_cost1 - new_cost1\n\n                old_cost2 = distance_matrix_2[new_solution[prev], node] + distance_matrix_2[node, new_solution[next_node]]\n                new_cost2 = distance_matrix_2[new_solution[prev], new_solution[next_node]]\n                improvement2 = old_cost2 - new_cost2\n\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_insert = i\n\n            if best_insert != -1:\n                # Perform insertion\n                node = new_solution[worst_node]\n                new_solution = np.concatenate([\n                    new_solution[:worst_node],\n                    new_solution[worst_node + 1:]\n                ])\n                new_solution = np.insert(new_solution, best_insert, node)\n\n    # Phase 3: Multi-edge swap\n    if n > 5:\n        # Select 4 random edges\n        edges = np.random.choice(n, size=4, replace=False)\n        edges = sorted(edges)\n\n        # Perform a 4-opt style swap\n        a, b, c, d = edges\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            segment1,\n            segment3,\n            new_solution[d:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            7.217843890517788,
            7.078018935107902
        ]
    }
]