[
    {
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by evaluating the Pareto front dominance and applies a hybrid local search combining segment reversal, edge insertion, and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search: segment reversal + edge insertion + node swapping\n        # Select a random segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a randomly selected edge elsewhere\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Perform a node swap based on distance matrices\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, size=2, replace=False)\n            cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n            cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n            if cost_diff_1 < 0 or cost_diff_2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.067152390715623,
            6.669355048841335
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a randomized edge-swap and segment-reversal hybrid operator to generate a neighbor solution while ensuring feasibility, and balances exploration and exploitation by leveraging both objective-specific distance matrices to guide the search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good trade-off between objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with objective guidance\n    if n > 3:\n        # Choose a segment to reverse based on high edge cost\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        # Decide reversal based on combined distance cost\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (permutation)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.696815469537818,
            6.918070498217975
        ]
    },
    {
        "algorithm": "{The heuristic function intelligently selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines edge insertion, segment reversal, and adaptive k-opt moves to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we use a simple random selection with bias toward better objectives)\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_nodes = len(base_solution)\n    if n_nodes < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive k-opt move (k between 2 and 4)\n        k = random.randint(2, 4)\n        if k == 2:\n            # Edge insertion\n            i, j = random.sample(range(n_nodes), 2)\n            new_solution = np.roll(new_solution, -i)\n            new_solution[1] = new_solution[j]\n            new_solution = np.roll(new_solution, i)\n        elif k == 3:\n            # Segment reversal\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 4-opt move (more complex)\n            a, b, c, d = sorted(random.sample(range(n_nodes), 4))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    return new_solution\n\n",
        "score": [
            6.468414571910298,
            7.394024026180258
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the Pareto dominance or crowding distance, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a randomly selected edge elsewhere\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.81732381730226,
            7.03853118445488
        ]
    },
    {
        "algorithm": "{A hybrid local search heuristic that selects a solution from the archive based on Pareto front dominance and applies a novel three-phase perturbation: first a segment reversal, then a guided insertion based on objective improvement, followed by a multi-edge swap to refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution on the Pareto front if possible\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Identify Pareto front solutions\n        pareto_indices = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                              (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_indices.append(i)\n        if pareto_indices:\n            selected_idx = np.random.choice(pareto_indices)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Phase 2: Guided insertion\n    if n > 4:\n        # Find the worst node to relocate\n        worst_node = -1\n        worst_cost = 0\n        for i in range(n):\n            prev = (i - 1) % n\n            next_node = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[prev], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[next_node]]\n            cost2 = distance_matrix_2[new_solution[prev], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[next_node]]\n            total_cost = cost1 + cost2\n            if total_cost > worst_cost:\n                worst_cost = total_cost\n                worst_node = i\n\n        if worst_node != -1:\n            # Find best insertion point\n            best_improvement = 0\n            best_insert = -1\n            node = new_solution[worst_node]\n\n            for i in range(n):\n                if i == worst_node or i == (worst_node - 1) % n:\n                    continue\n                prev = (i - 1) % n\n                next_node = (i + 1) % n\n\n                old_cost1 = distance_matrix_1[new_solution[prev], node] + distance_matrix_1[node, new_solution[next_node]]\n                new_cost1 = distance_matrix_1[new_solution[prev], new_solution[next_node]]\n                improvement1 = old_cost1 - new_cost1\n\n                old_cost2 = distance_matrix_2[new_solution[prev], node] + distance_matrix_2[node, new_solution[next_node]]\n                new_cost2 = distance_matrix_2[new_solution[prev], new_solution[next_node]]\n                improvement2 = old_cost2 - new_cost2\n\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_insert = i\n\n            if best_insert != -1:\n                # Perform insertion\n                node = new_solution[worst_node]\n                new_solution = np.concatenate([\n                    new_solution[:worst_node],\n                    new_solution[worst_node + 1:]\n                ])\n                new_solution = np.insert(new_solution, best_insert, node)\n\n    # Phase 3: Multi-edge swap\n    if n > 5:\n        # Select 4 random edges\n        edges = np.random.choice(n, size=4, replace=False)\n        edges = sorted(edges)\n\n        # Perform a 4-opt style swap\n        a, b, c, d = edges\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            segment1,\n            segment3,\n            new_solution[d:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            7.217843890517788,
            7.078018935107902
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by prioritizing those with better trade-offs between objectives, then applies a novel local search combining segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (better trade-off between objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Novel local search: segment rotation and edge swapping\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n\n        # Rotate the segment by a random amount\n        rotate_amount = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotate_amount)\n\n        new_solution[start:end+1] = segment\n\n        # Swap two edges\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.278009110432225,
            7.116657268821479
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search combining segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to rotate\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Swap two edges to improve connectivity\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.365298164604699,
            7.214930753570508
        ]
    },
    {
        "algorithm": "{An innovative local search heuristic that combines adaptive segment inversion with objective-aware edge reinsertion, selecting solutions with high objective diversity and applying a two-stage perturbation that first disrupts the tour structure based on both objectives' characteristics and then refines it using a dynamic insertion strategy guided by Pareto-optimal edge replacements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2 / (obj_range + 1e-10), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment inversion based on objective weights\n    if n > 3:\n        # Calculate objective weights based on diversity\n        obj_weights = obj_range / (np.sum(obj_range) + 1e-10)\n        # Select segment length based on weights\n        segment_length = max(2, int(np.random.normal(loc=obj_weights[0]*3 + obj_weights[1]*2, scale=1)))\n        segment_length = min(segment_length, n-1)\n\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert segment with probability based on objective weights\n        if np.random.rand() < obj_weights[0]:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Dynamic edge reinsertion guided by Pareto front\n    if n > 4:\n        # Find edges that are Pareto-dominated in both objectives\n        dominated_edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            dominated = True\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                l = (k + 1) % n\n                other_cost1 = distance_matrix_1[new_solution[k], new_solution[l]]\n                other_cost2 = distance_matrix_2[new_solution[k], new_solution[l]]\n                if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                    dominated = False\n                    break\n            if dominated:\n                dominated_edges.append((i, j))\n\n        if dominated_edges:\n            # Select a dominated edge to remove\n            edge_idx = np.random.choice(len(dominated_edges))\n            i, j = dominated_edges[edge_idx]\n            node = new_solution[j]\n\n            # Find best insertion point based on both objectives\n            best_pos = -1\n            best_score = float('inf')\n            for pos in range(n-1):\n                if pos == i or pos == j:\n                    continue\n                # Calculate cost for both objectives\n                cost1 = (distance_matrix_1[new_solution[pos], node] +\n                        distance_matrix_1[node, new_solution[(pos+1)%n]] -\n                        distance_matrix_1[new_solution[pos], new_solution[(pos+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[pos], node] +\n                        distance_matrix_2[node, new_solution[(pos+1)%n]] -\n                        distance_matrix_2[new_solution[pos], new_solution[(pos+1)%n]])\n                # Use weighted sum of objectives\n                score = obj_weights[0] * cost1 + obj_weights[1] * cost2\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Perform the insertion\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:j],\n                    new_solution[j+1:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            8.207321782463016,
            7.853266020815724
        ]
    },
    {
        "algorithm": "{A hybrid local search heuristic that intelligently selects a solution from the archive based on objective diversity and applies a novel three-phase perturbation: first, a multi-segment reversal operation guided by Pareto dominance, followed by a cross-space edge swap, and finally a segment insertion refinement step that optimizes the tour structure while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Calculate the spread of objectives\n        obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select a solution with high diversity\n        diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2 / (obj_range + 1e-10), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: Multi-segment reversal operation\n    n = len(new_solution)\n    if n > 3:\n        # Select 3 random segments\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        # Reverse each segment\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Phase 2: Cross-space edge swap\n    if n > 2:\n        # Find edges with high cost in both spaces\n        worst_edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if cost1 > np.mean(distance_matrix_1) and cost2 > np.mean(distance_matrix_2):\n                worst_edges.append(i)\n\n        if worst_edges:\n            # Select a random worst edge\n            edge = np.random.choice(worst_edges)\n            # Find the best edge to swap with in the other space\n            best_swap = -1\n            best_improvement = 0\n            for i in range(n):\n                j = (i + 1) % n\n                if i == edge or j == edge or i == (edge + 1) % n or j == (edge + 1) % n:\n                    continue\n                # Calculate improvement if we swap the edges\n                cost1_old = distance_matrix_1[new_solution[edge], new_solution[(edge + 1) % n]] + distance_matrix_1[new_solution[i], new_solution[j]]\n                cost2_old = distance_matrix_2[new_solution[edge], new_solution[(edge + 1) % n]] + distance_matrix_2[new_solution[i], new_solution[j]]\n                cost1_new = distance_matrix_1[new_solution[edge], new_solution[i]] + distance_matrix_1[new_solution[(edge + 1) % n], new_solution[j]]\n                cost2_new = distance_matrix_2[new_solution[edge], new_solution[i]] + distance_matrix_2[new_solution[(edge + 1) % n], new_solution[j]]\n                improvement = (cost1_old + cost2_old) - (cost1_new + cost2_new)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = i\n\n            if best_swap != -1:\n                # Perform the swap\n                i, j = best_swap, (best_swap + 1) % n\n                a, b = edge, (edge + 1) % n\n                if a > b:\n                    a, b = b, a\n                if i > j:\n                    i, j = j, i\n                # Reconstruct the solution\n                if a < i and b < j:\n                    new_solution = np.concatenate([\n                        new_solution[:a],\n                        new_solution[i:i+1],\n                        new_solution[a:i],\n                        new_solution[b:j],\n                        new_solution[b:b+1],\n                        new_solution[j:]\n                    ])\n                elif a < i and b >= j:\n                    new_solution = np.concatenate([\n                        new_solution[:a],\n                        new_solution[i:i+1],\n                        new_solution[a:i],\n                        new_solution[j:b],\n                        new_solution[b:b+1],\n                        new_solution[i+1:j],\n                        new_solution[b+1:]\n                    ])\n\n    # Phase 3: Segment insertion refinement\n    if n > 4:\n        # Select a random segment of length 3\n        start = np.random.randint(0, n - 3)\n        segment = new_solution[start:start+3]\n        # Remove the segment from the solution\n        temp_solution = np.concatenate([new_solution[:start], new_solution[start+3:]])\n        # Find the best insertion point for the segment\n        best_insert = -1\n        best_improvement = 0\n        for i in range(len(temp_solution)):\n            # Try inserting the segment at position i\n            new_cost1 = (distance_matrix_1[temp_solution[(i-1)%len(temp_solution)], segment[0]] +\n                        distance_matrix_1[segment[2], temp_solution[i]] -\n                        distance_matrix_1[temp_solution[(i-1)%len(temp_solution)], temp_solution[i]])\n            new_cost2 = (distance_matrix_2[temp_solution[(i-1)%len(temp_solution)], segment[0]] +\n                        distance_matrix_2[segment[2], temp_solution[i]] -\n                        distance_matrix_2[temp_solution[(i-1)%len(temp_solution)], temp_solution[i]])\n            improvement = - (new_cost1 + new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = i\n\n        if best_insert != -1:\n            # Insert the segment at the best position\n            new_solution = np.concatenate([\n                temp_solution[:best_insert],\n                segment,\n                temp_solution[best_insert:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            8.096405988488776,
            8.152147944608132
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive with the highest combined objective improvement potential, then applies a hybrid 3-opt and edge insertion local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective improvement potential\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with less than 4 nodes\n\n    # Hybrid local search: 3-opt + edge insertion\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select 4 distinct indices\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n        # Apply 3-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n        temp_solution[c:d+1] = np.flip(temp_solution[c:d+1])\n\n        # Check feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n        # Edge insertion\n        if np.random.rand() < 0.5:  # 50% chance to try edge insertion\n            u, v = sorted(np.random.choice(n, 2, replace=False))\n            if u != v:\n                # Remove edge u-v and insert in a different position\n                mask = np.ones(n, dtype=bool)\n                mask[[u, v]] = False\n                remaining = new_solution[mask]\n                insert_pos = np.random.randint(0, n-1)\n                temp_solution = np.concatenate([\n                    remaining[:insert_pos],\n                    new_solution[[u, v]],\n                    remaining[insert_pos:]\n                ])\n                if len(np.unique(temp_solution)) == n:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            8.462848817510269,
            8.93720651074241
        ]
    }
]