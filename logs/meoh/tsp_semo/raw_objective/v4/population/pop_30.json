[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a nonlinear weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (nonlinear weighted combination)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1)**0.7 + (obj[1]/max_obj2)**0.3 for _, obj in archive]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.3, 0.5, 0.2])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.55618061491404,
            8.180267322967786
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel local search combining segment transposition, adaptive edge flipping, and node reinsertion with hierarchical probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure diversity\n    weights = [0.3, 0.7]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure diversity (measure of tour variation)\n        n = len(sol)\n        diversity = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += (distance_matrix_1[prev, curr] * distance_matrix_2[curr, next_node] +\n                         distance_matrix_2[prev, curr] * distance_matrix_1[curr, next_node])\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.15 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hierarchical operation selection\n        if np.random.random() < 0.5:\n            # Segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n\n            temp = new_solution.copy()\n            temp[start1:start1+seg_length] = seg2\n            temp[start2:start2+seg_length] = seg1\n\n            # Check if transposition is valid\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n        else:\n            # Adaptive edge flipping with node reinsertion\n            if np.random.random() < 0.7:\n                # Edge flipping\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n\n                if len(np.unique(temp)) == n:\n                    new_solution = temp\n            else:\n                # Node reinsertion with position selection\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n\n                temp_sol = np.delete(new_solution, i)\n\n                # Select position based on both objectives\n                candidates = []\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, cost1, cost2))\n\n                if candidates:\n                    best_pos, _, _ = min(candidates, key=lambda x: weights[0]*x[1] + weights[1]*x[2])\n                    new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.575953962019064,
            4.681209405844362
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities, while incorporating a novel structure-preserving mutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure entropy\n    weights = [0.4, 0.6]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure entropy (measure of tour randomness)\n        n = len(sol)\n        entropy = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            # Calculate local structure diversity\n            diversity = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                        distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 4\n            entropy += diversity\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.2 * entropy\n        scores.append(score)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'structure_preserve'], p=[0.25, 0.25, 0.25, 0.25])\n\n        if operation == 'reversal':\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # structure_preserve operation\n            # Identify a segment that maintains good structure\n            segment_length = min(5, n//2)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Find the best position to reinsert this segment\n            best_pos = start\n            best_score = float('inf')\n            for pos in range(n - segment_length):\n                if pos >= start and pos <= end:\n                    continue\n                # Temporarily reinsert segment\n                temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                # Calculate score for this configuration\n                score = 0\n                for i in range(n):\n                    prev = temp_sol[i-1]\n                    curr = temp_sol[i]\n                    next_node = temp_sol[(i+1)%n]\n                    score += (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                             distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            # Apply the best reinsertion\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.199432988911294,
            5.604942752052077
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment shifting, adaptive node relocation, and multi-segment crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.5, 0.5]\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['shift', 'relocate', 'crossover'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'shift':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                shift = np.random.randint(1, min(5, j-i))\n                temp_sol = new_solution.copy()\n                segment = temp_sol[i:j]\n                temp_sol[i:j] = np.roll(segment, shift)\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, shift, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, best_shift, _, _ = min(candidates, key=lambda x: weights[0]*x[3] + weights[1]*x[4])\n                segment = new_solution[best_i:best_j]\n                new_solution[best_i:best_j] = np.roll(segment, best_shift)\n\n        elif operation == 'relocate':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)//2, 3*len(temp_sol)//4, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                k = np.random.randint(2, n//2)\n                i = np.random.randint(0, n - 2*k)\n                j = np.random.randint(i + k, n - k)\n                temp_sol = np.concatenate([new_solution[:i], new_solution[j:j+k], new_solution[i+k:j], new_solution[i:i+k], new_solution[j+k:]])\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, k, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, best_k, _, _ = min(candidates, key=lambda x: weights[0]*x[3] + weights[1]*x[4])\n                new_solution = np.concatenate([new_solution[:best_i], new_solution[best_j:best_j+best_k], new_solution[best_i+best_k:best_j], new_solution[best_i:best_i+best_k], new_solution[best_j+best_k:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.903988208882544,
            5.6635532092959355
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a combination of objective values and edge entropy metrics, then applies a hybrid local search combining probabilistic node relocation, adaptive segment rotation, and dynamic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values and edge entropy\n    weights = [0.5, 0.5]\n    scores = []\n    for sol, obj in archive:\n        edge_entropy = 0\n        n = len(sol)\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            edge_entropy += (distance_matrix_1[curr, prev] + distance_matrix_2[curr, prev] +\n                           distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n        scores.append(weights[0] * (obj[0] + obj[1]) + weights[1] * edge_entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocate', 'rotate', 'flip'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocate':\n            # Probabilistic node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'rotate':\n            # Adaptive segment rotation\n            candidates = []\n            for _ in range(5):\n                k = np.random.randint(2, min(5, n//2))\n                start = np.random.randint(0, n - k)\n                temp_sol = new_solution.copy()\n                segment = temp_sol[start:start+k]\n                temp_sol[start:start+k] = np.roll(segment, np.random.randint(1, k))\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((start, k, cost1, cost2))\n\n            if candidates:\n                best_start, best_k, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                segment = new_solution[best_start:best_start+best_k]\n                new_solution[best_start:best_start+best_k] = np.roll(segment, np.random.randint(1, best_k))\n\n        else:\n            # Dynamic edge flipping\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                if np.random.random() < 0.7:\n                    # With 70% probability, also reverse the segment between them\n                    if i > j:\n                        i, j = j, i\n                    temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n                if np.random.random() < 0.7:\n                    if best_i > best_j:\n                        best_i, best_j = best_j, best_i\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.159632793023187,
            5.606508960600376
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, adaptive edge swapping, and multi-point insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on combined objectives and diversity\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'swap', 'multi_insert'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal with adaptive selection\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swap':\n            # Adaptive edge swapping\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Multi-point insertion\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.5174918438430645,
            5.283765169936114
        ]
    }
]