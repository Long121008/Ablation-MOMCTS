[
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric that balances objective values and solution structure, then applies a hybrid local search combining adaptive segment rotations, probabilistic edge insertions, and guided node relocations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware metric\n    diversity_scores = []\n    for sol, obj in archive:\n        obj_score = 0.4 * obj[0] + 0.6 * obj[1]\n        structure_score = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        diversity_score = obj_score + 0.3 * structure_score\n        diversity_scores.append(diversity_score)\n\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['rotate', 'insert', 'relocate'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'rotate':\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotation = np.random.randint(1, k)\n            rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+k] = rotated\n\n        elif operation == 'insert':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                node = new_solution[i]\n                new_pos = j\n                cost1_diff = (distance_matrix_1[new_solution[i-1], new_solution[i+1]] -\n                             distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                             distance_matrix_1[new_solution[i], new_solution[i+1]]) + \\\n                            (distance_matrix_1[new_solution[new_pos-1], node] +\n                             distance_matrix_1[node, new_solution[new_pos]]) - \\\n                            (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] if new_pos != 0 else 0)\n                cost2_diff = (distance_matrix_2[new_solution[i-1], new_solution[i+1]] -\n                             distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                             distance_matrix_2[new_solution[i], new_solution[i+1]]) + \\\n                            (distance_matrix_2[new_solution[new_pos-1], node] +\n                             distance_matrix_2[node, new_solution[new_pos]]) - \\\n                            (distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] if new_pos != 0 else 0)\n                candidates.append((i, new_pos, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            node = new_solution[best_i]\n            new_solution = np.delete(new_solution, best_i)\n            new_solution = np.insert(new_solution, best_j, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.120286158108402,
            5.725671807240364
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and diversity)\n    weights = [0.5, 0.5]\n    scores = []\n    for sol, obj in archive:\n        diversity = len(set(sol)) / len(sol)\n        score = sum(w * o for w, o in zip(weights, obj)) / (1 + diversity)\n        scores.append(score)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.3, 0.4])\n\n        if operation == 'reversal':\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.089845562962776,
            5.747459699021897
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection metric, then applies a hybrid local search combining adaptive edge swapping, probabilistic path reversal, and dynamic segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity and objective metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.5 * obj[0] + 0.5 * obj[1]\n        diversity_score = np.sum([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.3 * diversity_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'reverse', 'rotate'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'swap':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'reverse':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n        else:\n            k = np.random.randint(1, min(3, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            new_pos = np.random.randint(0, n - k)\n            while abs(new_pos - start) < k:\n                new_pos = np.random.randint(0, n - k)\n            new_solution = np.delete(new_solution, np.s_[start:start+k])\n            new_solution = np.insert(new_solution, new_pos, segment)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.363784820998689,
            5.553749717697308
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment inversion, adaptive edge swapping, and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple inversion\n        new_solution = new_solution[::-1]\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swap', 'relocation'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swap':\n            # Adaptive edge swapping\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Adaptive node relocation\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.641322728268499,
            4.28498814765062
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective values and solution quality, then applies a hybrid local search combining adaptive segment swapping, dynamic node relocation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.3 * obj[0] + 0.7 * obj[1]\n        quality_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.5 * quality_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'relocate', 'invert'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'swap':\n            k = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - k)\n            start2 = np.random.randint(0, n - k)\n            while abs(start1 - start2) < k:\n                start2 = np.random.randint(0, n - k)\n            segment1 = new_solution[start1:start1+k]\n            segment2 = new_solution[start2:start2+k]\n            new_solution[start1:start1+k] = segment2\n            new_solution[start2:start2+k] = segment1\n\n        elif operation == 'relocate':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                segment = new_solution[i:j+1]\n                inverted = segment[::-1]\n                cost1_diff = (sum(distance_matrix_1[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_1[new_solution[i-1], inverted[0]] +\n                             distance_matrix_1[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_1[new_solution[i-1], segment[0]] +\n                             distance_matrix_1[segment[-1], new_solution[j]])\n                cost2_diff = (sum(distance_matrix_2[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_2[new_solution[i-1], inverted[0]] +\n                             distance_matrix_2[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_2[new_solution[i-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[j]])\n                candidates.append((i, j, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            segment = new_solution[best_i:best_j+1]\n            new_solution[best_i:best_j+1] = segment[::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.196582362480023,
            5.081888973265188
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    }
]