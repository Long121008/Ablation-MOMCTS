[
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel cross-space segment inversion with a dynamic node clustering strategy, using multi-objective aware selection and adaptive segment reordering to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_diverse_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_diverse_solution(archive)\n    new_solution = base_solution.copy()\n\n    def cross_space_segment_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([solution[:a], segment[::-1], solution[b:]])\n            else:\n                new_tour = np.concatenate([solution[:a], segment, solution[b:]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = cross_space_segment_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.199415122090953,
            5.460942632339946
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism, then applies a novel hybrid local search combining multi-segment inversion with adaptive edge swapping that considers both objective spaces to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def diversity_based_selection(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = diversity_based_selection(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            if random.random() < 0.7:\n                # Multi-segment inversion\n                segments = random.randint(2, 4)\n                points = sorted(random.sample(range(n), segments))\n                temp_solution = solution.copy()\n                for i in range(len(points)-1):\n                    temp_solution[points[i]:points[i+1]] = temp_solution[points[i]:points[i+1]][::-1]\n            else:\n                # Adaptive edge swapping\n                i, j = random.sample(range(n), 2)\n                temp_solution = solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if (cost1 <= best_cost1 and cost2 <= best_cost2 and (cost1 < best_cost1 or cost2 < best_cost2)) or \\\n               (random.random() < 0.2):\n                best_solution = temp_solution.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.8020434904813545,
            5.8343837297634344
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search operator that combines adaptive node insertion with constrained edge reversal, using a multi-objective evaluation framework that dynamically balances exploration and exploitation while maintaining feasibility through careful path validation and segment merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and improvement potential\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n\n    # Calculate diversity score\n    diversity_scores = np.abs(norm_obj1 - norm_obj2)\n    improvement_scores = 1 - (norm_obj1 + norm_obj2) / 2\n\n    # Combine scores with dynamic weights\n    alpha = 0.7 if np.mean(diversity_scores) > 0.5 else 0.3\n    combined_scores = alpha * diversity_scores + (1 - alpha) * improvement_scores\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive node insertion with constrained edge reversal\n        k = min(3, n // 3)\n        for _ in range(k):\n            # Select a random segment\n            seg_start = np.random.randint(0, n - 2)\n            seg_length = np.random.randint(2, min(4, n - seg_start))\n            segment = new_solution[seg_start:seg_start+seg_length]\n\n            # Remove the segment\n            temp_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n            # Evaluate insertion points\n            insertion_costs = []\n            for i in range(len(temp_solution)):\n                prev_node = temp_solution[i-1]\n                next_node = temp_solution[i % len(temp_solution)]\n\n                # Original cost\n                original_cost1 = distance_matrix_1[prev_node, next_node]\n                original_cost2 = distance_matrix_2[prev_node, next_node]\n\n                # New cost if segment is inserted here\n                new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                            distance_matrix_1[segment[-1], next_node] -\n                            original_cost1)\n                new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                            distance_matrix_2[segment[-1], next_node] -\n                            original_cost2)\n\n                # Evaluate both objectives\n                insertion_costs.append(alpha * new_cost1 + (1 - alpha) * new_cost2)\n\n            # Insert at best position\n            best_pos = np.argmin(insertion_costs)\n            temp_solution = np.insert(temp_solution, best_pos, segment)\n\n            # Apply constrained edge reversal\n            if np.random.random() < 0.4:\n                rev_start = np.random.randint(0, len(temp_solution) - 2)\n                rev_end = np.random.randint(rev_start + 2, len(temp_solution))\n\n                # Check if reversal improves both objectives\n                original_cost1 = (distance_matrix_1[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_1[temp_solution[rev_end-1], temp_solution[rev_end]])\n                original_cost2 = (distance_matrix_2[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_2[temp_solution[rev_end-1], temp_solution[rev_end]])\n\n                reversed_segment = temp_solution[rev_start:rev_end][::-1]\n                new_cost1 = (distance_matrix_1[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], temp_solution[rev_end]])\n                new_cost2 = (distance_matrix_2[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], temp_solution[rev_end]])\n\n                if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.05) or \\\n                   (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.05):\n                    temp_solution[rev_start:rev_end] = reversed_segment\n\n            # Update solution if better\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.5081194483044555,
            8.949465568077065
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic segment reordering strategy, using multi-objective aware selection with a different scoring function and adaptive segment flipping to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])\n        selected_idx = random.randint(0, min(5, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_reordering(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment3, segment2, segment4])\n            else:\n                new_tour = np.concatenate([segment4, segment2, segment3, segment1[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_reordering(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.924558498989931,
            5.108384936542805
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of Pareto dominance and adaptive segment swapping, then applies a novel dynamic segment relocation strategy that combines edge flipping with instance-aware node insertion, ensuring feasibility through careful boundary checks and cost evaluations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_relocation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n            remaining = np.concatenate([solution[:a], solution[b:]])\n\n            if len(segment) > 1 and len(remaining) > 1:\n                insert_pos = random.randint(0, len(remaining))\n                if insert_pos == 0:\n                    new_tour = np.concatenate([segment[::-1], remaining])\n                elif insert_pos == len(remaining):\n                    new_tour = np.concatenate([remaining, segment[::-1]])\n                else:\n                    new_tour = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n                cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1) or (cost2 < best_cost2):\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_relocation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.19581133746161,
            5.783815621343472
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel cross-space segment inversion with a dynamic node clustering strategy, using multi-objective aware selection and adaptive segment reordering to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_diverse_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_diverse_solution(archive)\n    new_solution = base_solution.copy()\n\n    def cross_space_segment_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([solution[:a], segment[::-1], solution[b:]])\n            else:\n                new_tour = np.concatenate([solution[:a], segment, solution[b:]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = cross_space_segment_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.199415122090953,
            5.460942632339946
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic segment reordering strategy, using multi-objective aware selection with a different scoring function and adaptive segment flipping to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])\n        selected_idx = random.randint(0, min(5, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_reordering(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment3, segment2, segment4])\n            else:\n                new_tour = np.concatenate([segment4, segment2, segment3, segment1[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_reordering(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.924558498989931,
            5.108384936542805
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search operator that combines adaptive node insertion with constrained edge reversal, using a multi-objective evaluation framework that dynamically balances exploration and exploitation while maintaining feasibility through careful path validation and segment merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and improvement potential\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n\n    # Calculate diversity score\n    diversity_scores = np.abs(norm_obj1 - norm_obj2)\n    improvement_scores = 1 - (norm_obj1 + norm_obj2) / 2\n\n    # Combine scores with dynamic weights\n    alpha = 0.7 if np.mean(diversity_scores) > 0.5 else 0.3\n    combined_scores = alpha * diversity_scores + (1 - alpha) * improvement_scores\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive node insertion with constrained edge reversal\n        k = min(3, n // 3)\n        for _ in range(k):\n            # Select a random segment\n            seg_start = np.random.randint(0, n - 2)\n            seg_length = np.random.randint(2, min(4, n - seg_start))\n            segment = new_solution[seg_start:seg_start+seg_length]\n\n            # Remove the segment\n            temp_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n            # Evaluate insertion points\n            insertion_costs = []\n            for i in range(len(temp_solution)):\n                prev_node = temp_solution[i-1]\n                next_node = temp_solution[i % len(temp_solution)]\n\n                # Original cost\n                original_cost1 = distance_matrix_1[prev_node, next_node]\n                original_cost2 = distance_matrix_2[prev_node, next_node]\n\n                # New cost if segment is inserted here\n                new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                            distance_matrix_1[segment[-1], next_node] -\n                            original_cost1)\n                new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                            distance_matrix_2[segment[-1], next_node] -\n                            original_cost2)\n\n                # Evaluate both objectives\n                insertion_costs.append(alpha * new_cost1 + (1 - alpha) * new_cost2)\n\n            # Insert at best position\n            best_pos = np.argmin(insertion_costs)\n            temp_solution = np.insert(temp_solution, best_pos, segment)\n\n            # Apply constrained edge reversal\n            if np.random.random() < 0.4:\n                rev_start = np.random.randint(0, len(temp_solution) - 2)\n                rev_end = np.random.randint(rev_start + 2, len(temp_solution))\n\n                # Check if reversal improves both objectives\n                original_cost1 = (distance_matrix_1[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_1[temp_solution[rev_end-1], temp_solution[rev_end]])\n                original_cost2 = (distance_matrix_2[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_2[temp_solution[rev_end-1], temp_solution[rev_end]])\n\n                reversed_segment = temp_solution[rev_start:rev_end][::-1]\n                new_cost1 = (distance_matrix_1[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], temp_solution[rev_end]])\n                new_cost2 = (distance_matrix_2[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], temp_solution[rev_end]])\n\n                if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.05) or \\\n                   (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.05):\n                    temp_solution[rev_start:rev_end] = reversed_segment\n\n            # Update solution if better\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.5081194483044555,
            8.949465568077065
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism, then applies a novel hybrid local search combining multi-segment inversion with adaptive edge swapping that considers both objective spaces to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def diversity_based_selection(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = diversity_based_selection(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            if random.random() < 0.7:\n                # Multi-segment inversion\n                segments = random.randint(2, 4)\n                points = sorted(random.sample(range(n), segments))\n                temp_solution = solution.copy()\n                for i in range(len(points)-1):\n                    temp_solution[points[i]:points[i+1]] = temp_solution[points[i]:points[i+1]][::-1]\n            else:\n                # Adaptive edge swapping\n                i, j = random.sample(range(n), 2)\n                temp_solution = solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if (cost1 <= best_cost1 and cost2 <= best_cost2 and (cost1 < best_cost1 or cost2 < best_cost2)) or \\\n               (random.random() < 0.2):\n                best_solution = temp_solution.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.8020434904813545,
            5.8343837297634344
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel cross-space segment inversion with a dynamic node clustering strategy, using multi-objective aware selection and adaptive segment reordering to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_diverse_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_diverse_solution(archive)\n    new_solution = base_solution.copy()\n\n    def cross_space_segment_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([solution[:a], segment[::-1], solution[b:]])\n            else:\n                new_tour = np.concatenate([solution[:a], segment, solution[b:]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = cross_space_segment_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.199415122090953,
            5.460942632339946
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    }
]