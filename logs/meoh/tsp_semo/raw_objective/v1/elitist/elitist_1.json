[
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on the sum of its objectives, then applies a hybrid local search operator that combines edge-swapping with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment inversion with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # If too small, perform a simple edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to invert\n        start = np.random.randint(0, n // 2)\n        end = np.random.randint(start + 2, min(n, start + n // 2))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Optionally swap some edges within the segment\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    return new_solution\n\n",
        "score": [
            7.411342874096885,
            6.190483383398926
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines edge insertion with a dynamic node reordering strategy, prioritizing segments with high potential for improvement in both objective spaces by adaptively selecting and perturbing critical edges based on their contribution to the total cost in either space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    selected_idx = np.argmin([min(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical segments in both objective spaces\n    n = len(base_solution)\n    critical_edges = set()\n\n    # Find edges with high contribution to total cost in either space\n    total_cost_1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    total_cost_2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        if (distance_matrix_1[u, v] / total_cost_1 > 0.1) or (distance_matrix_2[u, v] / total_cost_2 > 0.1):\n            critical_edges.add(i)\n\n    if not critical_edges:\n        # If no critical edges found, select a random segment\n        critical_edges.add(np.random.randint(0, n))\n\n    # Perform hybrid local search: edge insertion with dynamic reordering\n    for i in critical_edges:\n        # Select a segment to perturb\n        segment_start = i\n        segment_length = min(3, n // 2)  # Limit segment length for efficiency\n        segment_end = (segment_start + segment_length) % n\n\n        # Extract the segment\n        segment = new_solution[segment_start:segment_end]\n        if segment_end < segment_start:\n            segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n\n        # Remove the segment\n        if segment_end < segment_start:\n            new_solution = np.concatenate([new_solution[:segment_end], new_solution[segment_end:segment_start]])\n        else:\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n        # Reinsert the segment at a new position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure the solution remains valid (no duplicates)\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != len(instance):\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.085762682628435,
            9.536535714336596
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on the sum of its objectives, then applies a hybrid local search operator that combines edge-swapping with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment inversion with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # If too small, perform a simple edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to invert\n        start = np.random.randint(0, n // 2)\n        end = np.random.randint(start + 2, min(n, start + n // 2))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Optionally swap some edges within the segment\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    return new_solution\n\n",
        "score": [
            7.411342874096885,
            6.190483383398926
        ]
    }
]