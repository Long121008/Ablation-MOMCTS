[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An innovative adaptive multi-objective local search algorithm that employs a novel 5-opt*+segment rotation strategy with dynamic objective-aware cost balancing, using Pareto-frontier guided selection and adaptive segment permutation to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding, incorporating a hybrid segment rotation and insertion strategy for enhanced solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_5opt_rotation_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[3][::-1], segments[1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[4], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[4], segments[1], segments[2], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.02 and cost2 < best_cost2 * 1.02) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_5opt_rotation_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines a novel 4-opt*+segment swap strategy with dynamic objective-aware cost balancing, using Pareto-frontier guided selection and adaptive segment rearrangement to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding, incorporating a hybrid segment swap and inversion strategy for enhanced solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_swap_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[3], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n                np.concatenate([segments[1], segments[0], segments[2], segments[3]]),\n                np.concatenate([segments[1], segments[2], segments[0], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.9 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.9 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_swap_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.001430870356963,
            5.471980790119082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_swap_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[3], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[3], segments[1]]),\n                np.concatenate([segments[1], segments[0], segments[2], segments[3]]),\n                np.concatenate([segments[1], segments[2], segments[0], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.9 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.9 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_swap_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An adaptive local search algorithm that combines a novel 3-segment rearrangement with dynamic segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-segment dynamic rearrangement with adaptive segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_4segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[1], segments[0], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_4segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.886735525198715,
            5.508305984137848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_4segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[1], segments[0], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_4segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 4-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.499312812019222,
            6.0689349000627715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, using a weighted Pareto-aware selection criterion and adaptive cost thresholding to explore constrained neighborhoods while ensuring feasibility through segment validation and multi-objective cost balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.15 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4][::-1], segments[5], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4][::-1], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4], segments[5][::-1], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.07) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.07):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.4012242907064625,
            6.161250186426621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.15 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4][::-1], segments[5], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4][::-1], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4], segments[5][::-1], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.07) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.07):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n"
    }
]