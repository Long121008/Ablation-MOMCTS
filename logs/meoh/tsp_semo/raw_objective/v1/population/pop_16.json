[
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel cross-space segment inversion with a dynamic node clustering strategy, using multi-objective aware selection and adaptive segment reordering to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_diverse_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_diverse_solution(archive)\n    new_solution = base_solution.copy()\n\n    def cross_space_segment_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([solution[:a], segment[::-1], solution[b:]])\n            else:\n                new_tour = np.concatenate([solution[:a], segment, solution[b:]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = cross_space_segment_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.199415122090953,
            5.460942632339946
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a novel edge-swapping strategy combined with a multi-segment relocation operator to generate a neighbor solution while ensuring feasibility, and incorporates an adaptive insertion heuristic that considers both objectives to balance the search across the two spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with objective-aware selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.7:\n                # Swap edges based on combined cost\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if 0.7 * cost1 + 0.3 * cost2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Multi-segment relocation\n        segments = np.random.randint(1, min(3, n // 3))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Find insertion point considering both objectives\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(0.7 * cost1 + 0.3 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.978108930531727,
            7.395425275936926
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic segment rotation strategy, using Pareto-dominance aware selection and adaptive perturbation to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_pareto_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_pareto_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_segment_rotation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2, segment3[::-1], segment4])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3, segment4[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_segment_rotation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.044143454174796,
            6.0181333464344675
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of Pareto dominance and adaptive segment swapping, then applies a novel dynamic segment relocation strategy that combines edge flipping with instance-aware node insertion, ensuring feasibility through careful boundary checks and cost evaluations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_relocation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n            remaining = np.concatenate([solution[:a], solution[b:]])\n\n            if len(segment) > 1 and len(remaining) > 1:\n                insert_pos = random.randint(0, len(remaining))\n                if insert_pos == 0:\n                    new_tour = np.concatenate([segment[::-1], remaining])\n                elif insert_pos == len(remaining):\n                    new_tour = np.concatenate([remaining, segment[::-1]])\n                else:\n                    new_tour = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n                cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1) or (cost2 < best_cost2):\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_relocation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.19581133746161,
            5.783815621343472
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    # Select solution with highest hybrid score\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with probabilistic selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.8:\n                # Evaluate swap based on both objectives\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if w1 * cost1 + w2 * cost2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Adaptive segment relocation\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Multi-objective insertion evaluation\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            7.764596016804793,
            5.2528377695313715
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a non-linear objective score with adaptive weight normalization and hypervolume-based selection, applies a novel combination of edge-swapping and segment inversion with multi-objective segment insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with high potential for Pareto improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n\n    # Hypervolume-based selection\n    sorted_indices = np.lexsort((norm_obj2, norm_obj1))\n    hypervolumes = []\n    for i in range(len(sorted_indices)):\n        current = sorted_indices[i]\n        if i == 0:\n            hv = (1 - norm_obj1[current]) * (1 - norm_obj2[current])\n        else:\n            prev = sorted_indices[i-1]\n            hv = (norm_obj1[prev] - norm_obj1[current]) * (norm_obj2[prev] - norm_obj2[current])\n        hypervolumes.append(hv)\n\n    hypervolumes = np.array(hypervolumes)\n    w1 = 0.7 * (1 - hypervolumes / np.sum(hypervolumes))\n    w2 = 1 - w1\n\n    # Select solution with highest hypervolume score\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with probabilistic selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.9:\n                # Evaluate swap based on both objectives\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if (w1[selected_idx] * cost1 + w2[selected_idx] * cost2) < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment inversion with multi-objective evaluation\n        start = np.random.randint(0, n // 2)\n        length = np.random.randint(2, min(8, n - start))\n        end = start + length\n        segment = new_solution[start:end]\n        inverted_segment = segment[::-1]\n\n        # Evaluate inversion\n        cost1 = (distance_matrix_1[new_solution[start-1], inverted_segment[0]] +\n                 distance_matrix_1[inverted_segment[-1], new_solution[end % n]] -\n                 distance_matrix_1[new_solution[start-1], new_solution[end % n]])\n        cost2 = (distance_matrix_2[new_solution[start-1], inverted_segment[0]] +\n                 distance_matrix_2[inverted_segment[-1], new_solution[end % n]] -\n                 distance_matrix_2[new_solution[start-1], new_solution[end % n]])\n        if (w1[selected_idx] * cost1 + w2[selected_idx] * cost2) < 0:\n            new_solution[start:end] = inverted_segment\n\n        # Multi-objective segment insertion\n        segment_length = np.random.randint(2, min(5, n // 3))\n        segment_start = np.random.randint(0, n - segment_length)\n        segment = new_solution[segment_start:segment_start+segment_length]\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start+segment_length:]])\n\n        insertion_costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i % len(new_solution)]\n            cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                     distance_matrix_1[segment[-1], next_node] -\n                     distance_matrix_1[prev_node, next_node])\n            cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                     distance_matrix_2[segment[-1], next_node] -\n                     distance_matrix_2[prev_node, next_node])\n            insertion_costs.append(w1[selected_idx] * cost1 + w2[selected_idx] * cost2)\n\n        insert_pos = np.argmin(insertion_costs)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            7.4378620459100775,
            5.59535800913701
        ]
    }
]