[
    {
        "algorithm": "{A hybrid local search algorithm that combines a modified 3-opt move with a biased random walk to explore the solution space, prioritizing non-dominated regions and dynamically adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Modified 3-opt with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):  # Number of iterations\n            # Randomly select three distinct segments\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            # Generate a new tour by reversing segments with probability\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions to escape local optima\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.365297097212141,
            5.7434965719181355
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lexicographic ordering of objectives, then applies a novel path relinking approach that combines segment inversion with adaptive edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        start = np.random.randint(0, n // 3)\n        end = np.random.randint(start + 2, min(n, start + n // 3))\n        segment = new_solution[start:end]\n\n        if np.random.rand() < 0.8:\n            new_solution[start:end] = segment[::-1]\n\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n        if np.random.rand() < 0.3 and n >= 4:\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.132460775922828,
            10.453730271959436
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with edge insertion\n        start = np.random.randint(0, n // 3)\n        end = np.random.randint(start + 2, min(n, start + n // 3))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Insert a randomly selected node from elsewhere in the tour\n        if n > 4:\n            pos = np.random.randint(end, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            5.409315988911607,
            7.7830246934600416
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic neighborhood exploration strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            5.933597847097488,
            6.499122446202933
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic segment reversal strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.106345483709433,
            6.279480048841997
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines a biased random walk with a dynamic segment reversal and insertion strategy to explore the solution space, prioritizing non-dominated solutions and adaptively adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Dynamic segment reversal and insertion with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):  # Increased number of iterations\n            # Randomly select two distinct segments\n            a, b = sorted(random.sample(range(n), 2))\n            segment1 = solution[a:b]\n            segment2 = np.concatenate([solution[b:], solution[:a]])\n\n            # Dynamic segment reversal and insertion\n            if random.random() < 0.7:  # Higher probability for reversal\n                new_tour = np.concatenate([segment1[::-1], segment2])\n            else:\n                # Random insertion of a segment\n                insert_pos = random.randint(0, len(segment2) - 1)\n                new_tour = np.concatenate([segment2[:insert_pos], segment1, segment2[insert_pos:]])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective or with higher probability\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Higher probability to accept worse solutions to escape local optima\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.31875918667774,
            5.913916233932454
        ]
    },
    {
        "algorithm": "{A novel adaptive local search algorithm that combines a dynamic 5-opt* move with a Pareto-dominance guided neighborhood exploration strategy, using instance-specific parameters to balance exploration and exploitation while ensuring feasibility through multi-objective evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_diverse_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.choice(range(len(archive)))\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_diverse_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = solution[d:e]\n            segment5 = np.concatenate([solution[e:], solution[:a]])\n\n            if random.random() < 0.7:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1], segment5])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2, segment5[::-1], segment4])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or random.random() < 0.15:\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.207797273440402,
            6.093330354665267
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic node clustering approach with a biased edge relocation strategy, where nodes are grouped based on their combined objective costs, and edges are relocated to form clusters that minimize the total cost across both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on combined cost contribution\n    node_scores = np.zeros(n)\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        node_scores[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / (distance_matrix_1[u, v] + distance_matrix_2[u, v] + 1e-6)\n\n    # Identify nodes with high cost contribution\n    high_cost_nodes = np.argsort(node_scores)[-max(2, n//4):]\n\n    # Relocate high-cost nodes to new positions\n    for node_idx in high_cost_nodes:\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n):\n            # Try inserting after pos\n            temp_solution = np.insert(new_solution, pos, new_solution[node_idx])\n            temp_solution = np.delete(temp_solution, node_idx + (1 if node_idx > pos else 0))\n\n            # Calculate new cost\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, new_solution[node_idx])\n        new_solution = np.delete(new_solution, node_idx + (1 if node_idx > best_pos else 0))\n\n    return new_solution\n\n",
        "score": [
            6.138556990634729,
            6.325836965234252
        ]
    },
    {
        "algorithm": "{This algorithm combines lexicographic selection with a novel adaptive segment crossover and dynamic edge perturbation strategy to generate high-quality neighbors by intelligently recombining solution segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        crossover_point = np.random.randint(1, n-1)\n        segment_length = np.random.randint(2, min(n//2, 10))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        segment1 = new_solution[start:end]\n        segment2 = np.random.choice(archive_sorted[1][0], size=segment_length, replace=False) if len(archive_sorted) > 1 else segment1[::-1]\n\n        if np.random.rand() < 0.7:\n            new_solution[start:end] = segment2\n        else:\n            new_solution[start:end] = segment1[::-1]\n\n        if np.random.rand() < 0.4:\n            a, b = np.random.choice(n, 2, replace=False)\n            if new_solution[a] not in new_solution[:a] and new_solution[a] not in new_solution[a+1:]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.rand() < 0.3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and new_solution[i] not in new_solution[:j] and new_solution[i] not in new_solution[j+1:]:\n                temp = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, temp)\n\n    return new_solution\n\n",
        "score": [
            5.656966966177388,
            9.31643710641032
        ]
    }
]