[
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search operator that combines adaptive node insertion with constrained edge reversal, using a multi-objective evaluation framework that dynamically balances exploration and exploitation while maintaining feasibility through careful path validation and segment merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and improvement potential\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n\n    # Calculate diversity score\n    diversity_scores = np.abs(norm_obj1 - norm_obj2)\n    improvement_scores = 1 - (norm_obj1 + norm_obj2) / 2\n\n    # Combine scores with dynamic weights\n    alpha = 0.7 if np.mean(diversity_scores) > 0.5 else 0.3\n    combined_scores = alpha * diversity_scores + (1 - alpha) * improvement_scores\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive node insertion with constrained edge reversal\n        k = min(3, n // 3)\n        for _ in range(k):\n            # Select a random segment\n            seg_start = np.random.randint(0, n - 2)\n            seg_length = np.random.randint(2, min(4, n - seg_start))\n            segment = new_solution[seg_start:seg_start+seg_length]\n\n            # Remove the segment\n            temp_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n            # Evaluate insertion points\n            insertion_costs = []\n            for i in range(len(temp_solution)):\n                prev_node = temp_solution[i-1]\n                next_node = temp_solution[i % len(temp_solution)]\n\n                # Original cost\n                original_cost1 = distance_matrix_1[prev_node, next_node]\n                original_cost2 = distance_matrix_2[prev_node, next_node]\n\n                # New cost if segment is inserted here\n                new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                            distance_matrix_1[segment[-1], next_node] -\n                            original_cost1)\n                new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                            distance_matrix_2[segment[-1], next_node] -\n                            original_cost2)\n\n                # Evaluate both objectives\n                insertion_costs.append(alpha * new_cost1 + (1 - alpha) * new_cost2)\n\n            # Insert at best position\n            best_pos = np.argmin(insertion_costs)\n            temp_solution = np.insert(temp_solution, best_pos, segment)\n\n            # Apply constrained edge reversal\n            if np.random.random() < 0.4:\n                rev_start = np.random.randint(0, len(temp_solution) - 2)\n                rev_end = np.random.randint(rev_start + 2, len(temp_solution))\n\n                # Check if reversal improves both objectives\n                original_cost1 = (distance_matrix_1[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_1[temp_solution[rev_end-1], temp_solution[rev_end]])\n                original_cost2 = (distance_matrix_2[temp_solution[rev_start-1], temp_solution[rev_start]] +\n                                 distance_matrix_2[temp_solution[rev_end-1], temp_solution[rev_end]])\n\n                reversed_segment = temp_solution[rev_start:rev_end][::-1]\n                new_cost1 = (distance_matrix_1[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], temp_solution[rev_end]])\n                new_cost2 = (distance_matrix_2[temp_solution[rev_start-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], temp_solution[rev_end]])\n\n                if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.05) or \\\n                   (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.05):\n                    temp_solution[rev_start:rev_end] = reversed_segment\n\n            # Update solution if better\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.5081194483044555,
            8.949465568077065
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism, then applies a novel hybrid local search combining multi-segment inversion with adaptive edge swapping that considers both objective spaces to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def diversity_based_selection(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = diversity_based_selection(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            if random.random() < 0.7:\n                # Multi-segment inversion\n                segments = random.randint(2, 4)\n                points = sorted(random.sample(range(n), segments))\n                temp_solution = solution.copy()\n                for i in range(len(points)-1):\n                    temp_solution[points[i]:points[i+1]] = temp_solution[points[i]:points[i+1]][::-1]\n            else:\n                # Adaptive edge swapping\n                i, j = random.sample(range(n), 2)\n                temp_solution = solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            if len(np.unique(temp_solution)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if (cost1 <= best_cost1 and cost2 <= best_cost2 and (cost1 < best_cost1 or cost2 < best_cost2)) or \\\n               (random.random() < 0.2):\n                best_solution = temp_solution.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.8020434904813545,
            5.8343837297634344
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 4-opt move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights that dynamically adjust based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.811565901044076,
            5.686570302241275
        ]
    },
    {
        "algorithm": "{An adaptive hybrid local search algorithm that combines a novel 4-opt* move with a dynamic segment reversal strategy, using Pareto-aware selection and adaptive segment swapping to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])\n        selected_idx = random.randint(0, min(4, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_swap(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            seg1 = solution[a:b]\n            seg2 = solution[b:c]\n            seg3 = solution[c:d]\n            seg4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.7:\n                new_tour = np.concatenate([seg1, seg3, seg2, seg4])\n            else:\n                new_tour = np.concatenate([seg1[::-1], seg3[::-1], seg2[::-1], seg4])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_swap(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.214849459873125,
            5.360687941541983
        ]
    }
]