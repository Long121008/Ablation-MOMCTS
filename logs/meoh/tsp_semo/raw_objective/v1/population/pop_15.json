[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    # Select solution with highest hybrid score\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with probabilistic selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.8:\n                # Evaluate swap based on both objectives\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if w1 * cost1 + w2 * cost2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Adaptive segment relocation\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Multi-objective insertion evaluation\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            7.764596016804793,
            5.2528377695313715
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a novel edge-swapping strategy combined with a multi-segment relocation operator to generate a neighbor solution while ensuring feasibility, and incorporates an adaptive insertion heuristic that considers both objectives to balance the search across the two spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with objective-aware selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.7:\n                # Swap edges based on combined cost\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if 0.7 * cost1 + 0.3 * cost2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Multi-segment relocation\n        segments = np.random.randint(1, min(3, n // 3))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Find insertion point considering both objectives\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(0.7 * cost1 + 0.3 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.978108930531727,
            7.395425275936926
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic segment rotation strategy, using Pareto-dominance aware selection and adaptive perturbation to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_pareto_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_pareto_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_segment_rotation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2, segment3[::-1], segment4])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3, segment4[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_segment_rotation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.044143454174796,
            6.0181333464344675
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic segment reversal strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment2, segment1[::-1], segment3])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.623806225793005,
            5.64039794470818
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel cross-space segment relocation strategy with a dynamic segment reversal operator, using multi-objective aware selection and adaptive segment swapping to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def cross_space_segment_relocation(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([solution[:a], solution[b:]])\n                insert_pos = random.randint(0, len(new_tour))\n                new_tour = np.insert(new_tour, insert_pos, segment)\n            else:\n                new_tour = np.concatenate([segment, solution[:a], solution[b:]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = cross_space_segment_relocation(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.680500456473837,
            5.609067192780439
        ]
    },
    {
        "algorithm": "{A hybrid local search algorithm that combines a modified 3-opt move with a biased random walk to explore the solution space, prioritizing non-dominated regions and dynamically adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Modified 3-opt with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):  # Number of iterations\n            # Randomly select three distinct segments\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            # Generate a new tour by reversing segments with probability\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions to escape local optima\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.365297097212141,
            5.7434965719181355
        ]
    },
    {
        "algorithm": "{An enhanced local search algorithm that employs a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 + cost2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.561155984742824,
            6.041639462863467
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of Pareto dominance and adaptive segment swapping, then applies a novel dynamic segment relocation strategy that combines edge flipping with instance-aware node insertion, ensuring feasibility through careful boundary checks and cost evaluations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_segment_relocation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = solution[a:b]\n            remaining = np.concatenate([solution[:a], solution[b:]])\n\n            if len(segment) > 1 and len(remaining) > 1:\n                insert_pos = random.randint(0, len(remaining))\n                if insert_pos == 0:\n                    new_tour = np.concatenate([segment[::-1], remaining])\n                elif insert_pos == len(remaining):\n                    new_tour = np.concatenate([remaining, segment[::-1]])\n                else:\n                    new_tour = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n                cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1) or (cost2 < best_cost2):\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_relocation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.19581133746161,
            5.783815621343472
        ]
    }
]