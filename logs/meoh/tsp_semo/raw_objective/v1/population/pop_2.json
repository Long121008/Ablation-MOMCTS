[
    {
        "algorithm": "{A hybrid local search algorithm that combines a modified 3-opt move with a biased random walk to explore the solution space, prioritizing non-dominated regions and dynamically adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Modified 3-opt with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):  # Number of iterations\n            # Randomly select three distinct segments\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            # Generate a new tour by reversing segments with probability\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions to escape local optima\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.365297097212141,
            5.7434965719181355
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 3-opt with edge-swap\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Randomly swap two edges to introduce diversity\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.149417117853994,
            6.4820173028775
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on the sum of its objectives, then applies a hybrid local search operator that combines edge-swapping with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment inversion with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # If too small, perform a simple edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to invert\n        start = np.random.randint(0, n // 2)\n        end = np.random.randint(start + 2, min(n, start + n // 2))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Optionally swap some edges within the segment\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    return new_solution\n\n",
        "score": [
            7.411342874096885,
            6.190483383398926
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the minimum sum of objectives, then applies a novel path relinking approach that combines segment inversion with edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        start = np.random.randint(0, n // 2)\n        end = np.random.randint(start + 2, min(n, start + n // 2))\n        segment = new_solution[start:end]\n\n        if np.random.rand() < 0.7:\n            new_solution[start:end] = segment[::-1]\n\n        if np.random.rand() < 0.3 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    return new_solution\n\n",
        "score": [
            6.477467877985924,
            6.5013910405876185
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with biased random insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Biased random insertion: move a random node to a position that reduces the maximum objective cost\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        mask = np.ones(n, dtype=bool)\n        mask[np.where(new_solution == node_to_move)[0][0]] = False\n        possible_positions = np.where(mask)[0]\n\n        # Evaluate insertion positions\n        costs = []\n        for pos in possible_positions:\n            temp_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_move)[0][0]), pos, node_to_move)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i-1]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i-1]] for i in range(n))\n            costs.append(max(cost1, cost2))\n\n        # Select position that minimizes the maximum cost\n        best_pos = possible_positions[np.argmin(costs)]\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_move)[0][0]), best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            7.111970445564488,
            6.720453867830934
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel segment rotation strategy that dynamically reorders segments of varying lengths while preserving feasibility by ensuring no node is duplicated or skipped.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of varying length\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract and rotate the segment\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, np.random.randint(1, segment_length))\n\n        # Reinsert the rotated segment\n        new_solution[start:end] = rotated_segment\n\n        # Ensure no duplicates exist\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.581778525076053,
            8.22580869619183
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the minimum of its two objectives, then applies a hybrid local search that combines a novel path relinking strategy with a dynamic segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path relinking with dynamic segment reversal\n        ref_solution = archive_sorted[1][0].copy() if len(archive) > 1 else base_solution.copy()\n        common_indices = np.where(np.isin(base_solution, ref_solution))[0]\n\n        if len(common_indices) > 1:\n            start = np.random.choice(common_indices)\n            end = np.random.choice(common_indices[common_indices > start]) if len(common_indices[common_indices > start]) > 0 else start + 1\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n        # Dynamic edge swapping based on distance matrices\n        if np.random.rand() < 0.7:\n            i, j = np.random.choice(n, 2, replace=False)\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            if cost1 < cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.627278885301055,
            7.157146091683956
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines edge insertion with a dynamic node reordering strategy, prioritizing segments with high potential for improvement in both objective spaces by adaptively selecting and perturbing critical edges based on their contribution to the total cost in either space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    selected_idx = np.argmin([min(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical segments in both objective spaces\n    n = len(base_solution)\n    critical_edges = set()\n\n    # Find edges with high contribution to total cost in either space\n    total_cost_1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    total_cost_2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        if (distance_matrix_1[u, v] / total_cost_1 > 0.1) or (distance_matrix_2[u, v] / total_cost_2 > 0.1):\n            critical_edges.add(i)\n\n    if not critical_edges:\n        # If no critical edges found, select a random segment\n        critical_edges.add(np.random.randint(0, n))\n\n    # Perform hybrid local search: edge insertion with dynamic reordering\n    for i in critical_edges:\n        # Select a segment to perturb\n        segment_start = i\n        segment_length = min(3, n // 2)  # Limit segment length for efficiency\n        segment_end = (segment_start + segment_length) % n\n\n        # Extract the segment\n        segment = new_solution[segment_start:segment_end]\n        if segment_end < segment_start:\n            segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n\n        # Remove the segment\n        if segment_end < segment_start:\n            new_solution = np.concatenate([new_solution[:segment_end], new_solution[segment_end:segment_start]])\n        else:\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n        # Reinsert the segment at a new position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure the solution remains valid (no duplicates)\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != len(instance):\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.085762682628435,
            9.536535714336596
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by considering both objectives individually, then applies a novel crossover-like local search that combines segments from multiple solutions to create a new neighbor while preserving feasibility, ensuring no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        base_solution = archive[0][0].copy()\n        new_solution = base_solution.copy()\n        n = len(new_solution)\n        if n >= 2:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select two solutions from the archive based on their objectives\n    archive_sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    archive_sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    sol1 = archive_sorted_obj1[0][0].copy()\n    sol2 = archive_sorted_obj2[0][0].copy()\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Determine crossover points\n    point1 = np.random.randint(1, n//2)\n    point2 = np.random.randint(point1 + 1, n - 1)\n\n    # Copy segments from sol1 and sol2\n    new_solution[:point1] = sol1[:point1]\n    new_solution[point1:point2] = sol2[point1:point2]\n    new_solution[point2:] = sol1[point2:]\n\n    # Ensure all nodes are included and no duplicates exist\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    for i in range(n):\n        if new_solution[i] == -1:\n            new_solution[i] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    # Apply a small perturbation to avoid local optima\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.632849156706452,
            9.736616106351146
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic path inversion strategy with adaptive edge swapping, prioritizing segments that show potential for improvement in both objective spaces by selectively inverting critical paths and swapping edges based on their combined contribution to the total cost in either space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    selected_idx = np.argmin([min(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical segments in both objective spaces\n    n = len(base_solution)\n    critical_edges = set()\n\n    # Find edges with high contribution to total cost in either space\n    total_cost_1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    total_cost_2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        if (distance_matrix_1[u, v] / total_cost_1 > 0.1) or (distance_matrix_2[u, v] / total_cost_2 > 0.1):\n            critical_edges.add(i)\n\n    if not critical_edges:\n        # If no critical edges found, select a random segment\n        critical_edges.add(np.random.randint(0, n))\n\n    # Perform hybrid local search: dynamic path inversion and adaptive edge swapping\n    for i in critical_edges:\n        # Select a segment to perturb\n        segment_start = i\n        segment_length = min(4, n // 3)  # Limit segment length for efficiency\n        segment_end = (segment_start + segment_length) % n\n\n        # Extract the segment\n        segment = new_solution[segment_start:segment_end]\n        if segment_end < segment_start:\n            segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n\n        # Invert the segment with probability 0.5\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment\n        if segment_end < segment_start:\n            new_solution = np.concatenate([new_solution[:segment_end], new_solution[segment_end:segment_start]])\n        else:\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n        # Reinsert the segment at a new position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure the solution remains valid (no duplicates)\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != len(instance):\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n        # Adaptive edge swapping\n        if len(new_solution) > 3:\n            swap_pos1 = np.random.randint(0, len(new_solution))\n            swap_pos2 = np.random.randint(0, len(new_solution))\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n            # Ensure the solution remains valid (no duplicates)\n            unique, counts = np.unique(new_solution, return_counts=True)\n            if len(unique) != len(instance):\n                # If duplicates exist, revert to original solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.945366936341095,
            9.899784568350139
        ]
    }
]