[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on Pareto dominance or hypervolume contribution, then applies a hybrid local search combining edge insertion with a novel segment inversion operator that considers both objective spaces to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge insertion with segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge Insertion (standard but with novel selection criteria)\n    if n > 3:\n        # Select a random segment to remove\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find the best insertion point considering both objectives\n        best_insert_pos = -1\n        best_cost_improvement = 0\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue  # Skip the segment itself\n\n            # Calculate cost before and after insertion\n            old_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[b%n]]\n            old_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[b%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[b%n]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[b%n]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[i]]\n\n            # Novel selection criteria: weighted improvement\n            improvement = 0.7 * (old_cost1 - new_cost1) + 0.3 * (old_cost2 - new_cost2)\n\n            if improvement > best_cost_improvement:\n                best_cost_improvement = improvement\n                best_insert_pos = i\n\n        if best_insert_pos != -1 and best_insert_pos != a:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:best_insert_pos],\n                new_solution[a:b],\n                new_solution[best_insert_pos:]\n            ])\n\n    # Step 2: Segment Inversion with Objective Awareness\n    if n > 4:\n        # Select a random segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate cost before inversion\n        old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[b%n]]\n        old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[b%n]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[b%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[b%n]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.202747482753749,
            6.566930261504643
        ]
    },
    {
        "algorithm": "{The algorithm selects a high-performing solution from the archive, applies a hybrid local search combining edge insertion and node reordering to explore diverse neighborhoods while preserving feasibility, and ensures the generated neighbor maintains valid TSP properties through careful edge swaps and validations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Hybrid local search: Edge insertion with node reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder (3-opt style)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j]\n    np.random.shuffle(segment)\n    new_solution[i:j] = segment\n\n    # Validate and fix if necessary (ensure no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Revert to original if invalid\n        new_solution = selected_solution.copy()\n        # Try a different operation: swap two edges\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.067447405091563,
            8.734784668648363
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on Pareto dominance or hypervolume contribution, then applies a hybrid local search combining edge insertion with a novel segment inversion operator that considers both objective spaces to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge insertion with segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge Insertion (standard but with novel selection criteria)\n    if n > 3:\n        # Select a random segment to remove\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find the best insertion point considering both objectives\n        best_insert_pos = -1\n        best_cost_improvement = 0\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue  # Skip the segment itself\n\n            # Calculate cost before and after insertion\n            old_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[b%n]]\n            old_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[b%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[b%n]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[b%n]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[i]]\n\n            # Novel selection criteria: weighted improvement\n            improvement = 0.7 * (old_cost1 - new_cost1) + 0.3 * (old_cost2 - new_cost2)\n\n            if improvement > best_cost_improvement:\n                best_cost_improvement = improvement\n                best_insert_pos = i\n\n        if best_insert_pos != -1 and best_insert_pos != a:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:best_insert_pos],\n                new_solution[a:b],\n                new_solution[best_insert_pos:]\n            ])\n\n    # Step 2: Segment Inversion with Objective Awareness\n    if n > 4:\n        # Select a random segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate cost before inversion\n        old_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[(b-1)%n], new_solution[b%n]]\n        old_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[(b-1)%n], new_solution[b%n]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[b%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[b%n]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.202747482753749,
            6.566930261504643
        ]
    }
]