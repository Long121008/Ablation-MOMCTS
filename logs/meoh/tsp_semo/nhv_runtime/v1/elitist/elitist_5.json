[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9607322286408637,
            0.1317448616027832
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9019487432652015,
            0.12188470363616943
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment insertion and random segment shuffling to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.exp(objectives * weights)\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Insert segment and shuffle\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n    # Option 2: Random segment swap with insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8466090374961941,
            0.12832921743392944
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9434579015333912,
            0.23075997829437256
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on the worst objective value, then applies a hybrid local search combining node swapping with a probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = worst_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Perform node swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.3:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([\n                new_solution[:k],\n                [new_solution[l]],\n                new_solution[k:l],\n                [new_solution[k]],\n                new_solution[l:]\n            ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(worst_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8686109153900015,
            0.16374021768569946
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9346614731157932,
            0.19465023279190063
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining segment reversal, node reinsertion, and guided edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9558274769611513,
            0.8373363018035889
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-based selection criterion, then applies a novel local search operator combining adaptive segment rotation and distance-aware node insertion to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1  # Reference point for hypervolume calculation\n    hypervolumes = []\n    for obj in objectives:\n        hypervolumes.append((ref_point[0] - obj[0]) * (ref_point[1] - obj[1]))\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive segment rotation and distance-aware insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a segment to rotate adaptively\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(segment, rotation)\n\n        # Find a position to insert the rotated segment\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            # Calculate improvement potential based on distance matrices\n            original_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], rotated_segment[0]] +\n                        distance_matrix_2[new_solution[pos-1], rotated_segment[0]])\n            improvement = original_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                rotated_segment,\n                new_solution[best_pos+segment_length:]\n            ])\n\n        # Distance-aware node insertion\n        nodes_to_insert = np.setdiff1d(np.arange(n), new_solution)\n        if len(nodes_to_insert) > 0:\n            for node in nodes_to_insert:\n                best_insert_pos = -1\n                best_insert_value = float('inf')\n                for pos in range(n):\n                    # Calculate insertion cost based on both distance matrices\n                    cost = (distance_matrix_1[new_solution[pos-1], node] +\n                            distance_matrix_1[node, new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], node] +\n                            distance_matrix_2[node, new_solution[pos]])\n                    if cost < best_insert_value:\n                        best_insert_value = cost\n                        best_insert_pos = pos\n                if best_insert_pos != -1:\n                    new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[np.where(new_solution == unique_nodes[i])[0][0]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9219477201089967,
            0.31579649448394775
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    }
]