[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9346614731157932,
            0.19465023279190063
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9019487432652015,
            0.12188470363616943
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9434579015333912,
            0.23075997829437256
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the Pareto front, then applies a novel local search strategy combining adaptive segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8431834405373214,
            0.21518230438232422
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment relinking, node reinsertion with distance-based optimization, and a novel adaptive perturbation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search combining segment relinking, node reinsertion, and adaptive perturbation\n    if n > 3:\n        # Step 1: Segment relinking with distance-based optimization\n        a, b = sorted(random.sample(range(n), 2))\n        segment = base_solution[a:b]\n\n        # Find the best insertion point in the new solution\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n - len(segment) + 1):\n            temp = np.concatenate([new_solution[:pos], segment, new_solution[pos + len(segment):]])\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos + len(segment):]])\n\n        # Step 2: Node reinsertion with adaptive perturbation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find the position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            temp = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Adaptive perturbation based on current solution quality\n        if random.random() < 0.3:  # Higher chance for poor solutions\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9319501253660611,
            0.9100479483604431
        ]
    },
    {
        "algorithm": "{This heuristic function selects a solution from the archive with the highest potential for improvement by combining crowding distance and objective diversity, then applies a hybrid local search operator that combines edge insertion with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 + np.random.rand()) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment of length between 2 and min(6, n//2)\n    seg_length = np.random.randint(2, min(6, n//2) + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = base_solution[start:start+seg_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    remaining = np.concatenate([base_solution[:start], base_solution[start+seg_length:]])\n    insert_pos = np.random.randint(0, len(remaining) - seg_length + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Apply edge insertion for diversification\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8733647118179252,
            0.23261624574661255
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a novel segment-based local search that combines partial reversal and segment swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = None\n    best_score = float('inf')\n    for sol, obj in archive:\n        score = max(obj[0], obj[1])  # Simple Pareto front distance approximation\n        if score < best_score:\n            best_score = score\n            best_solution = sol\n\n    base_solution = best_solution.copy() if best_solution is not None else random.choice(archive)[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment-based local search\n        # Step 1: Split into two segments and swap them\n        split_point = random.randint(1, n-2)\n        segment1 = new_solution[:split_point]\n        segment2 = new_solution[split_point:]\n        new_solution = np.concatenate([segment2, segment1])\n\n        # Step 2: Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8431798002623518,
            0.2262769341468811
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized block relocation with a Pareto-guided edge insertion strategy, prioritizing solutions with high crowding distance in the objective space to enhance diversity while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: randomized block relocation + Pareto-guided edge insertion\n    # Random block relocation\n    block_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - block_size)\n    block = new_solution[start:start+block_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+block_size:], block])\n\n    # Pareto-guided edge insertion\n    for i in range(n):\n        for j in range(n):\n            if i == j or j == (i+1)%n:\n                continue\n\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if Pareto improvement\n            if (delta1 <= 0 and delta2 <= 0) and (delta1 < 0 or delta2 < 0):\n                # Perform edge insertion\n                if i < j:\n                    new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:], new_solution[i+1:j+1], [new_solution[j]]])\n                else:\n                    new_solution = np.concatenate([new_solution[:j+1], new_solution[i+1:], new_solution[j+1:i+1], [new_solution[i]]])\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8739242382097259,
            1.1163862943649292
        ]
    },
    {
        "algorithm": "{The algorithm selects a non-dominated solution from the archive with the highest crowding distance to promote diversity, then applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Calculate crowding distance for non-dominated solutions\n        sorted_solutions = sorted(non_dominated, key=lambda x: (x[1][0], x[1][1]))\n        crowding_distances = [0.0] * len(sorted_solutions)\n\n        for m in range(2):  # For both objectives\n            sorted_solutions.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_solutions)-1):\n                crowding_distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m])\n\n        # Select solution with highest crowding distance\n        max_cd = max(crowding_distances)\n        candidates = [sol for i, (sol, _) in enumerate(sorted_solutions) if crowding_distances[i] == max_cd]\n        base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt and segment reversal\n    if n > 4:\n        # 3-opt: select 3 edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Segment reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8107005733052586,
            0.22998100519180298
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining segment inversion and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive length\n        segment_length = min(3, n // 2)\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Node swapping based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8706596952963149,
            0.37422508001327515
        ]
    }
]