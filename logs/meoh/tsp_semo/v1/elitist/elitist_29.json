[
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 4-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding, incorporating a hybrid segment reversal and insertion strategy for enhanced solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.15 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[3], segments[1], segments[2][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.9 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 * 0.9 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.637465208694918,
            5.755561405894349
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 5-opt move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration, and incorporating a novel segment reversal strategy with adaptive acceptance criteria to explore diverse neighborhoods more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.610278672606704,
            5.961540129537722
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-segment rearrangement with dynamic segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.065478077605774,
            5.285903755911194
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt move with adaptive segment selection and Pareto-aware cost evaluation, using dynamically adjusted weights based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.304250330474227,
            5.156388037994637
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a hybrid 3-opt+segment insertion strategy with dynamic objective weighting, using Pareto-dominance aware selection and adaptive segment reversal to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]]),\n                np.concatenate([segments[1], segments[0][::-1], segments[2]]),\n                np.concatenate([segments[1], segments[2], segments[0][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.208468613092081,
            6.564377751743005
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 5-opt move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration, and incorporating a novel segment reversal strategy with adaptive acceptance criteria to explore diverse neighborhoods more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.610278672606704,
            5.961540129537722
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-segment rearrangement with dynamic segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.065478077605774,
            5.285903755911194
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt move with adaptive segment selection and Pareto-aware cost evaluation, using dynamically adjusted weights based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.304250330474227,
            5.156388037994637
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a hybrid 3-opt+segment insertion strategy with dynamic objective weighting, using Pareto-dominance aware selection and adaptive segment reversal to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]]),\n                np.concatenate([segments[1], segments[0][::-1], segments[2]]),\n                np.concatenate([segments[1], segments[2], segments[0][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.208468613092081,
            6.564377751743005
        ]
    },
    {
        "algorithm": "{A novel adaptive local search algorithm that combines a dynamic 3-opt move with Pareto-frontier aware segment selection and instance-specific objective weighting, using a diversity-aware selection criterion that balances exploitation and exploration while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            diversity = np.mean(np.abs(instance[:, 0] - instance[:, 2]))\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * diversity)\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.728540587022181,
            4.851108058329987
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 4-segment dynamic rearrangement with Pareto-aware segment fusion and instance-specific weight adaptation, using constrained neighborhood exploration to balance objective improvements while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2], segments[3][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3][::-1]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.7559614519869005,
            5.6244255279835915
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, then applies a novel combination of adaptive segment inversion and multi-objective edge insertion with probabilistic segment selection and Pareto-aware cost evaluation, while incorporating a dynamic 5-opt* move with adaptive segment reconfiguration and diversity-preserving permutation strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.4 + 0.4 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d, e = sorted(random.sample(range(n), 5))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            new_solution[d:e],\n            np.concatenate([new_solution[e:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4][::-1]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1][::-1], segments[2], segments[4][::-1]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n               (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(3, n // 3)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.305511872111907,
            8.920963397309288
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-segment rearrangement with dynamic segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.065478077605774,
            5.285903755911194
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt move with adaptive segment selection and Pareto-aware cost evaluation, using dynamically adjusted weights based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.304250330474227,
            5.156388037994637
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights that dynamically adjust based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.3 + cost2 * 0.7) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            7.197367989225901,
            4.667393013142348
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 5-opt move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration, and incorporating a novel segment reversal strategy with adaptive acceptance criteria to explore diverse neighborhoods more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[2], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.610278672606704,
            5.961540129537722
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, then applies a novel combination of adaptive segment inversion and multi-objective edge insertion with probabilistic segment selection and Pareto-aware cost evaluation, while incorporating a dynamic 5-opt* move with adaptive segment reconfiguration and diversity-preserving permutation strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.4 + 0.4 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d, e = sorted(random.sample(range(n), 5))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            new_solution[d:e],\n            np.concatenate([new_solution[e:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4][::-1]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1][::-1], segments[2], segments[4][::-1]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n               (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(3, n // 3)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.305511872111907,
            8.920963397309288
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt move with adaptive segment selection and Pareto-aware cost evaluation, using dynamically adjusted weights based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.304250330474227,
            5.156388037994637
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-segment rearrangement with dynamic segment rotation and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.4 + cost2 * 0.6) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            6.065478077605774,
            5.285903755911194
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a dynamic 4-opt* move with probabilistic segment reversal and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263409950431461,
            6.335828776027276
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 3-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]]),\n                np.concatenate([segments[1], segments[0], segments[2][::-1]]),\n                np.concatenate([segments[1][::-1], segments[2], segments[0]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 0.98 and cost2 < best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 * 0.98 and cost1 < best_cost1 * 1.05) or \\\n                   (cost1 < best_cost1 * 1.02 and cost2 < best_cost2 * 1.02):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.1111061562751665,
            6.6346227278998535
        ]
    },
    {
        "algorithm": "{This algorithm combines adaptive segment decomposition with multi-objective-aware node reinsertion, using a dynamic segment merging strategy that balances exploration and exploitation by evaluating both objective spaces while maintaining feasibility through constrained segment validation and adaptive segment reassembly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective improvement\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    combined_scores = 0.5 * (obj1 / np.max(obj1)) + 0.5 * (obj2 / np.max(obj2))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        # Simple rotation for small tours\n        k = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, k)\n    else:\n        # Adaptive segment decomposition and reinsertion\n        for _ in range(3):\n            # Select random segment boundaries\n            seg_start = np.random.randint(0, n - 3)\n            seg_end = np.random.randint(seg_start + 2, n - 1)\n\n            # Decompose into three segments\n            seg1 = new_solution[:seg_start]\n            seg2 = new_solution[seg_start:seg_end]\n            seg3 = new_solution[seg_end:]\n\n            # Evaluate all possible reinsertion combinations\n            candidates = [\n                np.concatenate([seg1, seg3, seg2]),\n                np.concatenate([seg2, seg1, seg3]),\n                np.concatenate([seg3, seg1, seg2]),\n                np.concatenate([seg1, seg2[::-1], seg3]),\n                np.concatenate([seg1[::-1], seg2, seg3])\n            ]\n\n            # Evaluate each candidate\n            costs = []\n            for candidate in candidates:\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                costs.append((cost1, cost2))\n\n            # Select best candidate based on Pareto dominance\n            best_idx = 0\n            for i in range(1, len(candidates)):\n                if (costs[i][0] < costs[best_idx][0] and costs[i][1] <= costs[best_idx][1] * 1.05) or \\\n                   (costs[i][1] < costs[best_idx][1] and costs[i][0] <= costs[best_idx][0] * 1.05):\n                    best_idx = i\n\n            new_solution = candidates[best_idx].copy()\n\n            # Dynamic segment merging\n            if np.random.random() < 0.3:\n                merge_point = np.random.randint(1, n - 1)\n                merged = np.concatenate([new_solution[:merge_point], new_solution[merge_point:][::-1]])\n                if len(np.unique(merged)) == n:\n                    new_solution = merged.copy()\n\n    return new_solution\n\n",
        "score": [
            5.926288420285383,
            5.623008345948879
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 4-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.746173444989285,
            5.698801376717283
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, then applies a novel combination of adaptive segment inversion and multi-objective edge insertion with probabilistic segment selection and Pareto-aware cost evaluation, while incorporating a dynamic 5-opt* move with adaptive segment reconfiguration and diversity-preserving permutation strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.4 + 0.4 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d, e = sorted(random.sample(range(n), 5))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            new_solution[d:e],\n            np.concatenate([new_solution[e:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4][::-1]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1][::-1], segments[2], segments[4][::-1]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n               (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(3, n // 3)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.305511872111907,
            8.920963397309288
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, Pareto-aware cost balancing, and adaptive permutation strategies, using a weighted score function with objective variance and diversity factors to guide exploration of constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        costs1 = [cost1 for _, (cost1, _) in archive]\n        costs2 = [cost2 for _, (_, cost2) in archive]\n        mean1, std1 = np.mean(costs1), np.std(costs1)\n        mean2, std2 = np.mean(costs2), np.std(costs2)\n\n        scores = []\n        for i, (_, (cost1, cost2)) in enumerate(archive):\n            score = (cost1 - mean1) / (std1 + 1e-6) * 0.6 + (cost2 - mean2) / (std2 + 1e-6) * 0.4\n            score += 0.3 * (cost1 / mean1) * (cost2 / mean2) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f, g = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                solution[f:g],\n                np.concatenate([solution[g:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[5], segments[4][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[3], segments[2][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1], segments[5], segments[6][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3][::-1], segments[2], segments[4], segments[5][::-1], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.614251538569044,
            7.558797037003641
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a dynamic 4-opt* move with probabilistic segment reversal and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.3 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.15) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.15):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263409950431461,
            6.335828776027276
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 3-segment reversal with dynamic segment selection, Pareto-aware cost evaluation, and objective-specific weights that dynamically adjust based on the relative improvement potential of each objective, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_3segment_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]]),\n                np.concatenate([segments[1], segments[0][::-1], segments[2]]),\n                np.concatenate([segments[1], segments[2], segments[0][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_3segment_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.383561003899889,
            6.007986083528888
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that employs a novel 7-opt* move with dynamic segment reconfiguration, using a hybrid selection criterion that combines objective costs with solution diversity metrics and adaptive permutation strategies to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            diversity = len(set(sol)) / len(sol) * 0.4\n            score = (cost1 * 0.5 + cost2 * 0.5) * (1 + 0.3 * diversity + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_7opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(40):\n            indices = sorted(random.sample(range(n), 7))\n            segments = [\n                solution[indices[0]:indices[1]],\n                solution[indices[1]:indices[2]],\n                solution[indices[2]:indices[3]],\n                solution[indices[3]:indices[4]],\n                solution[indices[4]:indices[5]],\n                solution[indices[5]:indices[6]],\n                np.concatenate([solution[indices[6]:], solution[:indices[0]]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4][::-1], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4], segments[5][::-1], segments[6]]),\n                np.concatenate([segments[0][::-1], segments[1][::-1], segments[2], segments[3], segments[4][::-1], segments[5], segments[6]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4][::-1], segments[5], segments[6]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.03 and cost2 < best_cost2 * 1.03) or \\\n                   (cost1 < best_cost1 * 0.97 and cost2 <= best_cost2 * 1.08) or \\\n                   (cost2 < best_cost2 * 0.97 and cost1 <= best_cost1 * 1.08):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_7opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.633100139495234,
            5.72817218312234
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 6-opt* move with dynamic segment reconfiguration and Pareto-aware cost balancing, using adaptive permutation strategies and instance-specific weights to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.25 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_6opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d, e, f = sorted(random.sample(range(n), 6))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                solution[e:f],\n                np.concatenate([solution[f:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4], segments[5]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4][::-1], segments[5]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3], segments[4][::-1], segments[5]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3][::-1], segments[4], segments[5][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4][::-1], segments[5]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_6opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.321289489816622,
            6.23370748357617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive neighborhood search algorithm that employs a dynamic 4-opt* move with Pareto-dominance guided segment selection and instance-aware cost balancing, using probabilistic segment reversal and insertion to explore high-quality solutions while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.6 + cost2 * 0.4) * (1 + 0.1 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_4opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(50):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                np.concatenate([solution[d:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n                np.concatenate([segments[0], segments[1], segments[2][::-1], segments[3]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1][::-1]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2], segments[3][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_4opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.260535469765954,
            6.541005768026686
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a hybrid 3-opt* move with dynamic segment selection and Pareto-aware cost evaluation, using instance-specific weights to balance objective improvements while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def hybrid_3opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                np.concatenate([solution[c:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2]]),\n                np.concatenate([segments[0], segments[2], segments[1][::-1]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.2) or \\\n                   (cost2 < best_cost2 and cost1 <= best_cost1 * 1.2):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_3opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.702905279581179,
            7.371158632418245
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objective values with a dynamic weight adjustment, applies a novel combination of edge-swapping and adaptive segment relocation with multi-objective insertion evaluation, and incorporates a probabilistic selection mechanism that favors solutions with diverse improvement potential across both objectives, while introducing a dynamic 4-opt* move with adaptive segment selection and Pareto-aware cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    obj1 = np.array([x[1][0] for x in archive])\n    obj2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    norm_obj1 = (obj1 - min1) / (max1 - min1 + 1e-8)\n    norm_obj2 = (obj2 - min2) / (max2 - min2 + 1e-8)\n    diversity = np.std(norm_obj1) * np.std(norm_obj2)\n    w1 = 0.5 + 0.3 * diversity\n    w2 = 1 - w1\n\n    scores = w1 * norm_obj1 + w2 * norm_obj2\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segments = [\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:d],\n            np.concatenate([new_solution[d:], new_solution[:a]])\n        ]\n\n        permutations = [\n            np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3]]),\n            np.concatenate([segments[0], segments[2], segments[1][::-1], segments[3]]),\n            np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3]]),\n            np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3][::-1]])\n        ]\n\n        best_perm = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n                best_perm = perm.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_perm.copy()\n\n        max_segments = min(4, n // 4)\n        segments = np.random.randint(1, max_segments + 1)\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(6, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(w1 * cost1 + w2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            9.512173441767725,
            3.9879078729822703
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that employs a novel 5-opt* move with dynamic segment reconfiguration and multi-objective aware cost balancing, using adaptive permutation strategies and Pareto-aware selection to explore constrained neighborhoods while ensuring feasibility through segment validation and cost thresholding.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        scores = []\n        for sol, (cost1, cost2) in archive:\n            score = (cost1 * 0.7 + cost2 * 0.3) * (1 + 0.2 * random.random())\n            scores.append(score)\n\n        selected_idx = np.argmin(scores)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_5opt_search(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(30):\n            a, b, c, d, e = sorted(random.sample(range(n), 5))\n            segments = [\n                solution[a:b],\n                solution[b:c],\n                solution[c:d],\n                solution[d:e],\n                np.concatenate([solution[e:], solution[:a]])\n            ]\n\n            permutations = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0][::-1], segments[1], segments[2][::-1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[2][::-1], segments[1], segments[3], segments[4][::-1]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2][::-1], segments[4]])\n            ]\n\n            for perm in permutations:\n                cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n\n                if (cost1 < best_cost1 * 1.05 and cost2 < best_cost2 * 1.05) or \\\n                   (cost1 < best_cost1 * 0.95 and cost2 <= best_cost2 * 1.1) or \\\n                   (cost2 < best_cost2 * 0.95 and cost1 <= best_cost1 * 1.1):\n                    best_solution = perm.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_5opt_search(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            4.861474705327149,
            6.997748414725789
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel multi-segment crossover with a dynamic path inversion strategy, using hybrid objective-aware selection and instance-adaptive segment merging to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_hybrid_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_hybrid_solution(archive)\n    new_solution = base_solution.copy()\n\n    def multi_segment_crossover(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(25):\n            num_segments = random.randint(2, 4)\n            segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n            segments = []\n            start = 0\n            for idx in segment_indices:\n                segments.append(solution[start:idx])\n                start = idx\n            segments.append(solution[start:])\n\n            random.shuffle(segments)\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate(segments)\n            else:\n                new_tour = np.concatenate([seg[::-1] if random.random() < 0.5 else seg for seg in segments])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.1 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.1 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = multi_segment_crossover(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            7.752388858052921,
            4.6043748603882095
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic path inversion strategy, using multi-objective aware selection and adaptive reversal to balance exploration and exploitation while ensuring feasibility through constrained path operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_promising_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n        return archive_sorted[selected_idx][0].copy()\n\n    base_solution = select_promising_solution(archive)\n    new_solution = base_solution.copy()\n\n    def dynamic_path_inversion(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            path1 = solution[a:b]\n            path2 = solution[b:c]\n            path3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([path1, path2[::-1], path3])\n            else:\n                new_tour = np.concatenate([path1[::-1], path2, path3[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.03 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.03 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_path_inversion(new_solution, distance_matrix_1, distance_matrix_2)\n    return new_solution\n\n",
        "score": [
            5.263845127795108,
            6.2474441344068525
        ]
    }
]