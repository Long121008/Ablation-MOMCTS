[
    {
        "algorithm": "{A hybrid local search algorithm that combines a modified 3-opt move with a biased random walk to explore the solution space, prioritizing non-dominated regions and dynamically adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Modified 3-opt with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):  # Number of iterations\n            # Randomly select three distinct segments\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            # Generate a new tour by reversing segments with probability\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions to escape local optima\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.365297097212141,
            5.7434965719181355
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic neighborhood exploration strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            5.933597847097488,
            6.499122446202933
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines a biased random walk with a dynamic segment reversal and insertion strategy to explore the solution space, prioritizing non-dominated solutions and adaptively adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Dynamic segment reversal and insertion with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):  # Increased number of iterations\n            # Randomly select two distinct segments\n            a, b = sorted(random.sample(range(n), 2))\n            segment1 = solution[a:b]\n            segment2 = np.concatenate([solution[b:], solution[:a]])\n\n            # Dynamic segment reversal and insertion\n            if random.random() < 0.7:  # Higher probability for reversal\n                new_tour = np.concatenate([segment1[::-1], segment2])\n            else:\n                # Random insertion of a segment\n                insert_pos = random.randint(0, len(segment2) - 1)\n                new_tour = np.concatenate([segment2[:insert_pos], segment1, segment2[insert_pos:]])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective or with higher probability\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Higher probability to accept worse solutions to escape local optima\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.31875918667774,
            5.913916233932454
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic segment reversal strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.106345483709433,
            6.279480048841997
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lexicographic ordering of objectives, then applies a novel path relinking approach that combines segment inversion with adaptive edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        start = np.random.randint(0, n // 3)\n        end = np.random.randint(start + 2, min(n, start + n // 3))\n        segment = new_solution[start:end]\n\n        if np.random.rand() < 0.8:\n            new_solution[start:end] = segment[::-1]\n\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n        if np.random.rand() < 0.3 and n >= 4:\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.132460775922828,
            10.453730271959436
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic node clustering approach with a biased edge relocation strategy, where nodes are grouped based on their combined objective costs, and edges are relocated to form clusters that minimize the total cost across both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on combined cost contribution\n    node_scores = np.zeros(n)\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        node_scores[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / (distance_matrix_1[u, v] + distance_matrix_2[u, v] + 1e-6)\n\n    # Identify nodes with high cost contribution\n    high_cost_nodes = np.argsort(node_scores)[-max(2, n//4):]\n\n    # Relocate high-cost nodes to new positions\n    for node_idx in high_cost_nodes:\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n):\n            # Try inserting after pos\n            temp_solution = np.insert(new_solution, pos, new_solution[node_idx])\n            temp_solution = np.delete(temp_solution, node_idx + (1 if node_idx > pos else 0))\n\n            # Calculate new cost\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, new_solution[node_idx])\n        new_solution = np.delete(new_solution, node_idx + (1 if node_idx > best_pos else 0))\n\n    return new_solution\n\n",
        "score": [
            6.138556990634729,
            6.325836965234252
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 3-opt with edge-swap\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Randomly swap two edges to introduce diversity\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.149417117853994,
            6.4820173028775
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on the sum of its objectives, then applies a hybrid local search operator that combines edge-swapping with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment inversion with edge swapping\n    n = len(new_solution)\n    if n < 4:\n        # If too small, perform a simple edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to invert\n        start = np.random.randint(0, n // 2)\n        end = np.random.randint(start + 2, min(n, start + n // 2))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Optionally swap some edges within the segment\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    return new_solution\n\n",
        "score": [
            7.411342874096885,
            6.190483383398926
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the lowest sum of objectives from the archive, then applies a novel hybrid local search that combines a k-opt move with a segment rotation strategy to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Apply hybrid local search: k-opt with segment rotation\n    n = len(new_solution)\n    if n < 5:\n        # For small instances, perform a simple edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select k random distinct positions\n        k = np.random.randint(3, min(6, n))\n        indices = sorted(np.random.choice(range(1, n), k, replace=False))\n\n        # Rotate segments between selected positions\n        segments = []\n        prev = 0\n        for idx in indices:\n            segments.append(new_solution[prev:idx])\n            prev = idx\n        segments.append(new_solution[prev:])\n\n        # Shuffle the segments\n        np.random.shuffle(segments)\n\n        # Reconstruct the tour\n        new_solution = np.concatenate(segments)\n\n        # Optionally rotate a segment clockwise\n        if np.random.rand() < 0.5:\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            segment = new_solution[start:end]\n            rotate_by = np.random.randint(1, len(segment))\n            new_solution[start:end] = np.roll(segment, rotate_by)\n\n    return new_solution\n\n",
        "score": [
            6.374573919445407,
            6.302996193304639
        ]
    },
    {
        "algorithm": "{This algorithm combines a dynamic segment reversal strategy with an adaptive edge exchange mechanism, where segments of varying lengths are reversed or exchanged based on their potential to improve both objectives, while dynamically adjusting the segment sizes based on the instance's characteristics and the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a combination of randomness and quality awareness\n    def select_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Calculate solution quality scores (inverse of sum of objectives)\n        scores = [1.0 / (sol[1][0] + sol[1][1] + 1e-10) for sol in archive]\n        total_score = sum(scores)\n        probabilities = [score / total_score for score in scores]\n\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_solution(archive)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal with adaptive segment sizes\n    def dynamic_segment_reversal(solution, distance_matrix_1, distance_matrix_2):\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        # Determine segment sizes based on instance characteristics\n        avg_distance1 = np.mean(distance_matrix_1)\n        avg_distance2 = np.mean(distance_matrix_2)\n        segment_size = max(2, min(5, int((avg_distance1 + avg_distance2) / 10)))\n\n        for _ in range(5):\n            # Randomly select a segment to reverse\n            start = random.randint(0, n - segment_size)\n            end = start + segment_size\n            segment = solution[start:end]\n\n            # Create a new solution by reversing the segment\n            new_tour = np.concatenate([solution[:start], segment[::-1], solution[end:]])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Accept if improvement in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = dynamic_segment_reversal(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Adaptive edge exchange mechanism\n    def edge_exchange(solution, distance_matrix_1, distance_matrix_2):\n        n = len(solution)\n        for _ in range(3):\n            # Select two random edges\n            a, b = sorted(random.sample(range(n), 2))\n\n            # Exchange the edges\n            new_tour = solution.copy()\n            new_tour[a], new_tour[b] = new_tour[b], new_tour[a]\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Accept if improvement in at least one objective\n            if (cost1 < sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))) or \\\n               (cost2 < sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))):\n                solution = new_tour.copy()\n\n        return solution\n\n    new_solution = edge_exchange(new_solution, distance_matrix_1, distance_matrix_2)\n\n    return new_solution\n\n",
        "score": [
            6.914092089826923,
            6.238891028204842
        ]
    }
]