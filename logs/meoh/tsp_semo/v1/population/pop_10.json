[
    {
        "algorithm": "{A hybrid local search algorithm that combines a modified 3-opt move with a biased random walk to explore the solution space, prioritizing non-dominated regions and dynamically adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Modified 3-opt with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(10):  # Number of iterations\n            # Randomly select three distinct segments\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            # Generate a new tour by reversing segments with probability\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Small probability to accept worse solutions to escape local optima\n                if random.random() < 0.1:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.365297097212141,
            5.7434965719181355
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, applies a hybrid edge-swapping strategy combined with a multi-segment relocation operator to generate a neighbor solution while ensuring feasibility, and incorporates an adaptive insertion heuristic that considers both objectives with dynamic weighting based on the solution's position in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs1 = np.array([x[1][0] for x in archive])\n    costs2 = np.array([x[1][1] for x in archive])\n    min1, max1 = np.min(costs1), np.max(costs1)\n    min2, max2 = np.min(costs2), np.max(costs2)\n    normalized = [(costs1[i] - min1)/(max1 - min1) + (costs2[i] - min2)/(max2 - min2) for i in range(len(archive))]\n    archive_sorted = sorted(zip(archive, normalized), key=lambda x: x[1])\n    base_solution = archive_sorted[0][0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic objective weighting based on archive position\n        weight1 = 0.5 + 0.5 * (1 - archive_sorted[0][1] / max(normalized))\n        weight2 = 1 - weight1\n\n        # Edge-swapping with dynamic objective weighting\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[a]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[a]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if weight1 * cost1 + weight2 * cost2 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Multi-segment relocation with dynamic objectives\n        segments = np.random.randint(1, min(3, n // 3))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(weight1 * cost1 + weight2 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            5.59059241667061,
            6.961812132846369
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a novel edge-swapping strategy combined with a multi-segment relocation operator to generate a neighbor solution while ensuring feasibility, and incorporates an adaptive insertion heuristic that considers both objectives to balance the search across the two spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-swapping with objective-aware selection\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1 and abs(a - b) < n - 1:\n            if np.random.random() < 0.7:\n                # Swap edges based on combined cost\n                cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if 0.7 * cost1 + 0.3 * cost2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Multi-segment relocation\n        segments = np.random.randint(1, min(3, n // 3))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            length = np.random.randint(2, min(5, n - start))\n            end = start + length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Find insertion point considering both objectives\n            insertion_costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node] -\n                         distance_matrix_2[prev_node, next_node])\n                insertion_costs.append(0.7 * cost1 + 0.3 * cost2)\n\n            insert_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.978108930531727,
            7.395425275936926
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic neighborhood exploration strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.6:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n            else:\n                new_tour = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            5.933597847097488,
            6.499122446202933
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility, and incorporates a novel node reinsertion strategy that considers both objective spaces to improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment reversal\n        segments = np.random.randint(1, min(4, n // 2))\n        for _ in range(segments):\n            start = np.random.randint(0, n // 2)\n            end = np.random.randint(start + 2, min(n, start + n // 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Objective-aware node reinsertion\n        if n > 4:\n            pos = np.random.randint(0, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n\n            # Calculate potential insertion positions considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i % len(new_solution)]\n                cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(0.5 * cost1 + 0.5 * cost2)\n\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.1602737475336315,
            5.775428940381621
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 4-opt* move with a dynamic segment rotation strategy, using Pareto-dominance aware selection and adaptive perturbation to balance exploration and exploitation while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_pareto_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_pareto_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_segment_rotation(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(20):\n            a, b, c, d = sorted(random.sample(range(n), 4))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = solution[c:d]\n            segment4 = np.concatenate([solution[d:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2, segment3[::-1], segment4])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3, segment4[::-1]])\n\n            if len(np.unique(new_tour)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 0.05 * best_cost2) or \\\n               (cost2 < best_cost2 and cost1 <= best_cost1 + 0.05 * best_cost1):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.15:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_segment_rotation(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.044143454174796,
            6.0181333464344675
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines a biased random walk with a dynamic segment reversal and insertion strategy to explore the solution space, prioritizing non-dominated solutions and adaptively adjusting the search based on the instance's characteristics to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with biased randomness towards non-dominated regions\n    def select_biased_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        # Rank solutions based on Pareto dominance\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_biased_solution(archive)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Dynamic segment reversal and insertion with biased random walk\n    def hybrid_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):  # Increased number of iterations\n            # Randomly select two distinct segments\n            a, b = sorted(random.sample(range(n), 2))\n            segment1 = solution[a:b]\n            segment2 = np.concatenate([solution[b:], solution[:a]])\n\n            # Dynamic segment reversal and insertion\n            if random.random() < 0.7:  # Higher probability for reversal\n                new_tour = np.concatenate([segment1[::-1], segment2])\n            else:\n                # Random insertion of a segment\n                insert_pos = random.randint(0, len(segment2) - 1)\n                new_tour = np.concatenate([segment2[:insert_pos], segment1, segment2[insert_pos:]])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            # Biased acceptance: accept if better in at least one objective or with higher probability\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                # Higher probability to accept worse solutions to escape local optima\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = hybrid_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.31875918667774,
            5.913916233932454
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the lexicographic ordering of objectives, then applies a novel path relinking approach that combines segment inversion with adaptive edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        start = np.random.randint(0, n // 3)\n        end = np.random.randint(start + 2, min(n, start + n // 3))\n        segment = new_solution[start:end]\n\n        if np.random.rand() < 0.8:\n            new_solution[start:end] = segment[::-1]\n\n        if np.random.rand() < 0.5 and len(segment) >= 2:\n            i, j = np.random.choice(len(segment), 2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n\n        if np.random.rand() < 0.3 and n >= 4:\n            a, b = np.random.choice(n, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.132460775922828,
            10.453730271959436
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with edge insertion\n        start = np.random.randint(0, n // 3)\n        end = np.random.randint(start + 2, min(n, start + n // 3))\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Insert a randomly selected node from elsewhere in the tour\n        if n > 4:\n            pos = np.random.randint(end, n)\n            node_to_insert = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            5.409315988911607,
            7.7830246934600416
        ]
    },
    {
        "algorithm": "{An adaptive local search algorithm that combines a novel 3-opt* move with a dynamic segment reversal strategy, using Pareto-based selection and instance-specific parameters to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def select_adaptive_solution(archive):\n        if len(archive) == 1:\n            return archive[0][0].copy()\n\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                       (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                        dominated[i] = True\n                        break\n\n        non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n        return archive[selected_idx][0].copy()\n\n    base_solution = select_adaptive_solution(archive)\n    new_solution = base_solution.copy()\n\n    def adaptive_local_search(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        best_solution = solution.copy()\n        best_cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n\n        for _ in range(15):\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = solution[a:b]\n            segment2 = solution[b:c]\n            segment3 = np.concatenate([solution[c:], solution[:a]])\n\n            if random.random() < 0.5:\n                new_tour = np.concatenate([segment1, segment2[::-1], segment3])\n            else:\n                new_tour = np.concatenate([segment1[::-1], segment2, segment3])\n\n            cost1 = sum(distance_matrix_1[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[new_tour[i], new_tour[(i+1)%n]] for i in range(n))\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_solution = new_tour.copy()\n                best_cost1 = cost1\n                best_cost2 = cost2\n            else:\n                if random.random() < 0.2:\n                    best_solution = new_tour.copy()\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        return best_solution\n\n    new_solution = adaptive_local_search(new_solution, distance_matrix_1, distance_matrix_2, instance)\n    return new_solution\n\n",
        "score": [
            6.106345483709433,
            6.279480048841997
        ]
    }
]