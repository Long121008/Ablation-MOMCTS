[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n",
        "score": [
            -0.6158084669605071,
            1.5382139682769775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n",
        "score": [
            -0.6158084669605071,
            1.5382139682769775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n",
        "score": [
            -0.6158084669605071,
            1.5382139682769775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7805746293775009,
            1.6026309132575989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7805746293775009,
            1.6026309132575989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A heuristic function that intelligently selects a promising solution from the archive, applies a novel hybrid local search operator combining node insertion and segment relocation, and ensures feasibility by validating the tour structure and distance calculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4768117132665879,
            1.3512842059135437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A heuristic function that intelligently selects a promising solution from the archive, applies a novel hybrid local search operator combining node insertion and segment relocation, and ensures feasibility by validating the tour structure and distance calculations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4768117132665879,
            1.3512842059135437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8579104384220748,
            0.5287096500396729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8579104384220748,
            0.5287096500396729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8579104384220748,
            0.5287096500396729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) - (sum(x[1]) * 0.1 * random.random())))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator: Adaptive Segment Shuffling\n    # Select a random segment and shuffle its nodes while maintaining feasibility\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end].copy()\n    random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    # Verify the solution remains feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original segment\n        new_solution[start:end] = selected_solution[start:end]\n\n    # Additional improvement: Apply a conditional swap if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate costs before and after swap\n    cost_before_1 = sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.828539552846033,
            1.8671666979789734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) - (sum(x[1]) * 0.1 * random.random())))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator: Adaptive Segment Shuffling\n    # Select a random segment and shuffle its nodes while maintaining feasibility\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end].copy()\n    random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    # Verify the solution remains feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original segment\n        new_solution[start:end] = selected_solution[start:end]\n\n    # Additional improvement: Apply a conditional swap if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate costs before and after swap\n    cost_before_1 = sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The new heuristic function selects a solution from the archive with a probability inversely proportional to its rank in the Pareto front, then applies a novel \"segment inversion and reinsertion\" local search that flips a random segment of the tour and reinserts it at a different position to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its rank in the Pareto front\n    pareto_front = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = random.choices(range(len(pareto_front)), weights=[1.0 / (1 + i) for i in range(len(pareto_front))])[0]\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment inversion and reinsertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.delete(new_solution, slice(i, j))\n    k = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, k, segment[::-1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8034637320222766,
            1.4257302284240723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its rank in the Pareto front\n    pareto_front = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = random.choices(range(len(pareto_front)), weights=[1.0 / (1 + i) for i in range(len(pareto_front))])[0]\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment inversion and reinsertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.delete(new_solution, slice(i, j))\n    k = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, k, segment[::-1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search that combines segment swapping with a dynamic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on weighted objective values and diversity\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment swapping with dynamic acceptance\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Swap segments to form a new cycle\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Dynamic acceptance: accept if either objective improves or with small probability\n    cost_before_1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    accept_prob = 0.1 if (cost_after_1 < cost_before_1 or cost_after_2 < cost_before_2) else 0.01\n    if random.random() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6918248514207808,
            3.2578699588775635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on weighted objective values and diversity\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment swapping with dynamic acceptance\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Swap segments to form a new cycle\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Dynamic acceptance: accept if either objective improves or with small probability\n    cost_before_1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    accept_prob = 0.1 if (cost_after_1 < cost_before_1 or cost_after_2 < cost_before_2) else 0.01\n    if random.random() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n",
        "score": [
            -0.86801465362076,
            2.8084232211112976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n",
        "score": [
            -0.86801465362076,
            2.8084232211112976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume contribution metric, then applies a hybrid local search combining a novel \"segment inversion\" operator with a probabilistic edge swapping mechanism to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        mask = np.ones(len(archive), dtype=bool)\n        mask[i] = False\n        dominated = (objectives[mask, 0] <= objectives[i, 0]) & (objectives[mask, 1] <= objectives[i, 1])\n        if not dominated.any():\n            contribution = np.prod(ref_point - objectives[i])\n        else:\n            contribution = 0\n        hv_contributions.append(contribution)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    n = len(new_solution)\n    if random.random() < 0.6:\n        # Segment inversion: reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Probabilistic edge swap\n        i = random.randint(0, n-2)\n        j = i + 1 if random.random() < 0.8 else random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7917052663597526,
            3.1525296568870544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        mask = np.ones(len(archive), dtype=bool)\n        mask[i] = False\n        dominated = (objectives[mask, 0] <= objectives[i, 0]) & (objectives[mask, 1] <= objectives[i, 1])\n        if not dominated.any():\n            contribution = np.prod(ref_point - objectives[i])\n        else:\n            contribution = 0\n        hv_contributions.append(contribution)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    n = len(new_solution)\n    if random.random() < 0.6:\n        # Segment inversion: reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Probabilistic edge swap\n        i = random.randint(0, n-2)\n        j = i + 1 if random.random() < 0.8 else random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer the first objective slightly more\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: hybrid of segment insertion and node swapping\n    # Step 1: Randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n\n    # Remove the segment and find the best insertion point\n    remaining = np.delete(new_solution, slice(a, b))\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the segment at position i\n        temp_solution = np.insert(remaining, i, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = weights[0] * cost1 + weights[1] * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.insert(remaining, best_insert_pos, segment)\n\n    # Step 2: Perform a node swap if it improves the solution\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    total_before = weights[0] * cost1_before + weights[1] * cost2_before\n\n    cost1_after = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n    cost2_after = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n    total_after = weights[0] * cost1_after + weights[1] * cost2_after\n\n    if total_after < total_before:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4879187684076867,
            12.353737890720367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Prefer the first objective slightly more\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: hybrid of segment insertion and node swapping\n    # Step 1: Randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n\n    # Remove the segment and find the best insertion point\n    remaining = np.delete(new_solution, slice(a, b))\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the segment at position i\n        temp_solution = np.insert(remaining, i, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = weights[0] * cost1 + weights[1] * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.insert(remaining, best_insert_pos, segment)\n\n    # Step 2: Perform a node swap if it improves the solution\n    i, j = random.sample(range(n), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    total_before = weights[0] * cost1_before + weights[1] * cost2_before\n\n    cost1_after = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n    cost2_after = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n    total_after = weights[0] * cost1_after + weights[1] * cost2_after\n\n    if total_after < total_before:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive, applies a hybrid local search combining edge swaps with a novel segment reversal, and ensures the solution remains feasible by verifying the cost improvement in both objectives before accepting the move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with a novel segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]  # Swap two edges\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n",
        "score": [
            -0.7726856218298623,
            2.6080010533332825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with a novel segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]  # Swap two edges\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.9690298067700512,
            11.808286845684052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.9690298067700512,
            11.808286845684052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted random choice favoring non-dominated solutions, then applies a hybrid local search combining segment reversal and node swapping with a probability-based acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its non-dominated status\n    objectives = [obj for _, obj in archive]\n    non_dominated = [1.0 if obj in objectives else 0.5 for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=non_dominated)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with probability 0.6, otherwise node swapping\n    if random.random() < 0.6:\n        # Segment reversal: flip a segment of the tour\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swapping: swap two nodes\n        n = len(new_solution)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8281229298625365,
            1.7861489057540894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its non-dominated status\n    objectives = [obj for _, obj in archive]\n    non_dominated = [1.0 if obj in objectives else 0.5 for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=non_dominated)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with probability 0.6, otherwise node swapping\n    if random.random() < 0.6:\n        # Segment reversal: flip a segment of the tour\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swapping: swap two nodes\n        n = len(new_solution)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The new algorithm combines a dynamic segment insertion strategy with a multi-objective-aware edge swapping mechanism to explore diverse neighborhoods while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    insert_pos = random.randint(0, n - (b - a))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n    new_solution = np.unique(new_solution)  # Ensure no duplicates\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform limited swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        cost_before_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n        cost_before_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Perform swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate cost after swap\n        cost_after_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n        cost_after_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Revert if swap doesn't improve both objectives\n        if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7618147969551953,
            1.250429928302765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    insert_pos = random.randint(0, n - (b - a))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n    new_solution = np.unique(new_solution)  # Ensure no duplicates\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform limited swaps\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        cost_before_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n        cost_before_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Perform swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate cost after swap\n        cost_after_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n        cost_after_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Revert if swap doesn't improve both objectives\n        if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution with the highest diversity in objective values from the archive, then applies a novel segment recombination and inversion operator to create a neighbor solution while ensuring feasibility through careful segment handling and validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct points\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Extract segments and invert one of them\n    segment = new_solution[a:b]\n    inverted_segment = segment[::-1]\n\n    # Create new solution by replacing the segment with its inversion\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If inversion caused duplicates, revert to original\n        new_solution = selected.copy()\n\n    # Apply a segment swap between two random positions\n    x, y = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[x:y]\n    z, w = sorted(random.sample(range(1, n-1), 2))\n    segment2 = new_solution[z:w]\n\n    # Swap segments if they don't overlap\n    if not (x < z < y or z < x < w):\n        new_solution = np.concatenate([\n            new_solution[:x], segment2, new_solution[y:z], segment1, new_solution[w:]\n        ])\n\n    # Final check for validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.35982551440802624,
            1.9572709798812866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct points\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Extract segments and invert one of them\n    segment = new_solution[a:b]\n    inverted_segment = segment[::-1]\n\n    # Create new solution by replacing the segment with its inversion\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If inversion caused duplicates, revert to original\n        new_solution = selected.copy()\n\n    # Apply a segment swap between two random positions\n    x, y = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[x:y]\n    z, w = sorted(random.sample(range(1, n-1), 2))\n    segment2 = new_solution[z:w]\n\n    # Swap segments if they don't overlap\n    if not (x < z < y or z < x < w):\n        new_solution = np.concatenate([\n            new_solution[:x], segment2, new_solution[y:z], segment1, new_solution[w:]\n        ])\n\n    # Final check for validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new heuristic function selects a promising solution from the archive based on a combination of dominance and diversity, then applies a hybrid local search that combines edge insertion and node relocation with a probability-based acceptance criterion to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a probability based on dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with probability 0.7, otherwise node relocation\n    if random.random() < 0.7:\n        # Edge insertion: randomly select two edges and insert a new edge between them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if i < k < j:\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = new_solution[j-1]\n            new_solution[j-1] = new_solution[k]\n    else:\n        # Node relocation: move a node to a different position\n        n = len(new_solution)\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines partial tour reversal with a probabilistic edge swap, ensuring feasibility by validating the resulting tour and reverting to the original if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability based on normalized objective values and diversity\n    objectives = [obj for _, obj in archive]\n    normalized_obj = np.array([(obj[0] / max(o[0] for o in objectives), obj[1] / max(o[1] for o in objectives)) for obj in objectives])\n    diversity_weights = [1.0 / (1 + np.sum(np.abs(normalized_obj[i] - normalized_obj))) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=diversity_weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: partial tour reversal with probabilistic edge swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse a segment of the tour\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistically swap two edges if it improves both objectives\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            # Calculate cost before swap\n            cost_before_1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            cost_before_2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            # Perform edge swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n            # Calculate cost after swap\n            cost_after_1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            cost_after_2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            # Revert if swap does not improve both objectives\n            if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8233321062916916,
            2.875241696834564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability based on normalized objective values and diversity\n    objectives = [obj for _, obj in archive]\n    normalized_obj = np.array([(obj[0] / max(o[0] for o in objectives), obj[1] / max(o[1] for o in objectives)) for obj in objectives])\n    diversity_weights = [1.0 / (1 + np.sum(np.abs(normalized_obj[i] - normalized_obj))) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=diversity_weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: partial tour reversal with probabilistic edge swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse a segment of the tour\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistically swap two edges if it improves both objectives\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            # Calculate cost before swap\n            cost_before_1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            cost_before_2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            # Perform edge swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n            # Calculate cost after swap\n            cost_after_1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            cost_after_2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n            # Revert if swap does not improve both objectives\n            if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A heuristic function that intelligently selects a promising solution from the archive, applies a novel hybrid local search operator combining node insertion and segment relocation, and ensures feasibility by validating the tour structure and distance calculations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (sum(x[1]) - (sum(x[1]) * 0.1 * random.random())))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator: Adaptive Segment Shuffling\n    # Select a random segment and shuffle its nodes while maintaining feasibility\n    segment_length = random.randint(2, min(5, n-1))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end].copy()\n    random.shuffle(segment)\n    new_solution[start:end] = segment\n\n    # Verify the solution remains feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original segment\n        new_solution[start:end] = selected_solution[start:end]\n\n    # Additional improvement: Apply a conditional swap if it improves both objectives\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate costs before and after swap\n    cost_before_1 = sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A heuristic function that selects a solution from the archive based on a combination of objective values and diversity, then applies a novel multi-segment relocation strategy that intelligently reorders and redistributes segments of the tour to improve both objectives while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: balance between objective quality and diversity\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    selected_solution = archive[selected_idx][0].copy()\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment relocation strategy\n        num_segments = random.randint(2, min(3, n//3))\n        segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n\n        # Create segments and shuffle their order\n        segments = []\n        current_pos = 0\n        for length in segment_lengths:\n            segments.append(new_solution[current_pos:current_pos+length])\n            current_pos += length\n        if current_pos < n:\n            segments.append(new_solution[current_pos:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Additional refinement: conditional segment reversal\n        for _ in range(2):\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            segment = new_solution[seg_start:seg_end+1]\n\n            # Calculate cost before reversal\n            cost_before_1 = (distance_matrix_1[new_solution[seg_start-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n            cost_before_2 = (distance_matrix_2[new_solution[seg_start-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n\n            # Calculate cost after reversal\n            reversed_segment = segment[::-1]\n            cost_after_1 = (distance_matrix_1[new_solution[seg_start-1], reversed_segment[0]] +\n                          distance_matrix_1[reversed_segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n            cost_after_2 = (distance_matrix_2[new_solution[seg_start-1], reversed_segment[0]] +\n                          distance_matrix_2[reversed_segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n\n            # Apply reversal if it improves both objectives\n            if (cost_after_1 < cost_before_1) and (cost_after_2 < cost_before_2):\n                new_solution[seg_start:seg_end+1] = reversed_segment\n\n    # Final validation\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8027217261625402,
            2.2807631492614746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: balance between objective quality and diversity\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    selected_solution = archive[selected_idx][0].copy()\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Multi-segment relocation strategy\n        num_segments = random.randint(2, min(3, n//3))\n        segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n\n        # Create segments and shuffle their order\n        segments = []\n        current_pos = 0\n        for length in segment_lengths:\n            segments.append(new_solution[current_pos:current_pos+length])\n            current_pos += length\n        if current_pos < n:\n            segments.append(new_solution[current_pos:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Additional refinement: conditional segment reversal\n        for _ in range(2):\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            segment = new_solution[seg_start:seg_end+1]\n\n            # Calculate cost before reversal\n            cost_before_1 = (distance_matrix_1[new_solution[seg_start-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n            cost_before_2 = (distance_matrix_2[new_solution[seg_start-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n\n            # Calculate cost after reversal\n            reversed_segment = segment[::-1]\n            cost_after_1 = (distance_matrix_1[new_solution[seg_start-1], reversed_segment[0]] +\n                          distance_matrix_1[reversed_segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n            cost_after_2 = (distance_matrix_2[new_solution[seg_start-1], reversed_segment[0]] +\n                          distance_matrix_2[reversed_segment[-1], new_solution[seg_end+1 if seg_end+1 < n else 0]])\n\n            # Apply reversal if it improves both objectives\n            if (cost_after_1 < cost_before_1) and (cost_after_2 < cost_before_2):\n                new_solution[seg_start:seg_end+1] = reversed_segment\n\n    # Final validation\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap segments to form a new cycle)\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n    # Novel segment reversal: reverse a random segment if it improves both objectives\n    l = random.randint(0, n-1)\n    m = random.randint(l, n-1)\n    segment = new_solution[l:m].copy()\n\n    # Calculate cost before and after reversal\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution[l:m] = segment[::-1]  # Reverse the segment\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if reversal does not improve both objectives\n    if (cost_after_1 >= cost_before_1) or (cost_after_2 >= cost_before_2):\n        new_solution[l:m] = segment  # Revert the reversal\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8935419396249074,
            0.6696915626525879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A new algorithm that employs a weighted sum approach with adaptive segment reversal to prioritize solutions with balanced objective improvements, then applies a multi-objective cost-aware segment insertion and reversal to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.6 * x[0] + 0.4 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.9088569034096855,
            11.371811985969543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.6 * x[0] + 0.4 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{An innovative adaptive multi-objective tour fragmentation and reassembly algorithm that dynamically partitions tours into variable-length segments based on local cost gradients in both objectives, then intelligently recombines them using a Pareto-optimal insertion strategy while preserving feasibility and exploring diverse trade-offs between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        # Check if current node has significantly different gradients than previous\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.3 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.3 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                # Try inserting segment at position i\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                # Ensure no duplicates and valid tour\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    # Calculate costs\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    # Check if this is Pareto-dominant\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            # Remove any potential duplicates (shouldn't happen due to earlier check)\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.9546481743292845,
            14.898779451847076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        # Check if current node has significantly different gradients than previous\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.3 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.3 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                # Try inserting segment at position i\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                # Ensure no duplicates and valid tour\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    # Calculate costs\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    # Check if this is Pareto-dominant\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            # Remove any potential duplicates (shouldn't happen due to earlier check)\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Randomly select another segment and insert it into a new position\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    # Apply a random 2-opt move if it improves at least one objective\n    i, j = sorted(random.sample(range(n), 2))\n    temp = new_solution[i:j+1].copy()\n    new_solution[i:j+1] = temp[::-1]\n\n    # Calculate cost before and after 2-opt\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    cost_before = calculate_cost(selected)\n    cost_after = calculate_cost(new_solution)\n\n    # Revert if 2-opt does not improve at least one objective\n    if (cost_after[0] >= cost_before[0] and cost_after[1] >= cost_before[1]):\n        new_solution[i:j+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.3911745840101974,
            2.818456709384918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Randomly select another segment and insert it into a new position\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    # Apply a random 2-opt move if it improves at least one objective\n    i, j = sorted(random.sample(range(n), 2))\n    temp = new_solution[i:j+1].copy()\n    new_solution[i:j+1] = temp[::-1]\n\n    # Calculate cost before and after 2-opt\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    cost_before = calculate_cost(selected)\n    cost_after = calculate_cost(new_solution)\n\n    # Revert if 2-opt does not improve at least one objective\n    if (cost_after[0] >= cost_before[0] and cost_after[1] >= cost_before[1]):\n        new_solution[i:j+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a random 2-opt move if it improves at least one objective\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j:\n        temp = new_solution[i:j+1].copy()\n        new_solution[i:j+1] = temp[::-1]\n\n        # Calculate cost before and after 2-opt\n        cost_before_1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        cost_after_1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n\n        cost_before_2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        cost_after_2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Revert if 2-opt does not improve at least one objective\n        if (cost_after_1 >= cost_before_1 and cost_after_2 >= cost_before_2):\n            new_solution[i:j+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.3427348103663066,
            2.5903208255767822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a random 2-opt move if it improves at least one objective\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j:\n        temp = new_solution[i:j+1].copy()\n        new_solution[i:j+1] = temp[::-1]\n\n        # Calculate cost before and after 2-opt\n        cost_before_1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        cost_after_1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n\n        cost_before_2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        cost_after_2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Revert if 2-opt does not improve at least one objective\n        if (cost_after_1 >= cost_before_1 and cost_after_2 >= cost_before_2):\n            new_solution[i:j+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A heuristic function that intelligently selects a promising solution from the archive, applies a novel hybrid local search operator combining node insertion and segment relocation, and ensures feasibility by validating the tour structure and distance calculations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a multi-segment crossover with adaptive segment sizes to generate a neighbor solution while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments-1))\n    segments = np.split(new_solution, segment_indices)\n\n    # Randomly shuffle segments\n    random.shuffle(segments)\n\n    # Reconstruct solution with shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment mutation: randomly reverse a segment\n    if random.random() < 0.3:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9651982890626335,
            2.4333435893058777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments-1))\n    segments = np.split(new_solution, segment_indices)\n\n    # Randomly shuffle segments\n    random.shuffle(segments)\n\n    # Reconstruct solution with shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment mutation: randomly reverse a segment\n    if random.random() < 0.3:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A heuristic function that intelligently selects a promising solution from the archive, applies a novel hybrid local search operator combining node insertion and segment relocation, and ensures feasibility by validating the tour structure and distance calculations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or with low objective values)\n    selected_solution = None\n    min_sum = float('inf')\n    for sol, obj in archive:\n        if sum(obj) < min_sum:\n            min_sum = sum(obj)\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Node insertion + segment relocation\n    n = len(base_solution)\n    if n < 4:\n        # Swap two random nodes if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node insertion: Remove a node and reinsert it at a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation: Move a segment of nodes to a different position\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-2)\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A heuristic function that intelligently selects a solution from the archive based on a novel scoring mechanism combining objective values and solution diversity, then applies a hybrid local search operator combining edge exchange and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on normalized objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())\n        diversity = len(set(sol)) / len(sol)\n        scores.append((sum(norm_obj) * diversity, sol))\n\n    # Select the solution with the highest score\n    selected_solution = max(scores, key=lambda x: x[0])[1].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Edge exchange + segment inversion\n    n = len(base_solution)\n    if n < 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange: Swap two edges\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion: Reverse a segment of nodes\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution is valid\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.822963525558746,
            7.751120507717133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on normalized objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())\n        diversity = len(set(sol)) / len(sol)\n        scores.append((sum(norm_obj) * diversity, sol))\n\n    # Select the solution with the highest score\n    selected_solution = max(scores, key=lambda x: x[0])[1].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Edge exchange + segment inversion\n    n = len(base_solution)\n    if n < 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange: Swap two edges\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion: Reverse a segment of nodes\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution is valid\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9330612739967166,
            0.7468093633651733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that employs a weighted sum approach with adaptive segment reversal to prioritize solutions with balanced objective improvements, then applies a multi-objective cost-aware segment insertion and reversal to explore diverse neighborhoods while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.6 * x[0] + 0.4 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9820087883189353,
            0.9952595829963684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that employs a weighted sum approach with adaptive segment reversal to prioritize solutions with balanced objective improvements, then applies a multi-objective cost-aware segment insertion and reversal to explore diverse neighborhoods while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.6 * x[0] + 0.4 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9820087883189353,
            0.9952595829963684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel approach that combines adaptive segment inversion with Pareto-aware segment reinsertion to generate diverse neighbor solutions while balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    k = random.randint(2, n//3)\n    start = random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    new_solution[start:start+k] = segment[::-1]\n\n    # Pareto-aware segment reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure solution remains valid\n    _, idx = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.8762683711285398,
            1.877911627292633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    k = random.randint(2, n//3)\n    start = random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    new_solution[start:start+k] = segment[::-1]\n\n    # Pareto-aware segment reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure solution remains valid\n    _, idx = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on its objective balance and applies a multi-stage local search combining adaptive segment reversal with cost-sensitive edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Stage 1: Adaptive segment reversal\n    segment_size = random.randint(2, min(8, n//3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Stage 2: Cost-sensitive edge swaps\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Calculate current and swapped costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for d in duplicates:\n            pos = np.where(new_solution == d)[0][0]\n            new_solution[pos] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.38916451020741616,
            1.1940993070602417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Stage 1: Adaptive segment reversal\n    segment_size = random.randint(2, min(8, n//3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Stage 2: Cost-sensitive edge swaps\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Calculate current and swapped costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for d in duplicates:\n            pos = np.where(new_solution == d)[0][0]\n            new_solution[pos] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An innovative adaptive multi-objective tour fragmentation and reassembly algorithm that dynamically partitions tours into variable-length segments based on local cost gradients in both objectives, then intelligently recombines them using a Pareto-optimal insertion strategy while preserving feasibility and exploring diverse trade-offs between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        # Check if current node has significantly different gradients than previous\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.3 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.3 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                # Try inserting segment at position i\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                # Ensure no duplicates and valid tour\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    # Calculate costs\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    # Check if this is Pareto-dominant\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            # Remove any potential duplicates (shouldn't happen due to earlier check)\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{An adaptive multi-objective tour segmentation and hybrid recombination algorithm that dynamically partitions tours into variable-length segments based on both local cost gradients and segment diversity, then intelligently recombines them using a hybrid of segment swapping and cost-aware insertion while maintaining feasibility and exploring diverse trade-offs between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment diversity scores\n    segment_scores = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        segment_scores.append(abs(cost1 - cost2))\n\n    # Identify diverse segments\n    threshold = np.mean(segment_scores) + np.std(segment_scores)\n    diverse_indices = [i for i, score in enumerate(segment_scores) if score > threshold]\n\n    if len(diverse_indices) > 1:\n        # Select two diverse segments\n        seg1, seg2 = random.sample(diverse_indices, 2)\n\n        # Determine segment lengths\n        len1 = random.randint(1, min(5, n//2))\n        len2 = random.randint(1, min(5, n//2))\n\n        # Extract segments\n        segment1 = new_solution[seg1:seg1+len1]\n        segment2 = new_solution[seg2:seg2+len2]\n\n        # Perform hybrid recombination\n        if random.random() < 0.5:\n            # Segment swap\n            new_solution = np.concatenate([\n                new_solution[:seg1],\n                segment2,\n                new_solution[seg1+len1:seg2],\n                segment1,\n                new_solution[seg2+len2:]\n            ])\n        else:\n            # Cost-aware insertion\n            insertion_point = random.randint(0, n-1)\n            new_solution = np.concatenate([\n                new_solution[:insertion_point],\n                segment1,\n                new_solution[insertion_point:]\n            ])\n\n        # Remove duplicates and ensure validity\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.5047952838737723,
            4.390296101570129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment diversity scores\n    segment_scores = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        segment_scores.append(abs(cost1 - cost2))\n\n    # Identify diverse segments\n    threshold = np.mean(segment_scores) + np.std(segment_scores)\n    diverse_indices = [i for i, score in enumerate(segment_scores) if score > threshold]\n\n    if len(diverse_indices) > 1:\n        # Select two diverse segments\n        seg1, seg2 = random.sample(diverse_indices, 2)\n\n        # Determine segment lengths\n        len1 = random.randint(1, min(5, n//2))\n        len2 = random.randint(1, min(5, n//2))\n\n        # Extract segments\n        segment1 = new_solution[seg1:seg1+len1]\n        segment2 = new_solution[seg2:seg2+len2]\n\n        # Perform hybrid recombination\n        if random.random() < 0.5:\n            # Segment swap\n            new_solution = np.concatenate([\n                new_solution[:seg1],\n                segment2,\n                new_solution[seg1+len1:seg2],\n                segment1,\n                new_solution[seg2+len2:]\n            ])\n        else:\n            # Cost-aware insertion\n            insertion_point = random.randint(0, n-1)\n            new_solution = np.concatenate([\n                new_solution[:insertion_point],\n                segment1,\n                new_solution[insertion_point:]\n            ])\n\n        # Remove duplicates and ensure validity\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform a segment inversion to create diversity\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a swap between two random nodes if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_after_1 >= cost_before_1 and cost_after_2 >= cost_before_2):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.6119071045208062,
            2.642130136489868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform a segment inversion to create diversity\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a swap between two random nodes if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_after_1 >= cost_before_1 and cost_after_2 >= cost_before_2):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The new algorithm combines adaptive segment reversal with multi-objective cost-aware insertion, where segments are reversed and inserted at positions that show promise in improving both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n    reversed_segment = segment[::-1]\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], reversed_segment, candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.5071343848239382,
            13.731519997119904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n    reversed_segment = segment[::-1]\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], reversed_segment, candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A new algorithm that combines dynamic segment reversal with a multi-objective cost-balanced segment relocation to explore diverse neighborhoods while maintaining feasibility and improving both objectives through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Reverse the segment for exploration\n    segment = segment[::-1]\n\n    # Find optimal insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting reversed segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates while preserving order\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select candidate that balances both objectives\n        best_candidate = min(candidates, key=lambda x: (x[0] + x[1]) / (1 + 0.5 * abs(x[0] - x[1])))\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.5574931481836405,
            14.196560144424438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Reverse the segment for exploration\n    segment = segment[::-1]\n\n    # Find optimal insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting reversed segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates while preserving order\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select candidate that balances both objectives\n        best_candidate = min(candidates, key=lambda x: (x[0] + x[1]) / (1 + 0.5 * abs(x[0] - x[1])))\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.790056666163302,
            0.4132969379425049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment rotation with objective-aware segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    k = random.randint(1, n//2)\n    rotation = new_solution[:k]\n    new_solution = np.concatenate([new_solution[k:], rotation])\n\n    # Objective-aware segment swap\n    i, j = sorted(random.sample(range(n), 2))\n    segment_a = new_solution[i:j]\n    segment_b = new_solution[j:]\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    new_solution = np.concatenate([new_solution[:i], segment_b, segment_a])\n\n    cost_after_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_after_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap doesn't improve both objectives\n    if (cost_after_1 >= cost_before_1) and (cost_after_2 >= cost_before_2):\n        new_solution = np.concatenate([new_solution[:i], segment_a, segment_b])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.790056666163302,
            0.4132969379425049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that employs a weighted sum approach with adaptive segment reversal to prioritize solutions with balanced objective improvements, then applies a multi-objective cost-aware segment insertion and reversal to explore diverse neighborhoods while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 3, random.randint(2, n // 3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.6 * x[0] + 0.4 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A new algorithm that employs a Pareto-based selection with adaptive segment reversal and insertion, prioritizing solutions with balanced objective improvements, then applies a multi-objective cost-aware segment insertion and reversal to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 2, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.5 * x[0] + 0.5 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.9128760157527465,
            10.976493954658508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    segment_length = max(2, min(n // 2, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment[::-1], candidate[i+1:]))\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        best_candidate = min(candidates, key=lambda x: 0.5 * x[0] + 0.5 * x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal and swap\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Swap nodes\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9609965161614321,
            2.6321102380752563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal and swap\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Swap nodes\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a multi-segment crossover with adaptive segment sizes to generate a neighbor solution while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments-1))\n    segments = np.split(new_solution, segment_indices)\n\n    # Randomly shuffle segments\n    random.shuffle(segments)\n\n    # Reconstruct solution with shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment mutation: randomly reverse a segment\n    if random.random() < 0.3:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel approach that combines adaptive segment inversion with Pareto-aware segment reinsertion to generate diverse neighbor solutions while balancing exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    k = random.randint(2, n//3)\n    start = random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    new_solution[start:start+k] = segment[::-1]\n\n    # Pareto-aware segment reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure solution remains valid\n    _, idx = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on its non-dominated status in both objectives, then applies a hybrid of adaptive edge-swapping and node-cluster perturbation to generate a neighbor solution while maintaining feasibility and exploring the solution space through both local and global perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive edge-swapping with distance-aware selection\n    for _ in range(random.randint(1, n//4)):\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate edge lengths in both objectives\n        edge1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        edge1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        edge2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Swap if it improves both objectives or maintains feasibility\n        if (edge1_after < edge1_before and edge2_after < edge2_before) or random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node-cluster perturbation with adaptive size\n    k = random.randint(1, n//3)\n    start = random.randint(0, n - k)\n    cluster = new_solution[start:start+k]\n\n    # Calculate cluster's total distance in both objectives\n    cluster_dist1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%k]] for i in range(k))\n    cluster_dist2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%k]] for i in range(k))\n\n    # Randomly reorder the cluster\n    permuted_cluster = np.random.permutation(cluster)\n    new_cluster_dist1 = sum(distance_matrix_1[permuted_cluster[i], permuted_cluster[(i+1)%k]] for i in range(k))\n    new_cluster_dist2 = sum(distance_matrix_2[permuted_cluster[i], permuted_cluster[(i+1)%k]] for i in range(k))\n\n    # Apply perturbation if it improves both objectives or maintains feasibility\n    if (new_cluster_dist1 <= cluster_dist1 and new_cluster_dist2 <= cluster_dist2) or random.random() < 0.2:\n        new_solution[start:start+k] = permuted_cluster\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7795505312950484,
            2.5392603278160095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive edge-swapping with distance-aware selection\n    for _ in range(random.randint(1, n//4)):\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate edge lengths in both objectives\n        edge1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        edge1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        edge2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Swap if it improves both objectives or maintains feasibility\n        if (edge1_after < edge1_before and edge2_after < edge2_before) or random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node-cluster perturbation with adaptive size\n    k = random.randint(1, n//3)\n    start = random.randint(0, n - k)\n    cluster = new_solution[start:start+k]\n\n    # Calculate cluster's total distance in both objectives\n    cluster_dist1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%k]] for i in range(k))\n    cluster_dist2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%k]] for i in range(k))\n\n    # Randomly reorder the cluster\n    permuted_cluster = np.random.permutation(cluster)\n    new_cluster_dist1 = sum(distance_matrix_1[permuted_cluster[i], permuted_cluster[(i+1)%k]] for i in range(k))\n    new_cluster_dist2 = sum(distance_matrix_2[permuted_cluster[i], permuted_cluster[(i+1)%k]] for i in range(k))\n\n    # Apply perturbation if it improves both objectives or maintains feasibility\n    if (new_cluster_dist1 <= cluster_dist1 and new_cluster_dist2 <= cluster_dist2) or random.random() < 0.2:\n        new_solution[start:start+k] = permuted_cluster\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance, applies a combination of segment reversal and node displacement to create a neighbor solution while ensuring feasibility through careful node validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Reverse the segment\n\n    # Insert reversed segment at a new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-2, 2)\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Remove duplicates and repair solution\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    # Node displacement with validation\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Validate and repair if invalid\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()\n            i, j = random.sample(range(1, n-1), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9129994486368067,
            1.4506052732467651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Reverse the segment\n\n    # Insert reversed segment at a new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-2, 2)\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Remove duplicates and repair solution\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    # Node displacement with validation\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Validate and repair if invalid\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()\n            i, j = random.sample(range(1, n-1), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a novel combination of segment rotation and guided node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive angle\n    rotation_size = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - rotation_size)\n    end = start + rotation_size\n    rotation_angle = random.choice([1, -1])\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation_angle)\n\n    # Guided node relocation based on objective improvement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate cost change for both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Apply relocation if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Final check for feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4023988275884301,
            2.2950069904327393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive angle\n    rotation_size = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - rotation_size)\n    end = start + rotation_size\n    rotation_angle = random.choice([1, -1])\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation_angle)\n\n    # Guided node relocation based on objective improvement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate cost change for both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Apply relocation if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Final check for feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that combines adaptive segment swapping with a multi-objective cost-aware segment insertion to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on distance matrices\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Calculate potential insertion points\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            # Try inserting segment after i\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], segment, candidate[i+1:]))\n            # Remove duplicates (keep first occurrence)\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select the candidate that improves both objectives most\n        best_candidate = min(candidates, key=lambda x: x[0] + x[1])\n        new_solution = best_candidate[2]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{A new algorithm that combines adaptive segment selection with multi-objective cost-aware segment reversal to explore diverse neighborhoods while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n\n    # Try inserting reversed segment at different positions\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], reversed_segment, candidate[i+1:]))\n            # Remove duplicates\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select candidate that improves at least one objective\n        improved = [c for c in candidates if (c[0] < archive[0][1][0] and c[1] < archive[0][1][1]) or\n                   (c[0] <= archive[0][1][0] and c[1] <= archive[0][1][1])]\n        if improved:\n            best_candidate = min(improved, key=lambda x: max(x[0], x[1]))\n            new_solution = best_candidate[2]\n\n    return new_solution\n\n",
        "score": [
            -0.9088063857414043,
            11.164174735546112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n\n    # Try inserting reversed segment at different positions\n    candidates = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            candidate = new_solution.copy()\n            candidate = np.concatenate((candidate[:i+1], reversed_segment, candidate[i+1:]))\n            # Remove duplicates\n            _, idx = np.unique(candidate, return_index=True)\n            candidate = candidate[np.sort(idx)]\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n            candidates.append((cost1, cost2, candidate))\n\n    if candidates:\n        # Select candidate that improves at least one objective\n        improved = [c for c in candidates if (c[0] < archive[0][1][0] and c[1] < archive[0][1][1]) or\n                   (c[0] <= archive[0][1][0] and c[1] <= archive[0][1][1])]\n        if improved:\n            best_candidate = min(improved, key=lambda x: max(x[0], x[1]))\n            new_solution = best_candidate[2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An innovative adaptive multi-objective tour fragmentation and reassembly algorithm that dynamically partitions tours into variable-length segments based on local cost gradients in both objectives, then intelligently recombines them using a Pareto-optimal insertion strategy while preserving feasibility and exploring diverse trade-offs between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        # Check if current node has significantly different gradients than previous\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.3 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.3 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                # Try inserting segment at position i\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                # Ensure no duplicates and valid tour\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    # Calculate costs\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    # Check if this is Pareto-dominant\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            # Remove any potential duplicates (shouldn't happen due to earlier check)\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{An adaptive multi-objective tour segmentation and reassembly algorithm that dynamically partitions tours into variable-length segments based on local cost gradients in both objectives, then intelligently recombines them using a Pareto-optimal insertion strategy while preserving feasibility and exploring diverse trade-offs between the two objectives, with a novel selection criterion that prioritizes solutions with balanced improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.5 * abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients with adjusted threshold\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.2 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.2 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move with probability based on segment size\n        seg_idx = random.choices(range(len(segments)), weights=[len(seg) for seg in segments])[0]\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.8843620315489135,
            14.808998465538025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.5 * abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for both objectives\n    cost_gradients = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        grad1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        grad2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        cost_gradients.append((grad1, grad2))\n\n    # Identify critical segments based on cost gradients with adjusted threshold\n    segments = []\n    current_segment = [0]\n    for i in range(1, n):\n        prev_grad = cost_gradients[i-1]\n        curr_grad = cost_gradients[i]\n        if (abs(curr_grad[0] - prev_grad[0]) > 0.2 * max(prev_grad[0], 1e-6) or\n            abs(curr_grad[1] - prev_grad[1]) > 0.2 * max(prev_grad[1], 1e-6)):\n            segments.append(current_segment)\n            current_segment = [i]\n        else:\n            current_segment.append(i)\n    segments.append(current_segment)\n\n    # Recombine segments using Pareto-optimal insertion\n    if len(segments) > 1:\n        # Select a random segment to move with probability based on segment size\n        seg_idx = random.choices(range(len(segments)), weights=[len(seg) for seg in segments])[0]\n        segment = new_solution[segments[seg_idx]].copy()\n\n        # Find best insertion point that maintains Pareto optimality\n        best_pos = -1\n        best_costs = (float('inf'), float('inf'))\n        for i in range(n):\n            if i not in segments[seg_idx]:\n                candidate = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])\n\n                unique, counts = np.unique(candidate, return_counts=True)\n                if len(unique) == n:\n                    cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                    if (cost1 <= best_costs[0] and cost2 < best_costs[1]) or (cost1 < best_costs[0] and cost2 <= best_costs[1]):\n                        best_pos = i\n                        best_costs = (cost1, cost2)\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            _, idx = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8965930235532539,
            0.4897574186325073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{An algorithm that combines multi-objective solution merging with adaptive segment inversion and diversity-preserving local search to create high-quality neighbors by intelligently inverting and recombining segments from promising solutions while ensuring feasibility and maintaining solution diversity through a hybrid of segment manipulation and objective-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])[:3]\n\n    # Create base solution by combining segments with adaptive inversion\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(3, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions and optionally invert segments\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n\n        # 40% chance to invert the segment\n        if random.random() < 0.4:\n            segment = segment[::-1]\n\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform diversity-preserving local search\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        # Select two random segments and swap or merge them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Create two possible options\n        option1 = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n        option2 = np.concatenate([new_solution[:a], segment1, segment2, new_solution[b:]])\n\n        # Evaluate both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select better option with 60% chance, or random otherwise\n        if random.random() < 0.6:\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:\n            new_solution = random.choice([option1, option2])\n\n        # Apply small perturbation to maintain diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    new_solution = np.array(new_solution[:n])\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.8488321416757588,
            3.0469276309013367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.4 * x[1][0] + 0.6 * x[1][1])[:3]\n\n    # Create base solution by combining segments with adaptive inversion\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(3, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions and optionally invert segments\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n\n        # 40% chance to invert the segment\n        if random.random() < 0.4:\n            segment = segment[::-1]\n\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform diversity-preserving local search\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        # Select two random segments and swap or merge them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Create two possible options\n        option1 = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n        option2 = np.concatenate([new_solution[:a], segment1, segment2, new_solution[b:]])\n\n        # Evaluate both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select better option with 60% chance, or random otherwise\n        if random.random() < 0.6:\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:\n            new_solution = random.choice([option1, option2])\n\n        # Apply small perturbation to maintain diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    new_solution = np.array(new_solution[:n])\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment rotation and adaptive node replacement to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with adaptive length\n    segment_length = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Apply adaptive node replacement\n    for _ in range(3):\n        pos = random.randint(0, n-1)\n        available_nodes = [node for node in range(n) if node not in new_solution]\n        if available_nodes:\n            new_solution[pos] = random.choice(available_nodes)\n\n    # Apply conditional 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    temp = new_solution.copy()\n    temp[i:j+1] = temp[i:j+1][::-1]\n    temp[j:k+1] = temp[j:k+1][::-1]\n\n    # Calculate cost before and after 3-opt\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n)) + distance_matrix_1[temp[-1], temp[0]]\n    cost_after_2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n)) + distance_matrix_2[temp[-1], temp[0]]\n\n    # Accept if at least one objective improves\n    if (cost_after_1 < cost_before_1) or (cost_after_2 < cost_before_2):\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7548531521975704,
            3.5388389825820923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment rotation with adaptive length\n    segment_length = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Apply adaptive node replacement\n    for _ in range(3):\n        pos = random.randint(0, n-1)\n        available_nodes = [node for node in range(n) if node not in new_solution]\n        if available_nodes:\n            new_solution[pos] = random.choice(available_nodes)\n\n    # Apply conditional 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    temp = new_solution.copy()\n    temp[i:j+1] = temp[i:j+1][::-1]\n    temp[j:k+1] = temp[j:k+1][::-1]\n\n    # Calculate cost before and after 3-opt\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    cost_after_1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n)) + distance_matrix_1[temp[-1], temp[0]]\n    cost_after_2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n)) + distance_matrix_2[temp[-1], temp[0]]\n\n    # Accept if at least one objective improves\n    if (cost_after_1 < cost_before_1) or (cost_after_2 < cost_before_2):\n        new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{A novel heuristic that prioritizes solutions with balanced objective values, then employs a dynamic segment inversion and adaptive segment relocation strategy with enhanced diversity through probabilistic segment selection and adaptive insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]) / (min(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with probabilistic selection\n    seg_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - seg_length)\n    j = i + seg_length\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation with probabilistic insertion\n    if random.random() < 0.7:\n        k = random.randint(0, n - seg_length)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6911339795287454,
            0.6066933870315552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]) / (min(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with probabilistic selection\n    seg_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - seg_length)\n    j = i + seg_length\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation with probabilistic insertion\n    if random.random() < 0.7:\n        k = random.randint(0, n - seg_length)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Extract segments and create a new tour by combining them\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    # Create a new solution by inserting segment2 into segment1\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Remove duplicate nodes and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure the solution remains a valid tour\n    new_solution = new_solution[:n]\n\n    # Apply a random swap if it improves at least one objective\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a combination of adaptive segment relocation and conditional node swapping to generate a neighbor while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove segment and insert at a different position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Conditional node swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Calculate costs\n        cost_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        cost_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Revert if no improvement in either objective\n        if cost_1 >= sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(n)) + distance_matrix_1[selected[-1], selected[0]] and \\\n           cost_2 >= sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(n)) + distance_matrix_2[selected[-1], selected[0]]:\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5054759088925124,
            3.0270824432373047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(4, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Remove segment and insert at a different position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Conditional node swapping\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Calculate costs\n        cost_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        cost_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Revert if no improvement in either objective\n        if cost_1 >= sum(distance_matrix_1[selected[i-1], selected[i]] for i in range(n)) + distance_matrix_1[selected[-1], selected[0]] and \\\n           cost_2 >= sum(distance_matrix_2[selected[i-1], selected[i]] for i in range(n)) + distance_matrix_2[selected[-1], selected[0]]:\n            new_solution[j] = new_solution[i]\n            new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0149212130116105,
            0.1944912075996399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0149212130116105,
            0.1944912075996399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0149212130116105,
            0.1944912075996399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution with the highest objective dominance (better in both objectives) from the archive and applies a novel hybrid local search combining multi-segment inversion with adaptive node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = random.randint(1, 3)\n    segments = sorted(random.sample(range(1, n-1), num_segments))\n    segments.append(n-1)\n\n    for i in range(num_segments):\n        start = segments[i]\n        end = segments[i+1]\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node swapping\n    swap_prob = min(0.5, 2/n)\n    for i in range(1, n-1):\n        if random.random() < swap_prob:\n            j = random.randint(1, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7452620005681786,
            2.2290247678756714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = random.randint(1, 3)\n    segments = sorted(random.sample(range(1, n-1), num_segments))\n    segments.append(n-1)\n\n    for i in range(num_segments):\n        start = segments[i]\n        end = segments[i+1]\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node swapping\n    swap_prob = min(0.5, 2/n)\n    for i in range(1, n-1):\n        if random.random() < swap_prob:\n            j = random.randint(1, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution with the highest combined cost from the archive and applies a novel hybrid local search combining adaptive segment reversal with probabilistic node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness through careful segment manipulation and validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    seg_length = random.randint(2, min(5, n//3))\n    start = random.randint(1, n - seg_length - 1)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation\n    if random.random() < 0.3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8487985418177959,
            2.076915979385376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    seg_length = random.randint(2, min(5, n//3))\n    start = random.randint(1, n - seg_length - 1)\n    segment = new_solution[start:start+seg_length]\n    new_solution[start:start+seg_length] = segment[::-1]\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation\n    if random.random() < 0.3:\n        seg_start = random.randint(1, n-2)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A new algorithm that employs a dynamic cluster-based perturbation approach, where nodes are grouped based on their spatial proximity in both objective spaces, then applies a novel cluster-shuffling mechanism that preserves local structures while introducing global diversification, ensuring feasibility through a multi-stage validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    n = len(selected)\n\n    # Create clusters based on spatial proximity in both objective spaces\n    clusters = []\n    remaining_nodes = set(range(n))\n    cluster_size = max(2, n // 5)\n\n    while remaining_nodes:\n        # Select a random starting node\n        start_node = random.choice(list(remaining_nodes))\n        cluster = [start_node]\n        remaining_nodes.remove(start_node)\n\n        # Expand cluster based on proximity in both spaces\n        while len(cluster) < cluster_size and remaining_nodes:\n            last_node = cluster[-1]\n            # Find the closest node in both spaces\n            candidates = []\n            for node in remaining_nodes:\n                dist1 = distance_matrix_1[last_node, node]\n                dist2 = distance_matrix_2[last_node, node]\n                combined_dist = dist1 + dist2\n                candidates.append((combined_dist, node))\n\n            if not candidates:\n                break\n\n            # Select the closest node\n            closest_node = min(candidates, key=lambda x: x[0])[1]\n            cluster.append(closest_node)\n            remaining_nodes.remove(closest_node)\n\n        clusters.append(cluster)\n\n    # Shuffle clusters with a bias towards maintaining relative order\n    shuffled_clusters = clusters.copy()\n    if len(shuffled_clusters) > 1:\n        # Randomly select a subset of clusters to shuffle\n        num_to_shuffle = random.randint(1, len(shuffled_clusters)-1)\n        indices = random.sample(range(len(shuffled_clusters)), num_to_shuffle)\n        # Shuffle the selected clusters\n        selected_clusters = [shuffled_clusters[i] for i in indices]\n        random.shuffle(selected_clusters)\n        for i, idx in enumerate(indices):\n            shuffled_clusters[idx] = selected_clusters[i]\n\n    # Reconstruct the solution from shuffled clusters\n    new_solution = []\n    for cluster in shuffled_clusters:\n        # Randomly decide whether to reverse the cluster\n        if random.random() < 0.3:\n            cluster = cluster[::-1]\n        new_solution.extend(cluster)\n\n    # Validate and fix any missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8661805235433064,
            4.671001732349396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    n = len(selected)\n\n    # Create clusters based on spatial proximity in both objective spaces\n    clusters = []\n    remaining_nodes = set(range(n))\n    cluster_size = max(2, n // 5)\n\n    while remaining_nodes:\n        # Select a random starting node\n        start_node = random.choice(list(remaining_nodes))\n        cluster = [start_node]\n        remaining_nodes.remove(start_node)\n\n        # Expand cluster based on proximity in both spaces\n        while len(cluster) < cluster_size and remaining_nodes:\n            last_node = cluster[-1]\n            # Find the closest node in both spaces\n            candidates = []\n            for node in remaining_nodes:\n                dist1 = distance_matrix_1[last_node, node]\n                dist2 = distance_matrix_2[last_node, node]\n                combined_dist = dist1 + dist2\n                candidates.append((combined_dist, node))\n\n            if not candidates:\n                break\n\n            # Select the closest node\n            closest_node = min(candidates, key=lambda x: x[0])[1]\n            cluster.append(closest_node)\n            remaining_nodes.remove(closest_node)\n\n        clusters.append(cluster)\n\n    # Shuffle clusters with a bias towards maintaining relative order\n    shuffled_clusters = clusters.copy()\n    if len(shuffled_clusters) > 1:\n        # Randomly select a subset of clusters to shuffle\n        num_to_shuffle = random.randint(1, len(shuffled_clusters)-1)\n        indices = random.sample(range(len(shuffled_clusters)), num_to_shuffle)\n        # Shuffle the selected clusters\n        selected_clusters = [shuffled_clusters[i] for i in indices]\n        random.shuffle(selected_clusters)\n        for i, idx in enumerate(indices):\n            shuffled_clusters[idx] = selected_clusters[i]\n\n    # Reconstruct the solution from shuffled clusters\n    new_solution = []\n    for cluster in shuffled_clusters:\n        # Randomly decide whether to reverse the cluster\n        if random.random() < 0.3:\n            cluster = cluster[::-1]\n        new_solution.extend(cluster)\n\n    # Validate and fix any missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm selects a solution with the highest combined objective value from the archive and applies a hybrid local search combining adaptive segment reversal with probabilistic edge swapping, ensuring feasibility through careful node validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n//3))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validity check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.bincount(new_solution) > 1)[0]]\n        for d in duplicates:\n            pos = np.where(new_solution == d)[0][1]\n            new_solution[pos] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9067012370125411,
            2.3108906149864197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n//3))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validity check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.bincount(new_solution) > 1)[0]]\n        for d in duplicates:\n            pos = np.where(new_solution == d)[0][1]\n            new_solution[pos] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The new algorithm selects a solution from the archive based on its objective diversity, then applies a novel hybrid local search combining segment relocations with a probabilistic node relocation strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment relocation with probabilistic node relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Relocate segment to a new position\n    new_solution = np.delete(new_solution, np.arange(a, b))\n    pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Probabilistic node relocation\n    if random.random() < 0.4:\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.42359176312396496,
            2.4893030524253845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment relocation with probabilistic node relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Relocate segment to a new position\n    new_solution = np.delete(new_solution, np.arange(a, b))\n    pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Probabilistic node relocation\n    if random.random() < 0.4:\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance, applies a combination of segment reversal and node displacement to create a neighbor solution while ensuring feasibility through careful node validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Reverse the segment\n\n    # Insert reversed segment at a new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-2, 2)\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Remove duplicates and repair solution\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    # Node displacement with validation\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Validate and repair if invalid\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()\n            i, j = random.sample(range(1, n-1), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance, applies a hybrid of segment inversion and node swapping with position-based displacement to create a neighbor solution while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion and node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Invert the segment\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]  # Ensure solution length\n\n    # Node swapping with position-based displacement\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, j + displacement))\n        new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.977511328658982,
            0.7744144201278687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion and node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Invert the segment\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]  # Ensure solution length\n\n    # Node swapping with position-based displacement\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, j + displacement))\n        new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a multi-segment crossover with adaptive segment sizes to generate a neighbor solution while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments-1))\n    segments = np.split(new_solution, segment_indices)\n\n    # Randomly shuffle segments\n    random.shuffle(segments)\n\n    # Reconstruct solution with shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment mutation: randomly reverse a segment\n    if random.random() < 0.3:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a dynamic segment inversion and adaptive multi-objective node insertion to generate a neighbor solution while maintaining feasibility and exploring the solution space more effectively by strategically inverting segments and inserting nodes based on their multi-objective potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with adaptive segment sizes\n    num_inversions = random.randint(1, min(3, n//4))\n    for _ in range(num_inversions):\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Adaptive multi-objective node insertion\n    if random.random() < 0.4:\n        # Select nodes with high potential for improvement\n        potential_nodes = []\n        for i in range(n):\n            # Calculate potential improvement by moving this node\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            # Try inserting at a different position\n            new_pos = random.randint(0, n-1)\n            if new_pos != i and new_pos != (i-1)%n and new_pos != (i+1)%n:\n                new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(new_pos+1)%n]] +\n                            distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]])\n                new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[(new_pos+1)%n]] +\n                            distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]])\n\n                # Calculate potential improvement in both objectives\n                improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n                potential_nodes.append((improvement, i, new_pos))\n\n        # Sort by potential improvement and select top candidates\n        potential_nodes.sort(reverse=True, key=lambda x: x[0])\n        for _, node_idx, new_pos in potential_nodes[:2]:  # Try top 2 candidates\n            # Perform the insertion\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.906285549241747,
            2.6638245582580566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with adaptive segment sizes\n    num_inversions = random.randint(1, min(3, n//4))\n    for _ in range(num_inversions):\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Adaptive multi-objective node insertion\n    if random.random() < 0.4:\n        # Select nodes with high potential for improvement\n        potential_nodes = []\n        for i in range(n):\n            # Calculate potential improvement by moving this node\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            # Try inserting at a different position\n            new_pos = random.randint(0, n-1)\n            if new_pos != i and new_pos != (i-1)%n and new_pos != (i+1)%n:\n                new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[(new_pos+1)%n]] +\n                            distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]])\n                new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[(new_pos+1)%n]] +\n                            distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]])\n\n                # Calculate potential improvement in both objectives\n                improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n                potential_nodes.append((improvement, i, new_pos))\n\n        # Sort by potential improvement and select top candidates\n        potential_nodes.sort(reverse=True, key=lambda x: x[0])\n        for _, node_idx, new_pos in potential_nodes[:2]:  # Try top 2 candidates\n            # Perform the insertion\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation with dynamic node clustering to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9910892716648734,
            2.598303735256195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{A novel algorithm that combines adaptive segment relocations with probabilistic segment reversals to generate high-quality neighbor solutions while ensuring feasibility through dynamic segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n    if random.random() > 0.5:\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8941658402519242,
            0.5794638991355896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() > 0.5:\n        segment1 = segment1[::-1]\n    if random.random() > 0.5:\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a multi-segment crossover with adaptive segment sizes to generate a neighbor solution while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good balance between objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments-1))\n    segments = np.split(new_solution, segment_indices)\n\n    # Randomly shuffle segments\n    random.shuffle(segments)\n\n    # Reconstruct solution with shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment mutation: randomly reverse a segment\n    if random.random() < 0.3:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This new algorithm selects a solution from the archive based on its balance between objectives, then applies a dynamic segment insertion and rotation operator to create a neighbor solution while maintaining feasibility and exploring the solution space more effectively by combining segment manipulation with rotational adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion and rotation\n    seg_length = random.randint(2, min(5, n//2))\n    seg_start = random.randint(0, n - seg_length)\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n    # Rotate the segment\n    rotation = random.randint(1, seg_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Insert the rotated segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9138317184399773,
            1.5166214108467102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion and rotation\n    seg_length = random.randint(2, min(5, n//2))\n    seg_start = random.randint(0, n - seg_length)\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n    # Rotate the segment\n    rotation = random.randint(1, seg_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Insert the rotated segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with dynamic segment realignment to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by prioritizing solutions with balanced objective values and applying adaptive segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        if k < len(new_solution):\n            new_solution = np.insert(new_solution, k, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6649883000285817,
            1.628280520439148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        if k < len(new_solution):\n            new_solution = np.insert(new_solution, k, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution with the highest objective dominance (one objective significantly better than the other) from the archive and applies a novel hybrid local search combining adaptive segment inversion with probabilistic edge swapping, ensuring feasibility by maintaining tour completeness and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    inverted_segment = segment[::-1]\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8683960541457288,
            0.6934306621551514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    inverted_segment = segment[::-1]\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel adaptive hybrid local search algorithm that selects solutions with high objective diversity, applies a combination of dynamic segment inversion, probabilistic node reinsertion, and objective-aware edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with probabilistic length\n    segment_length = random.randint(2, min(7, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Objective-aware edge swap\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve both objectives\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) and \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.47598126042101235,
            1.156379222869873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion with probabilistic length\n    segment_length = random.randint(2, min(7, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Objective-aware edge swap\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve both objectives\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) and \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel algorithm that selects solutions from the archive based on a weighted combination of objective values, then applies a hybrid operation combining adaptive segment reversal with conditional node relocations to generate high-quality neighbors while ensuring feasibility through dynamic validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    segment_length = min(3, n//3) if random.random() < 0.7 else random.randint(2, n//2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Conditional node relocation based on distance improvement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate cost delta for both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            # Apply relocation if beneficial to at least one objective\n            if delta1 < 0 or delta2 < 0:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.914445814857362,
            1.703064203262329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    segment_length = min(3, n//3) if random.random() < 0.7 else random.randint(2, n//2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Conditional node relocation based on distance improvement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate cost delta for both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            # Apply relocation if beneficial to at least one objective\n            if delta1 < 0 or delta2 < 0:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining adaptive segment inversion with probabilistic node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness through careful validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (abs(x[1][0] - x[1][1]) + (1/(x[1][0] + x[1][1] + 1e-6))))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    inverted_segment = segment[::-1]\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9574881738990477,
            0.7642303705215454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (abs(x[1][0] - x[1][1]) + (1/(x[1][0] + x[1][1] + 1e-6))))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    inverted_segment = segment[::-1]\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking with a weighted score function to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(3):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.6:  # 60% chance to prefer balanced improvement\n            if (0.7 * cost1[0] + 0.3 * cost1[1]) < (0.7 * cost2[0] + 0.3 * cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 40% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.909746586636325,
            1.2715041041374207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(3):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.6:  # 60% chance to prefer balanced improvement\n            if (0.7 * cost1[0] + 0.3 * cost1[1]) < (0.7 * cost2[0] + 0.3 * cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 40% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on its objective balance and applies a hybrid local search combining dynamic segment reversal with adaptive node swapping to generate diverse neighbors while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Adaptive node swapping\n    swap_positions = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n    else:\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional random perturbation\n    if random.random() < 0.2:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.9011754372094747,
            1.936993658542633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Adaptive node swapping\n    swap_positions = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n    else:\n        new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    # Ensure validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional random perturbation\n    if random.random() < 0.2:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on its objective diversity and applies a hybrid local search combining segment swaps with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with probabilistic node insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Insert segment at a new random position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates and append missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure validity\n    new_solution = new_solution[:n]\n\n    # Probabilistic node insertion: insert a random node at a random position\n    if random.random() < 0.3:\n        node = random.choice(np.setdiff1d(np.arange(n), new_solution))\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on its dominance in both objectives, then applies a dynamic segment inversion and adaptive node reinsertion strategy to create high-quality neighbors while maintaining feasibility through a multi-phase local search process that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment inversion\n    k = random.randint(2, min(5, n//2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    for i in range(len(segments)):\n        if random.random() < 0.4:\n            segments[i] = segments[i][::-1]  # Invert segment with 40% probability\n    new_solution = np.concatenate(segments)\n\n    # Phase 2: Adaptive node reinsertion\n    for _ in range(2):  # Perform multiple reinsertions\n        # Select a random node and remove it\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on multi-objective improvement\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(n-1):\n            # Create temporary solution\n            temp_sol = np.insert(new_solution, pos, node)\n\n            # Calculate cost difference\n            cost1 = (distance_matrix_1[temp_sol[pos-1], node] + distance_matrix_1[node, temp_sol[pos+1]] -\n                    distance_matrix_1[temp_sol[pos-1], temp_sol[pos+1]])\n            cost2 = (distance_matrix_2[temp_sol[pos-1], node] + distance_matrix_2[node, temp_sol[pos+1]] -\n                    distance_matrix_2[temp_sol[pos-1], temp_sol[pos+1]])\n\n            improvement = -cost1 - cost2  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure solution is valid (all nodes present exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(new_solution) - set(range(n))\n        for e in extra:\n            idx = np.where(new_solution == e)[0][0]\n            new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.7641638303079173,
            5.656062483787537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment inversion\n    k = random.randint(2, min(5, n//2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    for i in range(len(segments)):\n        if random.random() < 0.4:\n            segments[i] = segments[i][::-1]  # Invert segment with 40% probability\n    new_solution = np.concatenate(segments)\n\n    # Phase 2: Adaptive node reinsertion\n    for _ in range(2):  # Perform multiple reinsertions\n        # Select a random node and remove it\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on multi-objective improvement\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(n-1):\n            # Create temporary solution\n            temp_sol = np.insert(new_solution, pos, node)\n\n            # Calculate cost difference\n            cost1 = (distance_matrix_1[temp_sol[pos-1], node] + distance_matrix_1[node, temp_sol[pos+1]] -\n                    distance_matrix_1[temp_sol[pos-1], temp_sol[pos+1]])\n            cost2 = (distance_matrix_2[temp_sol[pos-1], node] + distance_matrix_2[node, temp_sol[pos+1]] -\n                    distance_matrix_2[temp_sol[pos-1], temp_sol[pos+1]])\n\n            improvement = -cost1 - cost2  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure solution is valid (all nodes present exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(new_solution) - set(range(n))\n        for e in extra:\n            idx = np.where(new_solution == e)[0][0]\n            new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with adaptive segment insertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by dynamically adjusting segment positions based on objective-specific distance metrics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8844388674883363,
            0.24216419458389282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive and applies a novel hybrid local search combining dynamic segment shuffling with adaptive node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness through a multi-phase validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment shuffling\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    random.shuffle(segment)\n    new_solution[i:j] = segment\n\n    # Adaptive node swapping\n    swap_pairs = random.sample(range(1, n-1), min(3, n-2))\n    for idx in swap_pairs:\n        if random.random() < 0.5:\n            new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n\n    # Multi-phase validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Objective-aware adjustment\n    if random.random() < 0.3:\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        if obj1 > obj2:\n            new_solution = new_solution[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6062046723939615,
            1.3572952151298523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment shuffling\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    random.shuffle(segment)\n    new_solution[i:j] = segment\n\n    # Adaptive node swapping\n    swap_pairs = random.sample(range(1, n-1), min(3, n-2))\n    for idx in swap_pairs:\n        if random.random() < 0.5:\n            new_solution[idx], new_solution[idx+1] = new_solution[idx+1], new_solution[idx]\n\n    # Multi-phase validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Objective-aware adjustment\n    if random.random() < 0.3:\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        if obj1 > obj2:\n            new_solution = new_solution[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{A novel algorithm that combines adaptive segment insertion with dynamic segment reversal to generate high-quality neighbor solutions by intelligently selecting and modifying segments of the tour while ensuring feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select segments and modify them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Reverse a segment and insert it at a different position\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], reversed_segment])\n\n    # Insert the reversed segment at a new position\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k:]])\n\n    # Ensure all nodes are present and unique\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Randomly swap two nodes to add more diversity\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9718986345331427,
            0.41606342792510986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select segments and modify them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Reverse a segment and insert it at a different position\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], reversed_segment])\n\n    # Insert the reversed segment at a new position\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k:]])\n\n    # Ensure all nodes are present and unique\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Randomly swap two nodes to add more diversity\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with dynamic segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selectively inverting and repositioning segments based on their contribution to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.410266374029613,
            1.2279987931251526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{A novel algorithm that combines adaptive segment inversion with multi-objective-aware edge insertion to dynamically balance exploration and exploitation while ensuring feasibility through probabilistic node repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.random() * 0.1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(n//2, int(random.expovariate(1.0))))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n            if random.random() < 0.7 * (1 - (cost1 + cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())):\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Probabilistic node repair\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9790403429373999,
            0.512920081615448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.random() * 0.1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(n//2, int(random.expovariate(1.0))))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n            if random.random() < 0.7 * (1 - (cost1 + cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())):\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Probabilistic node repair\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective dominance, applies a hybrid of segment inversion and node swapping with position-based displacement to create a neighbor solution while ensuring feasibility through validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion and node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Invert the segment\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]  # Ensure solution length\n\n    # Node swapping with position-based displacement\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, j + displacement))\n        new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure, then applies a novel hybrid local search combining adaptive segment transposition with dynamic node relocation, ensuring feasibility through a multi-stage validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + np.std(np.diff(x[0]))))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment transposition\n    segment_length = random.randint(2, min(6, n//3))\n    start = random.randint(1, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Dynamic node relocation\n    if random.random() < 0.6:\n        target_pos = random.randint(1, n - segment_length - 1)\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:target_pos],\n            segment,\n            new_solution[target_pos:]\n        ])\n\n    # Multi-stage validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, np.unique(new_solution))\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    # Additional structural refinement\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i+1]] < \\\n           distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j-1]][new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7037942140952572,
            7.502459168434143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + np.std(np.diff(x[0]))))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment transposition\n    segment_length = random.randint(2, min(6, n//3))\n    start = random.randint(1, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Dynamic node relocation\n    if random.random() < 0.6:\n        target_pos = random.randint(1, n - segment_length - 1)\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:target_pos],\n            segment,\n            new_solution[target_pos:]\n        ])\n\n    # Multi-stage validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, np.unique(new_solution))\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    # Additional structural refinement\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i+1]] < \\\n           distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j-1]][new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective dominance, applies a hybrid of segment inversion and node swapping with position-based displacement to create a neighbor solution while ensuring feasibility through validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion and node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Invert the segment\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]  # Ensure solution length\n\n    # Node swapping with position-based displacement\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, j + displacement))\n        new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -1.0181288627242264,
            0.33770620822906494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective dominance, applies a hybrid of segment inversion and node swapping with position-based displacement to create a neighbor solution while ensuring feasibility through validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion and node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Invert the segment\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]  # Ensure solution length\n\n    # Node swapping with position-based displacement\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, j + displacement))\n        new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -1.0181288627242264,
            0.33770620822906494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest objective diversity from the archive and applies a novel hybrid local search combining adaptive segment rotation with probabilistic node reinsertion, ensuring feasibility by maintaining tour completeness and node uniqueness.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Rotate segment by k positions\n    rotated_segment = np.roll(segment, k)\n\n    # Insert rotated segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node = new_solution[random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This new algorithm selects a solution with the highest combined objective value from the archive and applies a novel hybrid local search combining dynamic segment inversion with adaptive node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness while exploring both objective spaces through a multi-objective aware segment manipulation approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Invert segment with probability based on objective values\n    if random.random() < 0.6:  # Higher probability for more significant changes\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Adaptive node swapping based on multi-objective consideration\n    for _ in range(2):  # Perform multiple swaps\n        i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate potential costs before and after swap\n        def get_costs(sol):\n            cost1 = distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[j], sol[j+1]]\n            cost2 = distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[i], sol[i+1]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[j], sol[j+1]]\n            return cost1, cost2\n\n        original_costs = get_costs(new_solution)\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n        swapped_costs = get_costs(swapped_solution)\n\n        # Accept swap if it improves at least one objective\n        if (swapped_costs[0] < original_costs[0] or swapped_costs[1] < original_costs[1]) and random.random() < 0.8:\n            new_solution = swapped_solution\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Reinsert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8917982871241596,
            2.0872273445129395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Invert segment with probability based on objective values\n    if random.random() < 0.6:  # Higher probability for more significant changes\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Adaptive node swapping based on multi-objective consideration\n    for _ in range(2):  # Perform multiple swaps\n        i, j = sorted(random.sample(range(1, n-1), 2))\n\n        # Calculate potential costs before and after swap\n        def get_costs(sol):\n            cost1 = distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[j], sol[j+1]]\n            cost2 = distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[i], sol[i+1]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[j], sol[j+1]]\n            return cost1, cost2\n\n        original_costs = get_costs(new_solution)\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n        swapped_costs = get_costs(swapped_solution)\n\n        # Accept swap if it improves at least one objective\n        if (swapped_costs[0] < original_costs[0] or swapped_costs[1] < original_costs[1]) and random.random() < 0.8:\n            new_solution = swapped_solution\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Reinsert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining adaptive segment inversion with probabilistic node swapping, ensuring feasibility by maintaining tour completeness and node uniqueness through careful validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (abs(x[1][0] - x[1][1]) + (1/(x[1][0] + x[1][1] + 1e-6))))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    inverted_segment = segment[::-1]\n\n    # Insert inverted segment at a new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and objective dominance, then applies a combination of adaptive route fragmentation and probabilistic edge insertion, ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -abs(x[1][0] - x[1][1])))\n    selected = archive_sorted[len(archive)//2][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive route fragmentation\n    k = random.randint(2, min(5, n//2))\n    split_points = sorted(random.sample(range(1, n-1), k-1))\n    fragments = [new_solution[i:j] for i, j in zip([0]+split_points, split_points+[n])]\n\n    # Probabilistic edge insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        fragments.insert(random.randint(0, len(fragments)), new_solution[i:j])\n\n    # Reconstruct solution\n    new_solution = np.concatenate(fragments)\n\n    # Feasibility check and repair\n    missing = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing) > 0:\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:pos], missing, new_solution[pos:]])\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.8786382092397209,
            1.2892364859580994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -abs(x[1][0] - x[1][1])))\n    selected = archive_sorted[len(archive)//2][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive route fragmentation\n    k = random.randint(2, min(5, n//2))\n    split_points = sorted(random.sample(range(1, n-1), k-1))\n    fragments = [new_solution[i:j] for i, j in zip([0]+split_points, split_points+[n])]\n\n    # Probabilistic edge insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        fragments.insert(random.randint(0, len(fragments)), new_solution[i:j])\n\n    # Reconstruct solution\n    new_solution = np.concatenate(fragments)\n\n    # Feasibility check and repair\n    missing = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing) > 0:\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:pos], missing, new_solution[pos:]])\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment inversion with adaptive segment insertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by dynamically adjusting segment positions based on objective-specific distance metrics.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel algorithm that combines a hybrid segment reversal with adaptive segment relocation to generate diverse neighbor solutions while maintaining feasibility by dynamically adjusting segment positions based on objective-specific distance metrics and ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9210572213351281,
            0.396016001701355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance score (combination of normalized objective values) and applies a hybrid of multi-segment relocation with adaptive displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    dominance_scores = np.sum(normalized, axis=1)\n\n    # Select solution with lowest dominance score (most balanced)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Insert segments at new positions with displacement\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-min(2, pos1-1), min(2, n-pos1-1))\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-min(2, pos2-1), min(2, n-pos2-1))\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    # Apply segment relocations\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    # Node reallocation\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7445070304447434,
            0.3367574214935303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    dominance_scores = np.sum(normalized, axis=1)\n\n    # Select solution with lowest dominance score (most balanced)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Insert segments at new positions with displacement\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-min(2, pos1-1), min(2, n-pos1-1))\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-min(2, pos2-1), min(2, n-pos2-1))\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    # Apply segment relocations\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    # Node reallocation\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive using a novel objective-based ranking that combines normalized costs and diversity measures, then applies a hybrid local search that intelligently combines segment rotation with adaptive node swapping to explore the solution space while maintaining feasibility through a multi-tiered validation and repair system.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    if max_cost1 == 0 or max_cost2 == 0:\n        selected = archive[0][0].copy()\n    else:\n        def score(x):\n            norm1 = x[1][0] / max_cost1\n            norm2 = x[1][1] / max_cost2\n            return (norm1 + norm2) * (1 - abs(norm1 - norm2))\n        selected = max(archive, key=score)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.roll(segment, rotation)\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n        if (cost_diff1 <= 0 and cost_diff2 <= 0) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-tiered repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.in1d(new_solution, unique_nodes, invert=True))[0]]\n        for i, m in enumerate(missing):\n            if i < len(duplicates):\n                idx = np.where(new_solution == duplicates[i])[0][0]\n                new_solution[idx] = m\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([new_solution, missing])\n            new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9124672498069809,
            0.6366618275642395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    if max_cost1 == 0 or max_cost2 == 0:\n        selected = archive[0][0].copy()\n    else:\n        def score(x):\n            norm1 = x[1][0] / max_cost1\n            norm2 = x[1][1] / max_cost2\n            return (norm1 + norm2) * (1 - abs(norm1 - norm2))\n        selected = max(archive, key=score)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.roll(segment, rotation)\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n        if (cost_diff1 <= 0 and cost_diff2 <= 0) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-tiered repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.in1d(new_solution, unique_nodes, invert=True))[0]]\n        for i, m in enumerate(missing):\n            if i < len(duplicates):\n                idx = np.where(new_solution == duplicates[i])[0][0]\n                new_solution[idx] = m\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([new_solution, missing])\n            new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel approach that combines a dynamic segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Adaptive segment relocation\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel approach that dynamically combines a probabilistic segment inversion with a guided segment relocation to generate high-quality neighbor solutions while maintaining feasibility and exploring the solution space adaptively based on the current archive's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / np.max([y[1][0] for y in archive])) + (x[1][1] / np.max([y[1][1] for y in archive])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.7:  # Higher probability for inversion\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Guided segment relocation based on distance matrices\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        # Relocate segment to position that minimizes both objectives\n        best_pos = k\n        min_cost = float('inf')\n        for pos in range(max(0, k-2), min(n, k+3)):  # Check nearby positions\n            temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7651697950892006,
            11.189325332641602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / np.max([y[1][0] for y in archive])) + (x[1][1] / np.max([y[1][1] for y in archive])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.7:  # Higher probability for inversion\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Guided segment relocation based on distance matrices\n    k = random.randint(0, n-1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        # Relocate segment to position that minimizes both objectives\n        best_pos = k\n        min_cost = float('inf')\n        for pos in range(max(0, k-2), min(n, k+3)):  # Check nearby positions\n            temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with adaptive segment relocation and dynamic segment merging to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select random segments and perform inversion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Select another random segment and relocate it\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Adaptive segment relocation based on distance matrices\n    if random.random() < 0.5:\n        # Find the most distant node in the segment\n        max_dist = -1\n        best_pos = -1\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                continue\n            dist1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            dist2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_dist = dist1 + dist2\n            if total_dist > max_dist:\n                max_dist = total_dist\n                best_pos = pos\n        if best_pos != -1:\n            # Relocate the segment to the position with maximum distance\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic segment merging\n    if random.random() < 0.3:\n        m, o = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[m:o]\n        p, q = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[p:q]\n        merged_segment = np.concatenate([segment1, segment2])\n        new_solution = np.concatenate([new_solution[:m], merged_segment, new_solution[o:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8176808833402498,
            0.6519905924797058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select random segments and perform inversion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Select another random segment and relocate it\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Adaptive segment relocation based on distance matrices\n    if random.random() < 0.5:\n        # Find the most distant node in the segment\n        max_dist = -1\n        best_pos = -1\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                continue\n            dist1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            dist2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_dist = dist1 + dist2\n            if total_dist > max_dist:\n                max_dist = total_dist\n                best_pos = pos\n        if best_pos != -1:\n            # Relocate the segment to the position with maximum distance\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic segment merging\n    if random.random() < 0.3:\n        m, o = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[m:o]\n        p, q = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[p:q]\n        merged_segment = np.concatenate([segment1, segment2])\n        new_solution = np.concatenate([new_solution[:m], merged_segment, new_solution[o:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment reversal with adaptive segment relocation to generate diverse neighbor solutions while maintaining feasibility by dynamically adjusting segment positions based on objective-specific distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective diversity and solution structure, then applies a hybrid of adaptive segment insertion with probabilistic node swapping and dynamic segment merging to generate high-quality neighbors while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + (x[1][0] + x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n-segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    insert_pos = random.randint(0, n-segment_size)\n    while abs(insert_pos - start) < segment_size:\n        insert_pos = random.randint(0, n-segment_size)\n\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment merging\n    if random.random() < 0.3 and n > 6:\n        merge_pos = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:merge_pos], new_solution[merge_pos+1:]])\n\n    # Comprehensive repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8608996487870567,
            1.0280388593673706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + (x[1][0] + x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n-segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    insert_pos = random.randint(0, n-segment_size)\n    while abs(insert_pos - start) < segment_size:\n        insert_pos = random.randint(0, n-segment_size)\n\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment merging\n    if random.random() < 0.3 and n > 6:\n        merge_pos = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:merge_pos], new_solution[merge_pos+1:]])\n\n    # Comprehensive repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment rotation with dynamic segment inversion to generate neighbors, combining probabilistic segment displacement and node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9568280094502536,
            0.3536253571510315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that combines adaptive segment rotation with dynamic node clustering to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive path inversion with dynamic objective-aware node swapping to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front through a multi-criteria selection mechanism that prioritizes solutions with balanced objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic objective-aware node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(n), 2)\n        # Swap nodes based on their objective contributions\n        cost1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost1_j = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost2_j = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if (cost1_i + cost1_j) > (cost2_i + cost2_j):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7531892094414755,
            1.371842622756958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic objective-aware node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(n), 2)\n        # Swap nodes based on their objective contributions\n        cost1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost1_j = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost2_j = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if (cost1_i + cost1_j) > (cost2_i + cost2_j):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment inversion with multi-objective-aware edge insertion to dynamically balance exploration and exploitation while ensuring feasibility through probabilistic node repair.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.random() * 0.1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(n//2, int(random.expovariate(1.0))))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n            if random.random() < 0.7 * (1 - (cost1 + cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())):\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Probabilistic node repair\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This algorithm employs a dynamic segment fusion and probabilistic node reinsertion strategy, combining multi-objective-aware segment merging with adaptive node displacement to balance exploration and exploitation while ensuring feasibility through a hybrid validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment fusion\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Multi-objective-aware segment merging\n    cost1 = distance_matrix_1[new_solution[a-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[c]]\n    cost2 = distance_matrix_2[new_solution[a-1], segment2[0]] + distance_matrix_2[segment2[-1], new_solution[c]]\n    if random.random() < 0.8 * (1 - (cost1 + cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())):\n        merged_segment = np.concatenate([segment1, segment2[::-1] if random.random() < 0.5 else segment2])\n        new_solution = np.concatenate([new_solution[:a], merged_segment, new_solution[c:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Hybrid validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6231790070790091,
            0.9603099822998047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment fusion\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Multi-objective-aware segment merging\n    cost1 = distance_matrix_1[new_solution[a-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[c]]\n    cost2 = distance_matrix_2[new_solution[a-1], segment2[0]] + distance_matrix_2[segment2[-1], new_solution[c]]\n    if random.random() < 0.8 * (1 - (cost1 + cost2) / (distance_matrix_1.sum() + distance_matrix_2.sum())):\n        merged_segment = np.concatenate([segment1, segment2[::-1] if random.random() < 0.5 else segment2])\n        new_solution = np.concatenate([new_solution[:a], merged_segment, new_solution[c:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Hybrid validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment reversal with adaptive segment relocation to generate diverse neighbor solutions while maintaining feasibility by dynamically adjusting segment positions based on objective-specific distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.994023977961241,
            0.2688214182853699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel algorithm that combines a dynamic segment inversion with adaptive segment insertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by intelligently selecting segments and dynamically adjusting their positions based on objective-specific distance metrics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 2 * (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select two random segments and invert one\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Insert the other segment at a random position\n    segment = new_solution[k:l]\n    pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8220314798005934,
            0.2076815366744995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 2 * (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select two random segments and invert one\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Insert the other segment at a random position\n    segment = new_solution[k:l]\n    pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, then applies a hybrid of segment inversion with adaptive k-opt moves, combining probabilistic segment swaps and node reinsertion to explore the solution space while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive k-opt\n    k = random.randint(2, min(5, n//2))\n    points = sorted(random.sample(range(1, n-1), k))\n    segments = []\n    for i in range(len(points)-1):\n        seg = new_solution[points[i]:points[i+1]]\n        if random.random() < 0.5:\n            seg = seg[::-1]\n        segments.append(seg)\n    new_solution = np.concatenate([new_solution[:points[0]]] + segments + [new_solution[points[-1]:]])\n\n    # Probabilistic segment swap\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        seg1 = new_solution[a:b].copy()\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        seg2 = new_solution[c:d].copy()\n        new_solution = np.concatenate([new_solution[:a], seg2, new_solution[b:c], seg1, new_solution[d:]])\n\n    # Node reinsertion\n    if random.random() < 0.4:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7754308121290535,
            1.2458885312080383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive k-opt\n    k = random.randint(2, min(5, n//2))\n    points = sorted(random.sample(range(1, n-1), k))\n    segments = []\n    for i in range(len(points)-1):\n        seg = new_solution[points[i]:points[i+1]]\n        if random.random() < 0.5:\n            seg = seg[::-1]\n        segments.append(seg)\n    new_solution = np.concatenate([new_solution[:points[0]]] + segments + [new_solution[points[-1]:]])\n\n    # Probabilistic segment swap\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        seg1 = new_solution[a:b].copy()\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        seg2 = new_solution[c:d].copy()\n        new_solution = np.concatenate([new_solution[:a], seg2, new_solution[b:c], seg1, new_solution[d:]])\n\n    # Node reinsertion\n    if random.random() < 0.4:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its dominance score (combination of normalized objective values) and applies a hybrid of multi-segment relocation with adaptive displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    dominance_scores = np.sum(normalized, axis=1)\n\n    # Select solution with lowest dominance score (most balanced)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Insert segments at new positions with displacement\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-min(2, pos1-1), min(2, n-pos1-1))\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-min(2, pos2-1), min(2, n-pos2-1))\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    # Apply segment relocations\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    # Node reallocation\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive based on its hypervolume contribution and applies a hybrid of adaptive segment inversion with constrained displacement, combining deterministic segment reversal and probabilistic node swapping to explore the solution space while ensuring feasibility through minimal validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = np.max(objectives, axis=0) * 1.1\n    hypervolumes = np.prod(reference_point - objectives, axis=1)\n\n    selected_idx = np.argmax(hypervolumes)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    segment1 = segment1[::-1]\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-1, 1)\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-1, 1)\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8975217352455691,
            0.5138814449310303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = np.max(objectives, axis=0) * 1.1\n    hypervolumes = np.prod(reference_point - objectives, axis=1)\n\n    selected_idx = np.argmax(hypervolumes)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    segment1 = segment1[::-1]\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-1, 1)\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-1, 1)\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm that combines adaptive segment rotation with dynamic node clustering to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment reversal with dynamic node reinsertion, guided by a weighted objective score to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    alpha = 0.7\n    selected = max(archive, key=lambda x: alpha * x[1][0] + (1 - alpha) * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    node_to_move = random.randint(0, n - 1)\n    position = random.randint(0, n - 2)\n    if position >= node_to_move:\n        position += 1\n    new_solution = np.insert(np.delete(new_solution, node_to_move), position, new_solution[node_to_move])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8282856197595099,
            1.9832011461257935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    alpha = 0.7\n    selected = max(archive, key=lambda x: alpha * x[1][0] + (1 - alpha) * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    node_to_move = random.randint(0, n - 1)\n    position = random.randint(0, n - 2)\n    if position >= node_to_move:\n        position += 1\n    new_solution = np.insert(np.delete(new_solution, node_to_move), position, new_solution[node_to_move])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment rotation with dynamic segment inversion to generate neighbors, combining probabilistic segment displacement and node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid of dynamic segment reversal with probabilistic node swapping to generate neighbors, combining adaptive segment displacement and conditional node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9472285291139282,
            0.31440049409866333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm uses a novel multi-objective segment clustering and adaptive path optimization approach that dynamically partitions the tour into objective-aware clusters, then optimizes each cluster's position through a hybrid of segment rotation and intelligent path smoothing while preserving feasibility through a cluster validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic clustering based on objective-aware distance\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Optimize each cluster\n    for i in range(len(clusters)):\n        cluster = clusters[i]\n        if len(cluster) < 2:\n            continue\n\n        # Adaptive rotation\n        if random.random() < 0.5:\n            k = random.randint(1, len(cluster)-1)\n            cluster = np.concatenate([cluster[k:], cluster[:k]])\n\n        # Path smoothing\n        if random.random() < 0.3:\n            for j in range(1, len(cluster)-1):\n                if random.random() < 0.5:\n                    cluster[j], cluster[j+1] = cluster[j+1], cluster[j]\n\n        clusters[i] = cluster\n\n    # Reconstruct solution with optimized clusters\n    new_solution = np.concatenate(clusters)\n\n    # Validate and repair solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6935691428704343,
            2.2745693922042847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic clustering based on objective-aware distance\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Optimize each cluster\n    for i in range(len(clusters)):\n        cluster = clusters[i]\n        if len(cluster) < 2:\n            continue\n\n        # Adaptive rotation\n        if random.random() < 0.5:\n            k = random.randint(1, len(cluster)-1)\n            cluster = np.concatenate([cluster[k:], cluster[:k]])\n\n        # Path smoothing\n        if random.random() < 0.3:\n            for j in range(1, len(cluster)-1):\n                if random.random() < 0.5:\n                    cluster[j], cluster[j+1] = cluster[j+1], cluster[j]\n\n        clusters[i] = cluster\n\n    # Reconstruct solution with optimized clusters\n    new_solution = np.concatenate(clusters)\n\n    # Validate and repair solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity, applies a combination of segment inversion and adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply adaptive node insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Apply a conditional swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    temp = new_solution[i]\n    new_solution[i] = new_solution[j]\n    new_solution[j] = temp\n\n    # Calculate cost before and after swap\n    cost_before_1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost_before_2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Revert if swap does not improve at least one objective\n    if (cost_before_1 <= sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n       (cost_before_2 <= sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n        new_solution[j] = new_solution[i]\n        new_solution[i] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{An adaptive multi-objective tour fragmentation and reassembly algorithm that intelligently dissects promising solution segments from diverse archive solutions, evaluates their potential impact on both objectives, and reconstructs a new tour by strategically merging and reordering these segments while maintaining feasibility through constrained reassembly operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_indices = sorted(range(len(archive)), key=lambda i: archive[i][1][0] - archive[i][1][1])[:3]\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Extract diverse segments from selected solutions\n    segments = []\n    n = len(selected_solutions[0])\n    segment_size = max(2, n // 5)\n\n    for sol in selected_solutions:\n        for i in range(0, n, segment_size):\n            segments.append(sol[i:i+segment_size])\n\n    # Shuffle segments and attempt to create a new solution\n    random.shuffle(segments)\n    new_solution = []\n    used_nodes = set()\n\n    for seg in segments:\n        for node in seg:\n            if node not in used_nodes:\n                new_solution.append(node)\n                used_nodes.add(node)\n                if len(new_solution) == n:\n                    break\n        if len(new_solution) == n:\n            break\n\n    # Add any missing nodes\n    missing_nodes = set(range(n)) - used_nodes\n    if missing_nodes:\n        new_solution.extend(list(missing_nodes))\n\n    # Perform constrained reassembly to improve objectives\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate segment in different positions\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in range(n - len(segment) + 1):\n            if pos == i:\n                continue\n\n            # Create temporary solution\n            temp = new_solution[:i] + new_solution[j:]\n            temp = temp[:pos] + segment + temp[pos:]\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(1, len(temp))) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(1, len(temp))) + distance_matrix_2[temp[-1], temp[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply best found position\n        if best_pos != i:\n            new_solution = new_solution[:i] + new_solution[j:]\n            new_solution = new_solution[:best_pos] + segment + new_solution[best_pos:]\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8742458896248619,
            10.713953018188477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_indices = sorted(range(len(archive)), key=lambda i: archive[i][1][0] - archive[i][1][1])[:3]\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Extract diverse segments from selected solutions\n    segments = []\n    n = len(selected_solutions[0])\n    segment_size = max(2, n // 5)\n\n    for sol in selected_solutions:\n        for i in range(0, n, segment_size):\n            segments.append(sol[i:i+segment_size])\n\n    # Shuffle segments and attempt to create a new solution\n    random.shuffle(segments)\n    new_solution = []\n    used_nodes = set()\n\n    for seg in segments:\n        for node in seg:\n            if node not in used_nodes:\n                new_solution.append(node)\n                used_nodes.add(node)\n                if len(new_solution) == n:\n                    break\n        if len(new_solution) == n:\n            break\n\n    # Add any missing nodes\n    missing_nodes = set(range(n)) - used_nodes\n    if missing_nodes:\n        new_solution.extend(list(missing_nodes))\n\n    # Perform constrained reassembly to improve objectives\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate segment in different positions\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in range(n - len(segment) + 1):\n            if pos == i:\n                continue\n\n            # Create temporary solution\n            temp = new_solution[:i] + new_solution[j:]\n            temp = temp[:pos] + segment + temp[pos:]\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(1, len(temp))) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(1, len(temp))) + distance_matrix_2[temp[-1], temp[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply best found position\n        if best_pos != i:\n            new_solution = new_solution[:i] + new_solution[j:]\n            new_solution = new_solution[:best_pos] + segment + new_solution[best_pos:]\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment rotation with probabilistic node swapping and insertion, combining geometric transformations and multi-objective-aware node reallocation to explore the solution space while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n    segment = np.roll(segment, rotation)\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i+1]] < distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j-1]][new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective aware node insertion\n    if random.random() < 0.4:\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j and distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[i+1]] < distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j-1]][new_solution[j]]:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9177619312235528,
            0.3926912546157837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n    segment = np.roll(segment, rotation)\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i+1]] < distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j-1]][new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective aware node insertion\n    if random.random() < 0.4:\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j and distance_matrix_2[new_solution[i-1]][new_solution[j]] + distance_matrix_2[new_solution[j]][new_solution[i+1]] < distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j-1]][new_solution[j]]:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and applies a hybrid of probabilistic segment inversion with adaptive displacement and node swapping, ensuring feasibility through dynamic repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.6])  # Higher weight for second objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment inversion with displacement\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        segment = segment[::-1] if random.random() < 0.7 else segment\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.8:\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.706425080401607,
            1.3565682172775269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.4, 0.6])  # Higher weight for second objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment inversion with displacement\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        segment = segment[::-1] if random.random() < 0.7 else segment\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.8:\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm that combines adaptive segment rotation with dynamic node clustering to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This new algorithm employs a hybrid approach combining adaptive path inversion with dynamic segment swapping to generate high-quality neighbor solutions by balancing local and global perturbations while maintaining feasibility through careful node repositioning.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic segment swapping\n    segment_size = random.randint(2, min(5, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    while abs(pos1 - pos2) < segment_size:\n        pos2 = random.randint(0, n - segment_size)\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9309699354052332,
            0.5465879440307617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic segment swapping\n    segment_size = random.randint(2, min(5, n//2))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    while abs(pos1 - pos2) < segment_size:\n        pos2 = random.randint(0, n - segment_size)\n    segment1 = new_solution[pos1:pos1+segment_size]\n    segment2 = new_solution[pos2:pos2+segment_size]\n    new_solution[pos1:pos1+segment_size] = segment2\n    new_solution[pos2:pos2+segment_size] = segment1\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm employs a multi-phase strategy that combines adaptive segment reordering with objective-guided segment merging, using dynamic segment selection based on Pareto-optimal front proximity and local improvement potential, while ensuring feasibility through constrained segment insertion and rotation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment selection based on distance matrices\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Phase 2: Objective-guided segment reordering\n    if random.random() < 0.7:\n        segment_costs = []\n        for i in range(len(segment)):\n            for j in range(i+1, len(segment)):\n                cost1 = distance_matrix_1[segment[i], segment[j]] + distance_matrix_1[segment[j], segment[i]]\n                cost2 = distance_matrix_2[segment[i], segment[j]] + distance_matrix_2[segment[j], segment[i]]\n                segment_costs.append((cost1 + cost2, i, j))\n\n        if segment_costs:\n            _, i, j = min(segment_costs)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    # Phase 3: Dynamic segment insertion with feasibility check\n    insertion_point = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    # Phase 4: Segment rotation for diversity\n    if random.random() < 0.3:\n        rotation_point = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation_point)\n        new_solution[start:start+len(segment)] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.939237011710152,
            0.47486698627471924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment selection based on distance matrices\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Phase 2: Objective-guided segment reordering\n    if random.random() < 0.7:\n        segment_costs = []\n        for i in range(len(segment)):\n            for j in range(i+1, len(segment)):\n                cost1 = distance_matrix_1[segment[i], segment[j]] + distance_matrix_1[segment[j], segment[i]]\n                cost2 = distance_matrix_2[segment[i], segment[j]] + distance_matrix_2[segment[j], segment[i]]\n                segment_costs.append((cost1 + cost2, i, j))\n\n        if segment_costs:\n            _, i, j = min(segment_costs)\n            segment[i], segment[j] = segment[j], segment[i]\n\n    # Phase 3: Dynamic segment insertion with feasibility check\n    insertion_point = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    # Phase 4: Segment rotation for diversity\n    if random.random() < 0.3:\n        rotation_point = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation_point)\n        new_solution[start:start+len(segment)] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm that combines adaptive segment rotation with dynamic node clustering to generate diverse neighbor solutions while balancing exploration and exploitation of the Pareto front.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:end] = rotated_segment\n\n    # Dynamic node clustering\n    cluster_size = random.randint(2, min(4, n//4))\n    cluster_indices = random.sample(range(n), cluster_size)\n    cluster = new_solution[cluster_indices]\n    new_solution = np.delete(new_solution, cluster_indices)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm combines adaptive segment inversion with dynamic objective-balanced node reinsertion, selecting solutions based on their objective diversity and applying a hybrid of segment reversal and position-sensitive node relocation to explore the solution space while ensuring tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic objective-balanced node reinsertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6587975879089374,
            2.3065013885498047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic objective-balanced node reinsertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment rotation with dynamic segment inversion to generate neighbors, combining probabilistic segment displacement and node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i+1:j], [new_solution[i]], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{A novel algorithm that combines a probabilistic segment splitting and merging strategy with adaptive node reordering to generate diverse neighbor solutions while maintaining feasibility through dynamic segment validation and repair, leveraging both distance matrices to guide the exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    split_points = sorted(random.sample(range(1, n-1), 2))\n    a, b = split_points[0], split_points[1]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        new_solution = np.concatenate([segment1, segment2, segment3])\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.2:\n        k = random.randint(1, min(3, n-2))\n        segment = new_solution[-k:]\n        new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6910304739348553,
            2.3294341564178467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    split_points = sorted(random.sample(range(1, n-1), 2))\n    a, b = split_points[0], split_points[1]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        new_solution = np.concatenate([segment1, segment2, segment3])\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.2:\n        k = random.randint(1, min(3, n-2))\n        segment = new_solution[-k:]\n        new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A new algorithm that uses a multi-objective segment crossover and adaptive path reconfiguration to intelligently combine segments from diverse solutions while dynamically adjusting the exploration of objective spaces through weighted segment selection and path relinking.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_solutions = []\n    for sol, (cost1, cost2) in archive:\n        norm_cost1 = cost1 / (cost1 + cost2) if (cost1 + cost2) > 0 else 0\n        norm_cost2 = cost2 / (cost1 + cost2) if (cost1 + cost2) > 0 else 0\n        normalized_solutions.append((sol, norm_cost1, norm_cost2))\n\n    # Sort by combined normalized score with dynamic weights\n    alpha = random.uniform(0.3, 0.7)\n    top_solutions = sorted(normalized_solutions, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[:2]\n\n    # Create base solution using weighted segment selection\n    n = len(top_solutions[0][0])\n    base_solution = []\n    segment_size = max(2, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Select segment from solution with better performance in current objective space\n        if alpha > 0.5:\n            segment = top_solutions[0][0][i:i+segment_size]\n        else:\n            segment = top_solutions[1][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path reconfiguration\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible configurations\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select based on dynamic objective preference\n        if random.random() < alpha:\n            if cost1[0] < cost2[0]:\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:\n            if cost1[1] < cost2[1]:\n                new_solution = option1\n            else:\n                new_solution = option2\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.716466178821926,
            3.1820313334465027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_solutions = []\n    for sol, (cost1, cost2) in archive:\n        norm_cost1 = cost1 / (cost1 + cost2) if (cost1 + cost2) > 0 else 0\n        norm_cost2 = cost2 / (cost1 + cost2) if (cost1 + cost2) > 0 else 0\n        normalized_solutions.append((sol, norm_cost1, norm_cost2))\n\n    # Sort by combined normalized score with dynamic weights\n    alpha = random.uniform(0.3, 0.7)\n    top_solutions = sorted(normalized_solutions, key=lambda x: alpha * x[1] + (1 - alpha) * x[2])[:2]\n\n    # Create base solution using weighted segment selection\n    n = len(top_solutions[0][0])\n    base_solution = []\n    segment_size = max(2, n // 5)\n\n    for i in range(0, n, segment_size):\n        # Select segment from solution with better performance in current objective space\n        if alpha > 0.5:\n            segment = top_solutions[0][0][i:i+segment_size]\n        else:\n            segment = top_solutions[1][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path reconfiguration\n    new_solution = base_solution.copy()\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible configurations\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select based on dynamic objective preference\n        if random.random() < alpha:\n            if cost1[0] < cost2[0]:\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:\n            if cost1[1] < cost2[1]:\n                new_solution = option1\n            else:\n                new_solution = option2\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance score (combination of normalized objective values) and applies a hybrid of multi-segment relocation with adaptive displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    dominance_scores = np.sum(normalized, axis=1)\n\n    # Select solution with lowest dominance score (most balanced)\n    selected_idx = np.argmin(dominance_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segment1 = new_solution[a:b].copy()\n    segment2 = new_solution[c:d].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Insert segments at new positions with displacement\n    pos1 = random.randint(1, n-1)\n    displacement1 = random.randint(-min(2, pos1-1), min(2, n-pos1-1))\n    new_pos1 = max(1, min(n-1, pos1 + displacement1))\n\n    pos2 = random.randint(1, n-1)\n    displacement2 = random.randint(-min(2, pos2-1), min(2, n-pos2-1))\n    new_pos2 = max(1, min(n-1, pos2 + displacement2))\n\n    # Apply segment relocations\n    new_solution = np.concatenate([new_solution[:new_pos1], segment1, new_solution[new_pos1:]])\n    if new_pos2 > new_pos1:\n        new_pos2 += len(segment1)\n    new_solution = np.concatenate([new_solution[:new_pos2], segment2, new_solution[new_pos2:]])\n\n    # Node reallocation\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity score (combination of normalized objective values and tour structure diversity) and applies a hybrid of adaptive segment inversion with multi-objective node reinsertion, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate tour structure diversity\n    tour_structures = []\n    for sol, _ in archive:\n        structure = np.diff(sol)\n        tour_structures.append(structure)\n    structure_diversity = np.std(tour_structures, axis=0)\n\n    # Combine diversity measures\n    diversity_scores = np.sum(normalized, axis=1) + np.sum(structure_diversity)\n\n    # Select solution with highest diversity score\n    selected_idx = np.argmax(diversity_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(5, int(n * 0.2)))\n    start = random.randint(1, n - segment_length - 1)\n    end = start + segment_length\n\n    if random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node reinsertion\n    if random.random() < 0.8:\n        # Select nodes based on their contribution to both objectives\n        node_contributions = []\n        for i in range(1, n-1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[i+1]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] - distance_matrix_1[prev, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] - distance_matrix_2[prev, next_node]\n            node_contributions.append((cost1 + cost2, i))\n\n        # Sort nodes by their combined contribution\n        node_contributions.sort(reverse=True)\n        selected_nodes = [idx for _, idx in node_contributions[:min(3, len(node_contributions)//2)]]\n\n        # Reinsert selected nodes\n        for i in selected_nodes:\n            if random.random() < 0.5:\n                new_pos = random.randint(1, n-1)\n                if new_pos > i:\n                    new_pos += 1\n                new_solution = np.insert(new_solution, new_pos, new_solution[i])\n                new_solution = np.delete(new_solution, i if i < new_pos else i+1)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8717659965929074,
            3.7167372703552246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate tour structure diversity\n    tour_structures = []\n    for sol, _ in archive:\n        structure = np.diff(sol)\n        tour_structures.append(structure)\n    structure_diversity = np.std(tour_structures, axis=0)\n\n    # Combine diversity measures\n    diversity_scores = np.sum(normalized, axis=1) + np.sum(structure_diversity)\n\n    # Select solution with highest diversity score\n    selected_idx = np.argmax(diversity_scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(5, int(n * 0.2)))\n    start = random.randint(1, n - segment_length - 1)\n    end = start + segment_length\n\n    if random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node reinsertion\n    if random.random() < 0.8:\n        # Select nodes based on their contribution to both objectives\n        node_contributions = []\n        for i in range(1, n-1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[i+1]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] - distance_matrix_1[prev, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] - distance_matrix_2[prev, next_node]\n            node_contributions.append((cost1 + cost2, i))\n\n        # Sort nodes by their combined contribution\n        node_contributions.sort(reverse=True)\n        selected_nodes = [idx for _, idx in node_contributions[:min(3, len(node_contributions)//2)]]\n\n        # Reinsert selected nodes\n        for i in selected_nodes:\n            if random.random() < 0.5:\n                new_pos = random.randint(1, n-1)\n                if new_pos > i:\n                    new_pos += 1\n                new_solution = np.insert(new_solution, new_pos, new_solution[i])\n                new_solution = np.delete(new_solution, i if i < new_pos else i+1)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid of dynamic segment reversal with probabilistic node swapping to generate neighbors, combining adaptive segment displacement and conditional node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of adaptive segment inversion with probabilistic node insertion, combining dynamic segment displacement and conditional node reallocation to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(4, pos-1), min(4, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, i, new_solution[i+1])\n        new_solution = np.delete(new_solution, i+2)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9197784450909634,
            0.3180828094482422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(4, pos-1), min(4, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.8:\n        i = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, i, new_solution[i+1])\n        new_solution = np.delete(new_solution, i+2)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance, then applies a hybrid of multi-segment rotation with objective-aware displacement, combining probabilistic segment inversion and dynamic node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation with objective-aware displacement\n    segments = random.sample(range(1, n-1), k=random.randint(2, min(4, n-2)))\n    segments.sort()\n    rotated_segments = []\n\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        segment = new_solution[start:end]\n        rotated_segments.append(segment[::-1] if random.random() < 0.7 else segment)\n\n    # Dynamic node reinsertion\n    if random.random() < 0.8:\n        nodes_to_reinsert = random.sample(range(1, n-1), k=random.randint(1, min(3, n-2)))\n        for node in nodes_to_reinsert:\n            pos = new_solution.tolist().index(node)\n            new_pos = random.randint(1, n-2)\n            if new_pos != pos:\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Objective-aware displacement\n    if random.random() < 0.5:\n        obj = random.choice([0, 1])\n        distance_matrix = distance_matrix_1 if obj == 0 else distance_matrix_2\n        for i in range(1, n-1):\n            if random.random() < 0.3:\n                neighbors = [j for j in range(1, n-1) if j != i]\n                neighbor_costs = [distance_matrix[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix[new_solution[j], new_solution[i+1]] for j in neighbors]\n                best_neighbor = neighbors[np.argmin(neighbor_costs)]\n                new_solution[i], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8303865325265088,
            3.4333189725875854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation with objective-aware displacement\n    segments = random.sample(range(1, n-1), k=random.randint(2, min(4, n-2)))\n    segments.sort()\n    rotated_segments = []\n\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        segment = new_solution[start:end]\n        rotated_segments.append(segment[::-1] if random.random() < 0.7 else segment)\n\n    # Dynamic node reinsertion\n    if random.random() < 0.8:\n        nodes_to_reinsert = random.sample(range(1, n-1), k=random.randint(1, min(3, n-2)))\n        for node in nodes_to_reinsert:\n            pos = new_solution.tolist().index(node)\n            new_pos = random.randint(1, n-2)\n            if new_pos != pos:\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n                new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Objective-aware displacement\n    if random.random() < 0.5:\n        obj = random.choice([0, 1])\n        distance_matrix = distance_matrix_1 if obj == 0 else distance_matrix_2\n        for i in range(1, n-1):\n            if random.random() < 0.3:\n                neighbors = [j for j in range(1, n-1) if j != i]\n                neighbor_costs = [distance_matrix[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix[new_solution[j], new_solution[i+1]] for j in neighbors]\n                best_neighbor = neighbors[np.argmin(neighbor_costs)]\n                new_solution[i], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9129629620147888,
            0.1903696060180664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9129629620147888,
            0.1903696060180664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel algorithm that combines adaptive segment swaps with dynamic segment reversals and guided insertion to generate high-quality neighbor solutions while ensuring feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.930704069873176,
            0.7175614833831787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with adaptive segment relocations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by dynamically adjusting segment boundaries and insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6443281486848254,
            0.8126079440116882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid of dynamic segment reversal with probabilistic node swapping to generate neighbors, combining adaptive segment displacement and conditional node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity-aware selection metric and applies a hybrid of multi-segment crossover with adaptive route fragmentation, combining probabilistic path inversion and node cluster reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive fragmentation\n    segments = []\n    num_segments = random.randint(2, min(5, n//3))\n    points = sorted(random.sample(range(1, n-1), num_segments-1))\n    points = [0] + points + [n]\n\n    for i in range(len(points)-1):\n        segments.append(new_solution[points[i]:points[i+1]].copy())\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic path inversion\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Node cluster reallocation\n    if random.random() < 0.8:\n        cluster_size = random.randint(2, min(5, n//4))\n        cluster_pos = random.randint(1, n-1-cluster_size)\n        cluster = new_solution[cluster_pos:cluster_pos+cluster_size].copy()\n\n        new_pos = random.randint(1, n-1-cluster_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            cluster,\n            np.setdiff1d(new_solution, cluster)\n        ])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9160606831297486,
            0.6208840608596802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive fragmentation\n    segments = []\n    num_segments = random.randint(2, min(5, n//3))\n    points = sorted(random.sample(range(1, n-1), num_segments-1))\n    points = [0] + points + [n]\n\n    for i in range(len(points)-1):\n        segments.append(new_solution[points[i]:points[i+1]].copy())\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic path inversion\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Node cluster reallocation\n    if random.random() < 0.8:\n        cluster_size = random.randint(2, min(5, n//4))\n        cluster_pos = random.randint(1, n-1-cluster_size)\n        cluster = new_solution[cluster_pos:cluster_pos+cluster_size].copy()\n\n        new_pos = random.randint(1, n-1-cluster_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            cluster,\n            np.setdiff1d(new_solution, cluster)\n        ])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid of dynamic segment reversal with probabilistic node swapping to generate neighbors, combining adaptive segment displacement and conditional node reinsertion to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive based on hypervolume contribution and applies a hybrid of adaptive k-opt with probabilistic edge swapping, combining dynamic path inversion and conditional node reinsertion to explore the solution space while ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], 1) * max(x[1][1], 1)))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply adaptive k-opt with probabilistic edge swapping\n    k = random.randint(2, min(5, n//2))\n    indices = sorted(random.sample(range(1, n-1), k))\n    segment = new_solution[indices[0]:indices[-1]+1].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        for i in range(len(segment)-1):\n            if random.random() < 0.5:\n                segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Reinsert the modified segment\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]\n\n    # Conditional node reinsertion\n    if random.random() < 0.3:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Validate and repair feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8560215707494401,
            0.4615779519081116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], 1) * max(x[1][1], 1)))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply adaptive k-opt with probabilistic edge swapping\n    k = random.randint(2, min(5, n//2))\n    indices = sorted(random.sample(range(1, n-1), k))\n    segment = new_solution[indices[0]:indices[-1]+1].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        for i in range(len(segment)-1):\n            if random.random() < 0.5:\n                segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Reinsert the modified segment\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = new_solution[:n]\n\n    # Conditional node reinsertion\n    if random.random() < 0.3:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Validate and repair feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel algorithm that combines adaptive segment relocations with probabilistic segment reversals to generate high-quality neighbor solutions while dynamically balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / max(x[1][0], x[1][1], 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.3:\n        new_solution = np.concatenate([new_solution[j:], new_solution[i:j], new_solution[:i]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.974322053464395,
            0.26786649227142334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / max(x[1][0], x[1][1], 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.3:\n        new_solution = np.concatenate([new_solution[j:], new_solution[i:j], new_solution[:i]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a novel multi-segment crossover with adaptive displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive displacement\n    segments = []\n    for _ in range(random.randint(2, 4)):\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segments.append(new_solution[a:b].copy())\n\n    for segment in segments:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation with objective awareness\n    if random.random() < 0.8:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) < \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9542287369840707,
            0.47899824380874634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive displacement\n    segments = []\n    for _ in range(random.randint(2, 4)):\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segments.append(new_solution[a:b].copy())\n\n    for segment in segments:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation with objective awareness\n    if random.random() < 0.8:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) < \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid of segment rotation and adaptive node reinsertion, combining probabilistic segment rotation with position-aware displacement and node reallocation to explore the solution space while maintaining tour feasibility through a multi-stage validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment rotation\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    if random.random() < 0.7:\n        segment = np.roll(segment, rotation)\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reinsertion with position awareness\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Multi-stage repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure start and end nodes are not changed\n    new_solution[0] = selected[0]\n    new_solution[-1] = selected[-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8865938704026703,
            0.3943237066268921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment rotation\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    if random.random() < 0.7:\n        segment = np.roll(segment, rotation)\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reinsertion with position awareness\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Multi-stage repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure start and end nodes are not changed\n    new_solution[0] = selected[0]\n    new_solution[-1] = selected[-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized costs and diversity, then applies a novel combination of segment inversion with adaptive node swapping and probabilistic segment rotation to generate diverse high-quality neighbors while maintaining tour feasibility through a multi-stage validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4 + 0.2 * np.random.random(len(archive))\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive parameters\n    seg_length = max(2, min(n//4, int(np.random.normal(n//3, n//6))))\n    a = random.randint(1, n - seg_length - 1)\n    b = a + seg_length\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic segment rotation\n    if random.random() < 0.5:\n        rot = random.randint(1, seg_length - 1)\n        segment = np.concatenate([segment[rot:], segment[:rot]])\n\n    # Adaptive node swapping\n    swap_points = sorted(random.sample(range(1, n-1), min(3, n//3)))\n    for i in range(len(swap_points) - 1):\n        if random.random() < 0.8:\n            new_solution[swap_points[i]], new_solution[swap_points[i+1]] = new_solution[swap_points[i+1]], new_solution[swap_points[i]]\n\n    # Multi-stage repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure tour validity\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = selected.copy()\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8277566913224516,
            1.5328847169876099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4 + 0.2 * np.random.random(len(archive))\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive parameters\n    seg_length = max(2, min(n//4, int(np.random.normal(n//3, n//6))))\n    a = random.randint(1, n - seg_length - 1)\n    b = a + seg_length\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic segment rotation\n    if random.random() < 0.5:\n        rot = random.randint(1, seg_length - 1)\n        segment = np.concatenate([segment[rot:], segment[:rot]])\n\n    # Adaptive node swapping\n    swap_points = sorted(random.sample(range(1, n-1), min(3, n//3)))\n    for i in range(len(swap_points) - 1):\n        if random.random() < 0.8:\n            new_solution[swap_points[i]], new_solution[swap_points[i+1]] = new_solution[swap_points[i+1]], new_solution[swap_points[i]]\n\n    # Multi-stage repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure tour validity\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = selected.copy()\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel algorithm that combines adaptive segment shuffling with objective-aware segment reinsertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through dynamic segment manipulations and objective-balanced selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    random.shuffle(segment)\n\n    new_solution[i:j] = segment\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8161250917613718,
            0.2445337176322937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    random.shuffle(segment)\n\n    new_solution[i:j] = segment\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive based on its combined objective score, then applies a novel multi-segment crossover with probabilistic segment inversion and adaptive node swapping, ensuring feasibility through comprehensive validation and repair mechanisms while exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with probabilistic inversion\n    num_segments = random.randint(2, min(4, n//3))\n    segments = []\n    positions = sorted(random.sample(range(1, n-1), num_segments-1))\n    segments.append(new_solution[:positions[0]])\n    for i in range(len(positions)-1):\n        segments.append(new_solution[positions[i]:positions[i+1]])\n    segments.append(new_solution[positions[-1]:])\n\n    # Randomly invert some segments\n    for i in range(len(segments)):\n        if random.random() < 0.4:\n            segments[i] = segments[i][::-1]\n\n    # Recombine segments in new order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Adaptive node swapping based on objective correlation\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if obj1 < obj2 and random.random() < 0.6:\n        # More swaps if first objective is worse\n        num_swaps = random.randint(1, min(3, n//2))\n    else:\n        num_swaps = random.randint(0, 1)\n\n    for _ in range(num_swaps):\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7552246167859078,
            1.3221845030784607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: -x[1][0] - x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with probabilistic inversion\n    num_segments = random.randint(2, min(4, n//3))\n    segments = []\n    positions = sorted(random.sample(range(1, n-1), num_segments-1))\n    segments.append(new_solution[:positions[0]])\n    for i in range(len(positions)-1):\n        segments.append(new_solution[positions[i]:positions[i+1]])\n    segments.append(new_solution[positions[-1]:])\n\n    # Randomly invert some segments\n    for i in range(len(segments)):\n        if random.random() < 0.4:\n            segments[i] = segments[i][::-1]\n\n    # Recombine segments in new order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Adaptive node swapping based on objective correlation\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if obj1 < obj2 and random.random() < 0.6:\n        # More swaps if first objective is worse\n        num_swaps = random.randint(1, min(3, n//2))\n    else:\n        num_swaps = random.randint(0, 1)\n\n    for _ in range(num_swaps):\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm employs a multi-objective-aware segment relocation with adaptive segment inversion and dynamic segment fusion to generate diverse neighbor solutions while maintaining feasibility by intelligently combining segments based on their contribution to both objectives and ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n    else:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[l:m]\n        new_solution = np.concatenate([new_solution[:l], segment2[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.690054828819959,
            0.6456080079078674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n    else:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[l:m]\n        new_solution = np.concatenate([new_solution[:l], segment2[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9802027617903823,
            0.18505370616912842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9802027617903823,
            0.18505370616912842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{An algorithm that combines a dynamic segment inversion with adaptive segment shifting to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        shift = random.randint(-k, len(new_solution) - k)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+shift:], new_solution[k:k+shift]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8114862945984195,
            0.8351684212684631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        shift = random.randint(-k, len(new_solution) - k)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+shift:], new_solution[k:k+shift]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel algorithm that employs adaptive segment reshuffling with objective-biased segment selection to generate diverse neighbors by dynamically combining partial segments from promising solutions while ensuring feasibility through constrained segment insertion and reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + segment_length:]])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        random.shuffle(missing_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9466959463708828,
            0.3383678197860718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + segment_length:]])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        random.shuffle(missing_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8578536978907872,
            0.16673320531845093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8578536978907872,
            0.16673320531845093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel algorithm that combines adaptive segment relocations with dynamic node swaps to generate high-quality neighbor solutions by intelligently balancing exploration of the solution space and exploitation of promising segments while ensuring feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9327655903688159,
            0.9683308601379395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{An algorithm that combines a novel \"objective-biased segment rotation\" with a dynamic node repositioning strategy, where segments are rotated based on their relative performance in each objective space, and nodes are repositioned to balance the trade-off between the two objectives while ensuring feasibility through a probabilistic insertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best balanced objective performance\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate objective contributions of each segment\n    segment_length = max(2, n // 5)\n    segment_costs = []\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segment_costs.append((cost1, cost2))\n\n    # Rotate segments based on objective dominance\n    for i in range(len(segment_costs)):\n        if segment_costs[i][0] > segment_costs[i][1] and random.random() < 0.7:\n            start = i * segment_length\n            end = min(start + segment_length, n)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node repositioning\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.949165052780166,
            1.9112865328788757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best balanced objective performance\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate objective contributions of each segment\n    segment_length = max(2, n // 5)\n    segment_costs = []\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segment_costs.append((cost1, cost2))\n\n    # Rotate segments based on objective dominance\n    for i in range(len(segment_costs)):\n        if segment_costs[i][0] > segment_costs[i][1] and random.random() < 0.7:\n            start = i * segment_length\n            end = min(start + segment_length, n)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node repositioning\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel algorithm that combines adaptive segment swapping with dynamic node reinsertion, prioritizing solutions with balanced objective improvements while using randomized segment manipulations and feasibility checks to generate diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-8))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Swap segments with probability based on objective balance\n    if random.random() < 0.7:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Reinsert nodes with probability based on distance improvement\n    if random.random() < 0.4:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9383470700480021,
            1.5918281078338623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-8))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Swap segments with probability based on objective balance\n    if random.random() < 0.7:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Reinsert nodes with probability based on distance improvement\n    if random.random() < 0.4:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of segment inversion with probabilistic node swapping, combining distance-aware segment selection and adaptive displacement to explore the solution space while ensuring tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Distance-aware segment selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Identify segments with high combined distance\n    segments = []\n    for i in range(1, n-2):\n        segment_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n        segment_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n        segments.append((i, (segment_dist1 + segment_dist2) / (total_dist1 + total_dist2)))\n\n    segments.sort(key=lambda x: x[1], reverse=True)\n    a = segments[0][0] if segments else random.randint(1, n-2)\n    b = a + random.randint(2, min(5, n-a-1))\n\n    # Segment inversion with probability based on segment distance\n    if random.random() < 0.5 * (segments[0][1] if segments else 0.5):\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic node swapping based on distance\n    for _ in range(2):\n        i, j = random.sample(range(1, n-1), 2)\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        if random.random() > 0.7 * ((dist1_after + dist2_after) / (dist1_before + dist2_before)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6878315824920977,
            2.5231942534446716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Distance-aware segment selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Identify segments with high combined distance\n    segments = []\n    for i in range(1, n-2):\n        segment_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n        segment_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n        segments.append((i, (segment_dist1 + segment_dist2) / (total_dist1 + total_dist2)))\n\n    segments.sort(key=lambda x: x[1], reverse=True)\n    a = segments[0][0] if segments else random.randint(1, n-2)\n    b = a + random.randint(2, min(5, n-a-1))\n\n    # Segment inversion with probability based on segment distance\n    if random.random() < 0.5 * (segments[0][1] if segments else 0.5):\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic node swapping based on distance\n    for _ in range(2):\n        i, j = random.sample(range(1, n-1), 2)\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        if random.random() > 0.7 * ((dist1_after + dist2_after) / (dist1_before + dist2_before)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm combines a novel adaptive segment relocation strategy with a bi-objective-aware segment rotation operator to generate high-quality neighbors by dynamically reordering segments based on their contribution to both objectives and rotating segments to explore different configurations while ensuring feasibility through careful node insertion and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (2 * x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment contribution to both objectives\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(segment_length-1))\n    cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(segment_length-1))\n\n    # Decide whether to rotate the segment based on objective dominance\n    if cost1 > cost2:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n\n    # Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure all nodes are present and in correct order\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8318184509006725,
            1.5507298707962036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (2 * x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment contribution to both objectives\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(segment_length-1))\n    cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(segment_length-1))\n\n    # Decide whether to rotate the segment based on objective dominance\n    if cost1 > cost2:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n\n    # Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure all nodes are present and in correct order\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion guided by objective-aware segment quality assessment to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (2 * x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment quality based on both objectives\n    def segment_quality(i, j):\n        segment = new_solution[i:j]\n        cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        return (cost1 + cost2) / (1 + abs(cost1 - cost2))\n\n    # Extract multiple segments and reinsert them in a different order\n    segments = []\n    remaining = new_solution.copy()\n    while len(remaining) > 1:\n        i = random.randint(0, len(remaining)-1)\n        j = random.randint(i+1, min(i+4, len(remaining)))\n        segments.append(remaining[i:j])\n        remaining = np.concatenate([remaining[:i], remaining[j:]])\n\n    # Reconstruct solution with segments in random order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8695873769361651,
            1.7325878739356995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (2 * x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Calculate segment quality based on both objectives\n    def segment_quality(i, j):\n        segment = new_solution[i:j]\n        cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        return (cost1 + cost2) / (1 + abs(cost1 - cost2))\n\n    # Extract multiple segments and reinsert them in a different order\n    segments = []\n    remaining = new_solution.copy()\n    while len(remaining) > 1:\n        i = random.randint(0, len(remaining)-1)\n        j = random.randint(i+1, min(i+4, len(remaining)))\n        segments.append(remaining[i:j])\n        remaining = np.concatenate([remaining[:i], remaining[j:]])\n\n    # Reconstruct solution with segments in random order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9459553750550671,
            0.22808045148849487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel algorithm that uses a hybrid segment rotation with dynamic segment inversions and a modified score function to prioritize solutions with high potential for improvement by considering both objective values and their balance, while ensuring feasibility through intelligent segment manipulation and node insertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0015865092004106,
            0.4329144358634949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{An algorithm that combines dynamic segment reordering with adaptive segment inversion to generate diverse neighbor solutions by strategically manipulating segments based on their potential to improve both objectives, while ensuring feasibility through careful segment insertion and reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], new_solution[j:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6694909342154068,
            1.1216419339179993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], new_solution[j:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel algorithm that combines adaptive segment insertion with dynamic segment reversal to create diverse neighbor solutions while ensuring feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9396492963294925,
            0.36376041173934937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A novel algorithm that dynamically selects solutions based on a hybrid of normalized objective scores and local improvement potential, then applies a segment-based local search with adaptive rotation and insertion to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Dynamic selection based on normalized objective scores and local improvement potential\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        norm_obj1 = obj1 / (np.max(distance_matrix_1) * len(sol_obj[0]))\n        norm_obj2 = obj2 / (np.max(distance_matrix_2) * len(sol_obj[0]))\n        return (norm_obj1 + norm_obj2) / 2\n\n    selected = max(archive, key=score)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment-based local search with adaptive rotation and insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Adaptive rotation based on segment length\n        rotation = len(segment) // 2 if random.random() < 0.5 else len(segment) // 3\n        rotated_segment = np.roll(segment, rotation)\n\n        # Adaptive insertion point\n        k = random.randint(0, n) if random.random() < 0.3 else (i + j) // 2\n\n        # Apply segment operation\n        new_solution = np.concatenate([\n            new_solution[:i],\n            rotated_segment,\n            new_solution[i:j] if random.random() < 0.5 else np.array([]),\n            new_solution[j:] if random.random() < 0.7 else np.array([])\n        ])\n\n        # Ensure feasibility\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, list(missing_nodes))\n\n    # Final check and repair\n    if len(new_solution) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n\n    return new_solution\n\n",
        "score": [
            -0.8964949136128371,
            3.6991745829582214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Dynamic selection based on normalized objective scores and local improvement potential\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        norm_obj1 = obj1 / (np.max(distance_matrix_1) * len(sol_obj[0]))\n        norm_obj2 = obj2 / (np.max(distance_matrix_2) * len(sol_obj[0]))\n        return (norm_obj1 + norm_obj2) / 2\n\n    selected = max(archive, key=score)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment-based local search with adaptive rotation and insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Adaptive rotation based on segment length\n        rotation = len(segment) // 2 if random.random() < 0.5 else len(segment) // 3\n        rotated_segment = np.roll(segment, rotation)\n\n        # Adaptive insertion point\n        k = random.randint(0, n) if random.random() < 0.3 else (i + j) // 2\n\n        # Apply segment operation\n        new_solution = np.concatenate([\n            new_solution[:i],\n            rotated_segment,\n            new_solution[i:j] if random.random() < 0.5 else np.array([]),\n            new_solution[j:] if random.random() < 0.7 else np.array([])\n        ])\n\n        # Ensure feasibility\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, list(missing_nodes))\n\n    # Final check and repair\n    if len(new_solution) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm implements a novel hybrid local search strategy that combines objective-aware node clustering with adaptive segment recombination, using multi-objective distance metrics to identify critical segments for targeted improvement while maintaining feasibility through dynamic segment reordering and probabilistic segment merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Objective-aware node clustering\n    cluster_centers = []\n    for i in range(0, n, max(2, n//5)):\n        cluster = new_solution[i:i+max(2, n//5)]\n        x1_avg = np.mean(instance[cluster, 0])\n        y1_avg = np.mean(instance[cluster, 1])\n        x2_avg = np.mean(instance[cluster, 2])\n        y2_avg = np.mean(instance[cluster, 3])\n        cluster_centers.append((x1_avg, y1_avg, x2_avg, y2_avg))\n\n    # Identify critical segments\n    critical_segments = []\n    for i in range(len(cluster_centers)-1):\n        d1 = np.sqrt((cluster_centers[i][0]-cluster_centers[i+1][0])**2 +\n                    (cluster_centers[i][1]-cluster_centers[i+1][1])**2)\n        d2 = np.sqrt((cluster_centers[i][2]-cluster_centers[i+1][2])**2 +\n                    (cluster_centers[i][3]-cluster_centers[i+1][3])**2)\n        if d1 > np.mean(distance_matrix_1) or d2 > np.mean(distance_matrix_2):\n            critical_segments.append(i)\n\n    # Adaptive segment recombination\n    if critical_segments:\n        seg_idx = random.choice(critical_segments)\n        start = seg_idx * max(2, n//5)\n        end = min((seg_idx+1) * max(2, n//5), n)\n        segment = new_solution[start:end].copy()\n\n        if random.random() < 0.7:\n            segment = np.concatenate([segment[1:], segment[:1]])\n        else:\n            segment = segment[::-1]\n\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic segment merging\n    if random.random() < 0.6 and len(new_solution) > 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.9080948288977375,
            2.300212264060974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Objective-aware node clustering\n    cluster_centers = []\n    for i in range(0, n, max(2, n//5)):\n        cluster = new_solution[i:i+max(2, n//5)]\n        x1_avg = np.mean(instance[cluster, 0])\n        y1_avg = np.mean(instance[cluster, 1])\n        x2_avg = np.mean(instance[cluster, 2])\n        y2_avg = np.mean(instance[cluster, 3])\n        cluster_centers.append((x1_avg, y1_avg, x2_avg, y2_avg))\n\n    # Identify critical segments\n    critical_segments = []\n    for i in range(len(cluster_centers)-1):\n        d1 = np.sqrt((cluster_centers[i][0]-cluster_centers[i+1][0])**2 +\n                    (cluster_centers[i][1]-cluster_centers[i+1][1])**2)\n        d2 = np.sqrt((cluster_centers[i][2]-cluster_centers[i+1][2])**2 +\n                    (cluster_centers[i][3]-cluster_centers[i+1][3])**2)\n        if d1 > np.mean(distance_matrix_1) or d2 > np.mean(distance_matrix_2):\n            critical_segments.append(i)\n\n    # Adaptive segment recombination\n    if critical_segments:\n        seg_idx = random.choice(critical_segments)\n        start = seg_idx * max(2, n//5)\n        end = min((seg_idx+1) * max(2, n//5), n)\n        segment = new_solution[start:end].copy()\n\n        if random.random() < 0.7:\n            segment = np.concatenate([segment[1:], segment[:1]])\n        else:\n            segment = segment[::-1]\n\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic segment merging\n    if random.random() < 0.6 and len(new_solution) > 4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid operator that combines multi-segment inversion with adaptive node swapping to explore the solution space while ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive node swapping\n    num_segments = random.randint(2, min(4, n//3))\n    segment_points = sorted(random.sample(range(1, n-1), num_segments+1))\n\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node swapping based on distance metrics\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n            cost2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + \\\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            if random.random() < 0.8 * (1 - min(1, cost1/cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.586856793208216,
            1.6507072448730469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive node swapping\n    num_segments = random.randint(2, min(4, n//3))\n    segment_points = sorted(random.sample(range(1, n-1), num_segments+1))\n\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        if random.random() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node swapping based on distance metrics\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n            cost2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + \\\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            if random.random() < 0.8 * (1 - min(1, cost1/cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines adaptive segment relocations with probabilistic segment reversals to generate high-quality neighbor solutions while dynamically balancing exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / max(x[1][0], x[1][1], 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.3:\n        new_solution = np.concatenate([new_solution[j:], new_solution[i:j], new_solution[:i]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{A novel algorithm that combines weighted objective-based selection with adaptive segment swaps and probabilistic segment reversals to generate high-quality neighbor solutions while dynamically balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective score\n    def score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    selected = min(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n // 3, random.randint(1, n // 2)))\n    i = random.randint(0, n - segment_size)\n    j = i + segment_size\n    segment = new_solution[i:j]\n\n    # Probabilistic operations\n    if random.random() < 0.4:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.3:\n        k = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5728606039995584,
            1.471592903137207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective score\n    def score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    selected = min(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n // 3, random.randint(1, n // 2)))\n    i = random.randint(0, n - segment_size)\n    j = i + segment_size\n    segment = new_solution[i:j]\n\n    # Probabilistic operations\n    if random.random() < 0.4:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.3:\n        k = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on its combined objective improvement potential and applies a hybrid of adaptive segment reordering with dynamic node clustering, combining probabilistic segment inversion and spatial-aware node insertion to explore the solution space while ensuring feasibility through a multi-stage validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    cluster_size = max(2, min(5, n // 4))\n    a = random.randint(0, n - cluster_size)\n    b = a + cluster_size\n    segment = new_solution[a:b].copy()\n\n    # Dynamic node clustering based on spatial proximity\n    if random.random() < 0.7:\n        coords1 = instance[segment, :2]\n        coords2 = instance[segment, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Sort nodes in segment by distance to centroids\n        dist1 = np.linalg.norm(coords1 - centroid1, axis=1)\n        dist2 = np.linalg.norm(coords2 - centroid2, axis=1)\n        combined_dist = dist1 + dist2\n        sorted_indices = np.argsort(combined_dist)\n        segment = segment[sorted_indices]\n\n    # Probabilistic segment inversion\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position\n    insert_pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Spatial-aware node insertion\n    if random.random() < 0.5 and len(new_solution) > cluster_size:\n        node_to_insert = random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion position based on spatial proximity\n        best_pos = 0\n        min_dist = float('inf')\n        for i in range(len(remaining_nodes)):\n            if i == 0:\n                dist = distance_matrix_1[remaining_nodes[i], node_to_insert] + distance_matrix_2[remaining_nodes[i], node_to_insert]\n            else:\n                dist = (distance_matrix_1[remaining_nodes[i-1], node_to_insert] + distance_matrix_1[node_to_insert, remaining_nodes[i]]) + \\\n                       (distance_matrix_2[remaining_nodes[i-1], node_to_insert] + distance_matrix_2[node_to_insert, remaining_nodes[i]])\n            if dist < min_dist:\n                min_dist = dist\n                best_pos = i\n\n        new_solution = np.insert(remaining_nodes, best_pos, node_to_insert)\n\n    # Multi-stage validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n\n    # Ensure tour length matches original\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8123301878422686,
            0.6784685254096985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    cluster_size = max(2, min(5, n // 4))\n    a = random.randint(0, n - cluster_size)\n    b = a + cluster_size\n    segment = new_solution[a:b].copy()\n\n    # Dynamic node clustering based on spatial proximity\n    if random.random() < 0.7:\n        coords1 = instance[segment, :2]\n        coords2 = instance[segment, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Sort nodes in segment by distance to centroids\n        dist1 = np.linalg.norm(coords1 - centroid1, axis=1)\n        dist2 = np.linalg.norm(coords2 - centroid2, axis=1)\n        combined_dist = dist1 + dist2\n        sorted_indices = np.argsort(combined_dist)\n        segment = segment[sorted_indices]\n\n    # Probabilistic segment inversion\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position\n    insert_pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Spatial-aware node insertion\n    if random.random() < 0.5 and len(new_solution) > cluster_size:\n        node_to_insert = random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion position based on spatial proximity\n        best_pos = 0\n        min_dist = float('inf')\n        for i in range(len(remaining_nodes)):\n            if i == 0:\n                dist = distance_matrix_1[remaining_nodes[i], node_to_insert] + distance_matrix_2[remaining_nodes[i], node_to_insert]\n            else:\n                dist = (distance_matrix_1[remaining_nodes[i-1], node_to_insert] + distance_matrix_1[node_to_insert, remaining_nodes[i]]) + \\\n                       (distance_matrix_2[remaining_nodes[i-1], node_to_insert] + distance_matrix_2[node_to_insert, remaining_nodes[i]])\n            if dist < min_dist:\n                min_dist = dist\n                best_pos = i\n\n        new_solution = np.insert(remaining_nodes, best_pos, node_to_insert)\n\n    # Multi-stage validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n\n    # Ensure tour length matches original\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm combines a hybrid segment relocation with dynamic segment reordering to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        k = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, k, segment)\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        k = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, k, segment[::-1])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9270784483786922,
            1.5368019342422485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        k = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, k, segment)\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        k = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, k, segment[::-1])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment reversal with dynamic segment insertion, combining probabilistic edge swapping and node displacement to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Dynamic segment insertion\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Node displacement\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = np.setdiff1d(new_solution, np.arange(n))\n        new_solution = np.concatenate([new_solution[new_solution != extra[0]], missing])\n\n    return new_solution\n\n",
        "score": [
            -0.8896234099951341,
            1.1583847999572754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Dynamic segment insertion\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Node displacement\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = np.setdiff1d(new_solution, np.arange(n))\n        new_solution = np.concatenate([new_solution[new_solution != extra[0]], missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This algorithm selects a high-quality solution from the archive based on the sum of normalized objectives and applies a hybrid of adaptive segment permutation with dynamic node reinsertion, combining probabilistic segment translation and conditional node reordering to explore the solution space while maintaining feasibility through a multi-step validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    obj1 = [x[1][0] for x in archive]\n    obj2 = [x[1][1] for x in archive]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    normalized = [(i, (obj1[i]-min1)/(max1-min1) + (obj2[i]-min2)/(max2-min2)) for i in range(len(archive))]\n    selected_index = min(normalized, key=lambda x: x[1])[0]\n    selected = archive[selected_index][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment permutation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if len(segment) > 1:\n        if random.random() < 0.7:\n            segment = np.random.permutation(segment)\n        else:\n            segment = segment[::-1]\n\n    # Dynamic node reinsertion\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(4, pos-1), min(4, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic segment translation\n    if random.random() < 0.6:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Conditional node reordering\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Multi-step repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure tour validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9849241483016165,
            0.6392757892608643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    obj1 = [x[1][0] for x in archive]\n    obj2 = [x[1][1] for x in archive]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    normalized = [(i, (obj1[i]-min1)/(max1-min1) + (obj2[i]-min2)/(max2-min2)) for i in range(len(archive))]\n    selected_index = min(normalized, key=lambda x: x[1])[0]\n    selected = archive[selected_index][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment permutation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if len(segment) > 1:\n        if random.random() < 0.7:\n            segment = np.random.permutation(segment)\n        else:\n            segment = segment[::-1]\n\n    # Dynamic node reinsertion\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(4, pos-1), min(4, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic segment translation\n    if random.random() < 0.6:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Conditional node reordering\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Multi-step repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure tour validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm uses a dynamic segment relocation strategy combined with objective-aware segment reversal to generate diverse neighbor solutions, adaptively selecting segments based on their potential improvement in both objective spaces while ensuring feasibility by carefully reinserting missing nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best harmonic mean of objectives\n    selected = max(archive, key=lambda x: 2 / (1/x[1][0] + 1/x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segment based on objective-aware criteria\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment cost in both objectives\n    def segment_cost(sol, start, length):\n        cost1 = distance_matrix_1[sol[start-1], sol[start]]\n        cost2 = distance_matrix_2[sol[start-1], sol[start]]\n        for i in range(start, start+length-1):\n            cost1 += distance_matrix_1[sol[i], sol[i+1]]\n            cost2 += distance_matrix_2[sol[i], sol[i+1]]\n        cost1 += distance_matrix_1[sol[start+length-1], sol[(start+length)%n]]\n        cost2 += distance_matrix_2[sol[start+length-1], sol[(start+length)%n]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = segment_cost(new_solution, start, segment_length)\n\n    # Try different segment operations\n    operations = [\n        segment[::-1],  # Reverse\n        np.roll(segment, 1),  # Rotate right\n        np.roll(segment, -1)  # Rotate left\n    ]\n\n    best_operation = segment\n    best_improvement = 0\n\n    for op in operations:\n        temp_sol = new_solution.copy()\n        temp_sol[start:start+segment_length] = op\n        new_cost1, new_cost2 = segment_cost(temp_sol, start, segment_length)\n\n        # Calculate improvement (normalized)\n        improvement = (current_cost1 - new_cost1) / (current_cost1 + 1e-6) + (current_cost2 - new_cost2) / (current_cost2 + 1e-6)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_operation = op\n\n    new_solution[start:start+segment_length] = best_operation\n\n    # Dynamic relocation\n    if random.random() < 0.7:\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos != start:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:new_pos],\n                segment,\n                new_solution[new_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9350322898204988,
            1.0397645235061646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best harmonic mean of objectives\n    selected = max(archive, key=lambda x: 2 / (1/x[1][0] + 1/x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segment based on objective-aware criteria\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment cost in both objectives\n    def segment_cost(sol, start, length):\n        cost1 = distance_matrix_1[sol[start-1], sol[start]]\n        cost2 = distance_matrix_2[sol[start-1], sol[start]]\n        for i in range(start, start+length-1):\n            cost1 += distance_matrix_1[sol[i], sol[i+1]]\n            cost2 += distance_matrix_2[sol[i], sol[i+1]]\n        cost1 += distance_matrix_1[sol[start+length-1], sol[(start+length)%n]]\n        cost2 += distance_matrix_2[sol[start+length-1], sol[(start+length)%n]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = segment_cost(new_solution, start, segment_length)\n\n    # Try different segment operations\n    operations = [\n        segment[::-1],  # Reverse\n        np.roll(segment, 1),  # Rotate right\n        np.roll(segment, -1)  # Rotate left\n    ]\n\n    best_operation = segment\n    best_improvement = 0\n\n    for op in operations:\n        temp_sol = new_solution.copy()\n        temp_sol[start:start+segment_length] = op\n        new_cost1, new_cost2 = segment_cost(temp_sol, start, segment_length)\n\n        # Calculate improvement (normalized)\n        improvement = (current_cost1 - new_cost1) / (current_cost1 + 1e-6) + (current_cost2 - new_cost2) / (current_cost2 + 1e-6)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_operation = op\n\n    new_solution[start:start+segment_length] = best_operation\n\n    # Dynamic relocation\n    if random.random() < 0.7:\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos != start:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:new_pos],\n                segment,\n                new_solution[new_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0307361098219516,
            0.24344688653945923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0307361098219516,
            0.24344688653945923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{An algorithm that uses a hybrid of random segment swaps with adaptive segment reversal and insertion, guided by a novel objective-aware score function that prioritizes solutions with balanced improvement potential in both objectives, to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if (selected[i-1] if i > 0 else selected[-1]) in segment:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8887801836610378,
            0.277169406414032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if (selected[i-1] if i > 0 else selected[-1]) in segment:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm uses a dynamic segment rotation with adaptive segment lengths and probabilistic inversion to generate diverse neighbors by selecting solutions with high potential for improvement based on a novel score function that considers both objective values and their ratio, while ensuring feasibility through careful node insertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = min(random.randint(2, n//3), n-2)\n    i = random.randint(0, n-segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-segment_length)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8982043213111416,
            0.3202006220817566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = min(random.randint(2, n//3), n-2)\n    i = random.randint(0, n-segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-segment_length)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{An algorithm that employs a hybrid approach of node swapping and segment rotation to generate neighbors by intelligently selecting and manipulating segments of the tour based on objective-aware criteria, ensuring feasibility through careful segment insertion and reversal operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    c = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.911387987875201,
            0.2027772068977356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    c = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive based on its combined objective improvement potential and applies a hybrid of adaptive path inversion with dynamic segment reallocation, combining probabilistic node clustering and segment-based displacement to explore the solution space while ensuring feasibility through an intelligent repair mechanism that maintains tour continuity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if b - a > 2 and random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic segment reallocation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(1, n-segment_length-1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Probabilistic node clustering\n    if random.random() < 0.6:\n        cluster_center = random.choice(segment)\n        cluster_indices = np.where(new_solution == cluster_center)[0]\n        if len(cluster_indices) > 1:\n            cluster_indices = sorted(cluster_indices)\n            for i in range(len(cluster_indices)-1):\n                if cluster_indices[i+1] - cluster_indices[i] > 1:\n                    new_solution[cluster_indices[i]+1:cluster_indices[i+1]] = new_solution[cluster_indices[i]+1:cluster_indices[i+1]][::-1]\n\n    # Segment-based displacement\n    new_pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Intelligent repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8148592061424214,
            0.41535305976867676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if b - a > 2 and random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic segment reallocation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(1, n-segment_length-1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Probabilistic node clustering\n    if random.random() < 0.6:\n        cluster_center = random.choice(segment)\n        cluster_indices = np.where(new_solution == cluster_center)[0]\n        if len(cluster_indices) > 1:\n            cluster_indices = sorted(cluster_indices)\n            for i in range(len(cluster_indices)-1):\n                if cluster_indices[i+1] - cluster_indices[i] > 1:\n                    new_solution[cluster_indices[i]+1:cluster_indices[i+1]] = new_solution[cluster_indices[i]+1:cluster_indices[i+1]][::-1]\n\n    # Segment-based displacement\n    new_pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Intelligent repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment permutation with probabilistic segment transposition to create diverse neighbors while ensuring feasibility through a multi-phase validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = np.random.permutation(segment)\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.884984028736147,
            0.44648152589797974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = np.random.permutation(segment)\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity score, combining Pareto dominance and crowding distance, then applies a hybrid of segment inversion with probabilistic node swapping and adaptive displacement to generate a neighbor solution while ensuring feasibility through a robust validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        crowding_distances = []\n        for i in range(1, len(sorted_archive)-1):\n            left = sorted_archive[i-1][1]\n            right = sorted_archive[i+1][1]\n            dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n            crowding_distances.append(dist)\n        max_idx = np.argmax(crowding_distances)\n        selected = sorted_archive[max_idx+1][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion with probabilistic node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive displacement with position-based probability\n    for i in range(1, n-1):\n        if random.random() < 0.3 + 0.4 * (i / n):\n            j = random.randint(1, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Robust repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8363987587016469,
            1.6416650414466858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        crowding_distances = []\n        for i in range(1, len(sorted_archive)-1):\n            left = sorted_archive[i-1][1]\n            right = sorted_archive[i+1][1]\n            dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n            crowding_distances.append(dist)\n        max_idx = np.argmax(crowding_distances)\n        selected = sorted_archive[max_idx+1][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment inversion with probabilistic node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive displacement with position-based probability\n    for i in range(1, n-1):\n        if random.random() < 0.3 + 0.4 * (i / n):\n            j = random.randint(1, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Robust repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that uses a dynamic segment fusion and adaptive multi-objective path relinking to combine promising segments from top-ranked solutions while maintaining feasibility and improving both objectives through a hybrid of segment merging and intelligent path relinking.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    top_solutions = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[:3]\n\n    # Create a base solution by merging segments from top solutions\n    base_solution = []\n    n = len(top_solutions[0][0])\n    segment_size = max(2, n // 6)\n\n    for i in range(0, n, segment_size):\n        # Alternate between top solutions for segment selection\n        source_idx = i // segment_size % len(top_solutions)\n        segment = top_solutions[source_idx][0][i:i+segment_size]\n        base_solution.extend(segment)\n\n    # Ensure all nodes are included (handle any missing nodes)\n    missing_nodes = set(range(n)) - set(base_solution)\n    if missing_nodes:\n        base_solution.extend(list(missing_nodes))\n\n    # Perform adaptive path relinking with multi-objective consideration\n    new_solution = base_solution.copy()\n    for _ in range(2):  # Perform multiple relinking steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = [x for x in new_solution if x not in segment1]\n\n        # Evaluate both possible merges\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        # Calculate costs for both options\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select the better option based on multi-objective tradeoff\n        if random.random() < 0.7:  # 70% chance to prefer balanced improvement\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                new_solution = option1\n            else:\n                new_solution = option2\n        else:  # 30% chance to prefer individual objective improvement\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    new_solution = option1\n                else:\n                    new_solution = option2\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm combines dynamic segment reordering with adaptive multi-objective segment swapping to create diverse neighbors by selectively reordering segments from promising solutions while maintaining feasibility and balancing improvements across both objectives through intelligent segment exchanges.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 1 / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment size based on problem size\n    segment_size = max(2, n // 4)\n\n    # Randomly select multiple segments and reorder them\n    num_segments = random.randint(2, min(4, n // segment_size))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_size)\n        segments.append(new_solution[start:start+segment_size])\n\n    # Shuffle the segments\n    random.shuffle(segments)\n\n    # Rebuild the solution with reordered segments\n    rebuilt_solution = []\n    for seg in segments:\n        rebuilt_solution.extend(seg)\n\n    # Add remaining nodes if any\n    remaining_nodes = set(selected_solution) - set(rebuilt_solution)\n    rebuilt_solution.extend(list(remaining_nodes))\n\n    # Perform multi-objective segment swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = rebuilt_solution[i:j]\n        segment2 = [x for x in rebuilt_solution if x not in segment1]\n\n        # Evaluate both possible swaps\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select based on multi-objective tradeoff\n        if random.random() < 0.6:\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                rebuilt_solution = option1\n            else:\n                rebuilt_solution = option2\n        else:\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    rebuilt_solution = option1\n                else:\n                    rebuilt_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    rebuilt_solution = option1\n                else:\n                    rebuilt_solution = option2\n\n    return np.array(rebuilt_solution)\n\n",
        "score": [
            -0.8084725006105695,
            1.1002413630485535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 1 / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment size based on problem size\n    segment_size = max(2, n // 4)\n\n    # Randomly select multiple segments and reorder them\n    num_segments = random.randint(2, min(4, n // segment_size))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_size)\n        segments.append(new_solution[start:start+segment_size])\n\n    # Shuffle the segments\n    random.shuffle(segments)\n\n    # Rebuild the solution with reordered segments\n    rebuilt_solution = []\n    for seg in segments:\n        rebuilt_solution.extend(seg)\n\n    # Add remaining nodes if any\n    remaining_nodes = set(selected_solution) - set(rebuilt_solution)\n    rebuilt_solution.extend(list(remaining_nodes))\n\n    # Perform multi-objective segment swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = rebuilt_solution[i:j]\n        segment2 = [x for x in rebuilt_solution if x not in segment1]\n\n        # Evaluate both possible swaps\n        option1 = segment1 + segment2\n        option2 = segment2 + segment1\n\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution))) + distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        cost1 = calculate_cost(option1)\n        cost2 = calculate_cost(option2)\n\n        # Select based on multi-objective tradeoff\n        if random.random() < 0.6:\n            if (cost1[0] + cost1[1]) < (cost2[0] + cost2[1]):\n                rebuilt_solution = option1\n            else:\n                rebuilt_solution = option2\n        else:\n            if random.random() < 0.5:\n                if cost1[0] < cost2[0]:\n                    rebuilt_solution = option1\n                else:\n                    rebuilt_solution = option2\n            else:\n                if cost1[1] < cost2[1]:\n                    rebuilt_solution = option1\n                else:\n                    rebuilt_solution = option2\n\n    return np.array(rebuilt_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel algorithm that combines dynamic segment relocations with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting solutions with high potential for improvement based on a combination of objective values and solution diversity, ensuring feasibility through careful segment manipulation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and invert one\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Randomly relocate a segment to a new position\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        segment_length = len(segment)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Repair solution to ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional adaptive inversion based on distance matrices\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        # Decide inversion based on which objective space has higher variance\n        if np.std(distance_matrix_1[new_solution]) > np.std(distance_matrix_2[new_solution]):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8552592312451408,
            0.48675721883773804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and invert one\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Randomly relocate a segment to a new position\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        segment_length = len(segment)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Repair solution to ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional adaptive inversion based on distance matrices\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        # Decide inversion based on which objective space has higher variance\n        if np.std(distance_matrix_1[new_solution]) > np.std(distance_matrix_2[new_solution]):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel hybrid of adaptive segment relocation with guided node reinsertion, combining dynamic segment inversion and probabilistic chain reversal to explore the solution space while ensuring feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.delete(new_solution, np.s_[:b])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic segment inversion with probability\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Probabilistic chain reversal\n    if random.random() < 0.6:\n        chain_length = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-chain_length-1)\n        new_solution[start:start+chain_length] = new_solution[start:start+chain_length][::-1]\n\n    # Guided node reinsertion\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        best_pos = 1\n        min_cost = float('inf')\n        for pos in range(1, len(new_solution)):\n            temp = np.insert(new_solution, pos, node_to_move)\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n            combined_cost = cost1 + cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9807984634111309,
            3.0987608432769775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.delete(new_solution, np.s_[:b])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic segment inversion with probability\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Probabilistic chain reversal\n    if random.random() < 0.6:\n        chain_length = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-chain_length-1)\n        new_solution[start:start+chain_length] = new_solution[start:start+chain_length][::-1]\n\n    # Guided node reinsertion\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        best_pos = 1\n        min_cost = float('inf')\n        for pos in range(1, len(new_solution)):\n            temp = np.insert(new_solution, pos, node_to_move)\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n            combined_cost = cost1 + cost2\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm uses a combination of adaptive segment extraction, dynamic node swapping, and probabilistic segment insertion to create diverse neighbors while maintaining feasibility, focusing on both objective spaces through weighted distance evaluations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment of nodes and store it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Probabilistically decide to reverse the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Insert the segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Perform dynamic node swapping based on both distance matrices\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    node1, node2 = new_solution[swap_pos1], new_solution[swap_pos2]\n\n    # Calculate weighted probability of swapping based on both objectives\n    dist1 = distance_matrix_1[node1, node2] + distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos2]] + distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos1]]\n    dist2 = distance_matrix_2[node1, node2] + distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos2]] + distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos1]]\n    swap_prob = 1 / (1 + (dist1 + dist2) / (new_solution.size * 100))\n\n    if random.random() < swap_prob:\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.31895216961585293,
            1.462496042251587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment of nodes and store it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Probabilistically decide to reverse the segment\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Insert the segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Perform dynamic node swapping based on both distance matrices\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    node1, node2 = new_solution[swap_pos1], new_solution[swap_pos2]\n\n    # Calculate weighted probability of swapping based on both objectives\n    dist1 = distance_matrix_1[node1, node2] + distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos2]] + distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos1]]\n    dist2 = distance_matrix_2[node1, node2] + distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos2]] + distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos1]]\n    swap_prob = 1 / (1 + (dist1 + dist2) / (new_solution.size * 100))\n\n    if random.random() < swap_prob:\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that uses a hybrid segment rotation with dynamic segment inversions and a modified score function to prioritize solutions with high potential for improvement by considering both objective values and their balance, while ensuring feasibility through intelligent segment manipulation and node insertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment rotation with dynamic segment inversion and node reinsertion, combining probabilistic segment reversal and adaptive node displacement to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9845247388578695,
            0.47841429710388184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(2, pos-1), min(2, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{A novel algorithm that intelligently selects a solution from the archive based on a dynamic selection score combining objective values and applies a hybrid segment relocation and inversion operator to generate diverse neighbors while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment relocation and inversion\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n\n    segment = new_solution[a:b]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Inversion with 50% probability\n\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    if c < len(new_solution):\n        new_solution = np.insert(new_solution, c, segment)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6907336174442029,
            2.2427645325660706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment relocation and inversion\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n\n    segment = new_solution[a:b]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Inversion with 50% probability\n\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    if c < len(new_solution):\n        new_solution = np.insert(new_solution, c, segment)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and rotate it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back into the solution\n    new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n    # Perform a random swap to further diversify\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7535971202714925,
            1.7837127447128296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and rotate it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back into the solution\n    new_solution = np.concatenate([new_solution[:i], rotated_segment, new_solution[j:]])\n\n    # Perform a random swap to further diversify\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects solutions from the archive based on a novel hybrid scoring combining normalized objective distances and solution entropy, then applies a dynamic segment-based local search with adaptive segment merging and probabilistic edge swapping to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return instance[:, 0].astype(int)\n\n    # Hybrid selection based on normalized objective distance and solution entropy\n    def score(sol_obj):\n        sol, obj = sol_obj\n        norm_dist = (abs(obj[0] - obj[1]) / max(obj[0], obj[1], 1e-6))\n        entropy = len(np.unique(sol)) / len(sol)\n        return norm_dist * entropy\n\n    selected = max(archive, key=score)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment-based local search\n    seg_size = max(2, min(5, n // 4))\n    a = random.randint(1, n - seg_size - 1)\n    segment = new_solution[a:a+seg_size].copy()\n\n    # Adaptive segment merging\n    if random.random() < 0.7:\n        b = random.randint(a+seg_size, min(n-1, a+2*seg_size))\n        segment = np.concatenate([segment, new_solution[a+seg_size:b]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, min(n-1, i+3))\n        segment = np.concatenate([segment[:i], segment[j:], segment[i:j]])\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8712700804387989,
            2.6050256490707397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return instance[:, 0].astype(int)\n\n    # Hybrid selection based on normalized objective distance and solution entropy\n    def score(sol_obj):\n        sol, obj = sol_obj\n        norm_dist = (abs(obj[0] - obj[1]) / max(obj[0], obj[1], 1e-6))\n        entropy = len(np.unique(sol)) / len(sol)\n        return norm_dist * entropy\n\n    selected = max(archive, key=score)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment-based local search\n    seg_size = max(2, min(5, n // 4))\n    a = random.randint(1, n - seg_size - 1)\n    segment = new_solution[a:a+seg_size].copy()\n\n    # Adaptive segment merging\n    if random.random() < 0.7:\n        b = random.randint(a+seg_size, min(n-1, a+2*seg_size))\n        segment = np.concatenate([segment, new_solution[a+seg_size:b]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, min(n-1, i+3))\n        segment = np.concatenate([segment[:i], segment[j:], segment[i:j]])\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{An algorithm that employs a hybrid of segment-based relocation and dynamic rotation with adaptive segment length selection to explore the solution space while maintaining feasibility and leveraging multi-objective awareness for neighbor generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insertion_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6088810854168448,
            1.4601404666900635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insertion_pos = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a hybrid approach of node swapping and segment rotation to generate neighbors by intelligently selecting and manipulating segments of the tour based on objective-aware criteria, ensuring feasibility through careful segment insertion and reversal operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    c = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{An algorithm that uses a combination of node reordering and segment inversion with objective-aware probabilistic selection to generate neighbors, ensuring feasibility through careful node preservation and segment manipulation while favoring solutions with balanced objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.52017077652618,
            0.7506546974182129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of segment reversal with adaptive segment shifting, combining probabilistic node insertion and dynamic segment reordering to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    shift = random.randint(-min(3, a), min(3, n-b))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Dynamic segment reordering\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        np.random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9349730989367085,
            0.35918891429901123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: min(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    shift = random.randint(-min(3, a), min(3, n-b))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Dynamic segment reordering\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        np.random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{An algorithm that dynamically combines segment shuffling with adaptive segment reversal and reinsertion, guided by objective-aware diversity measures to generate high-quality neighbors while ensuring feasibility through constrained segment manipulation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective score\n    scores = [sum(obj) / (1 + abs(obj[0] - obj[1])) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select segments and positions\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Adaptive segment manipulation\n    if random.random() < 0.7:\n        segment = segment[::-1]  # Reverse with higher probability\n    else:\n        segment = np.roll(segment, random.randint(1, segment_size-1))  # Rotate\n\n    # Reinsertion with objective awareness\n    insert_pos = random.randint(0, n - segment_size)\n    if insert_pos > start:\n        insert_pos -= segment_size\n\n    # Create new solution\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7199986284639753,
            0.620648205280304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective score\n    scores = [sum(obj) / (1 + abs(obj[0] - obj[1])) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select segments and positions\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Adaptive segment manipulation\n    if random.random() < 0.7:\n        segment = segment[::-1]  # Reverse with higher probability\n    else:\n        segment = np.roll(segment, random.randint(1, segment_size-1))  # Rotate\n\n    # Reinsertion with objective awareness\n    insert_pos = random.randint(0, n - segment_size)\n    if insert_pos > start:\n        insert_pos -= segment_size\n\n    # Create new solution\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{An algorithm that combines dynamic segment swapping with adaptive segment rotation and inversion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9457717479303285,
            0.2010955810546875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel algorithm that uses a dynamic segment inversion and insertion strategy with adaptive segment selection based on both objectives' contributions to select solutions for local improvement, ensuring diverse neighborhood exploration while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9005925979844952,
            0.24317699670791626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{An algorithm that uses a hybrid approach of adaptive segment swapping and dynamic segment inversion to generate high-quality neighbor solutions, prioritizing solutions with balanced objective improvements and incorporating instance-specific distance information for more targeted local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: min(x[1][0], x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segments based on distance information\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Adaptive segment manipulation\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Dynamic insertion with distance awareness\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert at position that minimizes both objectives\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                temp = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n))\n                if cost1 + cost2 < min_cost:\n                    min_cost = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.942181876300642,
            0.2383975386619568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: min(x[1][0], x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segments based on distance information\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Adaptive segment manipulation\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Dynamic insertion with distance awareness\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert at position that minimizes both objectives\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                temp = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n))\n                if cost1 + cost2 < min_cost:\n                    min_cost = cost1 + cost2\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective trade-off ratio and applies a novel hybrid local search combining adaptive segment reversal with probabilistic node insertion and dynamic segment displacement, ensuring feasibility through comprehensive validation and repair mechanisms while exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Dynamic segment displacement\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        segment = new_solution[k:k+random.randint(1, min(5, n-k))]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+len(segment):], segment])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.5324617517560465,
            0.6619728803634644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Dynamic segment displacement\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        segment = new_solution[k:k+random.randint(1, min(5, n-k))]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+len(segment):], segment])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.setdiff1d(new_solution, unique_nodes)\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel diversity score combining both objectives, then applies a hybrid of adaptive segment relocation with probabilistic node insertion and dynamic segment reversal to explore the solution space while ensuring feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(10, n//2))\n    start = random.randint(1, n-segment_length-1)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        insert_pos = random.randint(1, n-segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        new_solution = new_solution[:n]\n\n    # Dynamic segment reversal\n    if random.random() < 0.6:\n        rev_start = random.randint(1, n-2)\n        rev_length = random.randint(2, min(8, n-rev_start))\n        new_solution[rev_start:rev_start+rev_length] = new_solution[rev_start:rev_start+rev_length][::-1]\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9789978316097511,
            0.4459213614463806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(10, n//2))\n    start = random.randint(1, n-segment_length-1)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        insert_pos = random.randint(1, n-segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        new_solution = new_solution[:n]\n\n    # Dynamic segment reversal\n    if random.random() < 0.6:\n        rev_start = random.randint(1, n-2)\n        rev_length = random.randint(2, min(8, n-rev_start))\n        new_solution[rev_start:rev_start+rev_length] = new_solution[rev_start:rev_start+rev_length][::-1]\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Ensure circularity\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{An algorithm that employs adaptive segment decomposition with objective-aware segment swapping and rotation to generate diverse neighbors by dynamically selecting and manipulating segments based on their potential improvement in both objectives, while ensuring feasibility through constrained segment reinsertion and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and a rotation point\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n    rot_point = random.randint(0, n-1)\n\n    # Extract segments and optionally rotate\n    segment1 = new_solution[seg1_start:seg1_end]\n    segment2 = new_solution[seg2_start:seg2_end]\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Swap segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        segment2,\n        new_solution[seg1_end:seg2_start],\n        segment1,\n        new_solution[seg2_end:]\n    ])\n\n    # Rotate segments\n    if rot_point < len(new_solution):\n        new_solution = np.concatenate([\n            new_solution[rot_point:],\n            new_solution[:rot_point]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8465746624486741,
            0.396933913230896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and a rotation point\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n    rot_point = random.randint(0, n-1)\n\n    # Extract segments and optionally rotate\n    segment1 = new_solution[seg1_start:seg1_end]\n    segment2 = new_solution[seg2_start:seg2_end]\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Swap segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        segment2,\n        new_solution[seg1_end:seg2_start],\n        segment1,\n        new_solution[seg2_end:]\n    ])\n\n    # Rotate segments\n    if rot_point < len(new_solution):\n        new_solution = np.concatenate([\n            new_solution[rot_point:],\n            new_solution[:rot_point]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{An algorithm that combines a dynamic segment inversion with adaptive segment shifting and rotation, guided by objective-aware segment selection and feasibility-preserving operations, to generate diverse neighbor solutions while maintaining tour validity and exploring the solution space through non-uniform segment manipulations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Identify segments with high potential for improvement\n    segment_length = max(2, n // 5)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Apply dynamic inversion and shifting\n    if random.random() < 0.7:\n        segment = segment[::-1]\n    shift = random.randint(1, n - segment_length)\n\n    # Reinsert the segment at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_solution = np.insert(new_solution, (start + shift) % len(new_solution), segment)\n\n    # Apply adaptive rotation based on objective values\n    if random.random() < 0.5:\n        rotate_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.roll(new_solution, rotate_pos)\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9410650873080948,
            1.3007144331932068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Identify segments with high potential for improvement\n    segment_length = max(2, n // 5)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Apply dynamic inversion and shifting\n    if random.random() < 0.7:\n        segment = segment[::-1]\n    shift = random.randint(1, n - segment_length)\n\n    # Reinsert the segment at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_solution = np.insert(new_solution, (start + shift) % len(new_solution), segment)\n\n    # Apply adaptive rotation based on objective values\n    if random.random() < 0.5:\n        rotate_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.roll(new_solution, rotate_pos)\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of objective-aware segment rotation with probabilistic node swapping, combining adaptive segment displacement and position-based node reallocation to explore the solution space while maintaining tour feasibility through a combination of segment validation and dynamic repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    if random.random() < 0.5:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = segment\n\n    # Probabilistic node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment displacement\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Position-based node reallocation\n    if random.random() < 0.5:\n        pos = random.randint(1, n-2)\n        if pos < n//2:\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:pos+2], new_solution[pos:pos+1], new_solution[pos+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:pos+1], new_solution[pos:pos+1], new_solution[pos+1:pos+2], new_solution[pos+2:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.4225623000639755,
            0.7461092472076416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    if random.random() < 0.5:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = segment\n\n    # Probabilistic node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment displacement\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        pos = random.randint(1, n-1)\n        displacement = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Position-based node reallocation\n    if random.random() < 0.5:\n        pos = random.randint(1, n-2)\n        if pos < n//2:\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:pos+2], new_solution[pos:pos+1], new_solution[pos+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:pos+1], new_solution[pos:pos+1], new_solution[pos+1:pos+2], new_solution[pos+2:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of dynamic segment reversal with probabilistic segment insertion, combining adaptive segment shifting and conditional node transposition to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic segment insertion\n    if random.random() < 0.6:\n        pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_solution = new_solution[:n]\n\n    # Adaptive segment shifting\n    shift = random.randint(-3, 3)\n    if shift != 0:\n        segment_start = random.randint(1, n-1)\n        segment_length = min(5, n - segment_start)\n        segment = new_solution[segment_start:segment_start+segment_length].copy()\n        new_pos = max(1, min(n-1, segment_start + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = new_solution[:n]\n\n    # Conditional node transposition\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.43084534064002866,
            0.4783388376235962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Probabilistic segment insertion\n    if random.random() < 0.6:\n        pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_solution = new_solution[:n]\n\n    # Adaptive segment shifting\n    shift = random.randint(-3, 3)\n    if shift != 0:\n        segment_start = random.randint(1, n-1)\n        segment_length = min(5, n - segment_start)\n        segment = new_solution[segment_start:segment_start+segment_length].copy()\n        new_pos = max(1, min(n-1, segment_start + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = new_solution[:n]\n\n    # Conditional node transposition\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance, then applies a hybrid of segment rotation with adaptive node clustering and probabilistic segment inversion to generate diverse neighbors while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive clustering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment inversion\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive node clustering\n    cluster_size = min(3, len(segment))\n    clusters = [segment[i:i+cluster_size] for i in range(0, len(segment), cluster_size)]\n    random.shuffle(clusters)\n    segment = np.concatenate(clusters)\n\n    # Reinsert segment with rotation\n    pos = random.randint(1, n-1)\n    rotation = random.randint(0, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Node clustering and reallocation\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n        cluster = new_solution[i:j]\n        new_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9120693583820176,
            0.3573698401451111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with adaptive clustering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment inversion\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive node clustering\n    cluster_size = min(3, len(segment))\n    clusters = [segment[i:i+cluster_size] for i in range(0, len(segment), cluster_size)]\n    random.shuffle(clusters)\n    segment = np.concatenate(clusters)\n\n    # Reinsert segment with rotation\n    pos = random.randint(1, n-1)\n    rotation = random.randint(0, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution = np.concatenate([new_solution[:pos], rotated_segment, new_solution[pos:]])\n\n    # Node clustering and reallocation\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n        cluster = new_solution[i:j]\n        new_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on its normalized objective scores, then applies a hybrid of segment inversion with adaptive node reinsertion and probabilistic edge swapping to explore the solution space while maintaining feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] / (x[1][0] + x[1][1] + 1e-6) - x[1][1] / (x[1][0] + x[1][1] + 1e-6))**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    seg_length = min(5, max(2, int(random.expovariate(1.0))))\n    a = random.randint(1, n - seg_length - 1)\n    segment = new_solution[a:a+seg_length]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[a+seg_length:]])\n\n    # Adaptive node reinsertion\n    if random.random() < 0.8:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.845222561203582,
            1.4522322416305542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] / (x[1][0] + x[1][1] + 1e-6) - x[1][1] / (x[1][0] + x[1][1] + 1e-6))**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    seg_length = min(5, max(2, int(random.expovariate(1.0))))\n    a = random.randint(1, n - seg_length - 1)\n    segment = new_solution[a:a+seg_length]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[a+seg_length:]])\n\n    # Adaptive node reinsertion\n    if random.random() < 0.8:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel algorithm that combines adaptive segment swapping with dynamic path reordering to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to reduce both objectives, while ensuring feasibility through careful node reinsertion and path validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9555497202268431,
            0.2593122124671936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{An algorithm that employs a hybrid of dynamic segment swapping and adaptive segment rotation to generate diverse neighbor solutions by intelligently selecting segments based on their contribution to both objectives, ensuring feasibility through careful segment reinsertion and rotation, and exploring the solution space through objective-aware segment manipulations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.877432962212606,
            0.22311842441558838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel algorithm that uses a weighted combination of objective values to select a solution from the archive, followed by a hybrid segment rotation and insertion strategy that dynamically adjusts segment sizes and positions to generate diverse, high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8188182446320442,
            0.1965809464454651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in the objective space and applies a hybrid of segment crossover with adaptive segment reversal, combining dynamic segment insertion and probabilistic edge swapping to explore the solution space while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment crossover with adaptive reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    if c > a and d < b:\n        c, d = d, c\n    segment2 = new_solution[c:d].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n        segment2 = segment2[::-1]\n\n    # Dynamic segment insertion\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = np.concatenate([new_solution[:pos+len(segment)], segment2, new_solution[pos+len(segment):]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.79623432614255,
            0.29256564378738403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment crossover with adaptive reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    if c > a and d < b:\n        c, d = d, c\n    segment2 = new_solution[c:d].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n        segment2 = segment2[::-1]\n\n    # Dynamic segment insertion\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n    new_solution = np.concatenate([new_solution[:pos+len(segment)], segment2, new_solution[pos+len(segment):]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{A novel algorithm that combines adaptive segment swaps with probabilistic segment rotations to generate high-quality neighbor solutions by dynamically adjusting segment lengths and rotation probabilities based on solution quality and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Dynamic rotation probability based on solution quality\n    rotation_prob = min(0.8, (archive[0][1][0] + archive[0][1][1]) / (sum(x[1][0] + x[1][1] for x in archive) + 1e-6))\n\n    if random.random() < rotation_prob:\n        # Segment rotation\n        segment = new_solution[i:j]\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[i:j] = segment\n    else:\n        # Segment swap with variable length\n        k = random.randint(0, n - segment_length)\n        l = k + segment_length\n        new_solution[i:j], new_solution[k:l] = new_solution[k:l], new_solution[i:j]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8547752076987607,
            0.4004485011100769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Dynamic rotation probability based on solution quality\n    rotation_prob = min(0.8, (archive[0][1][0] + archive[0][1][1]) / (sum(x[1][0] + x[1][1] for x in archive) + 1e-6))\n\n    if random.random() < rotation_prob:\n        # Segment rotation\n        segment = new_solution[i:j]\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[i:j] = segment\n    else:\n        # Segment swap with variable length\n        k = random.randint(0, n - segment_length)\n        l = k + segment_length\n        new_solution[i:j], new_solution[k:l] = new_solution[k:l], new_solution[i:j]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel adaptive segment shuffling operator that dynamically reorders segments of the tour while maintaining feasibility through a probabilistic segment merging and splitting mechanism, ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    k = random.randint(2, min(5, n//2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic segment merging and splitting\n    if random.random() < 0.7:\n        split_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:split_pos], new_solution[split_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5505304475692658,
            1.3535543084144592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    k = random.randint(2, min(5, n//2))\n    segments = [new_solution[i:i+k] for i in range(0, n, k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic segment merging and splitting\n    if random.random() < 0.7:\n        split_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:split_pos], new_solution[split_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a hybrid objective-aware selection criterion, then applies a dynamic segment exchange and rotation operator that intelligently combines segments from different parts of the solution while maintaining feasibility through a node validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + x[1][0] * 0.3 + x[1][1] * 0.7))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment exchange and rotation\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Node validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        extra_nodes = [node for node in new_solution if np.count_nonzero(new_solution == node) > 1]\n\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n        for node in extra_nodes:\n            indices = np.where(new_solution == node)[0]\n            if len(indices) > 1:\n                for idx in indices[1:]:\n                    new_solution = np.delete(new_solution, idx)\n\n    return new_solution\n\n",
        "score": [
            -0.8134497269123071,
            0.36749333143234253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + x[1][0] * 0.3 + x[1][1] * 0.7))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment exchange and rotation\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]])\n\n    # Node validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        extra_nodes = [node for node in new_solution if np.count_nonzero(new_solution == node) > 1]\n\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n        for node in extra_nodes:\n            indices = np.where(new_solution == node)[0]\n            if len(indices) > 1:\n                for idx in indices[1:]:\n                    new_solution = np.delete(new_solution, idx)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines dynamic segment swapping with adaptive segment rotation and inversion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{An algorithm that combines adaptive segment rearrangement with dynamic segment merging and splitting to generate diverse neighbor solutions by intelligently selecting segments based on their contribution to both objectives and then applying context-aware transformations to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = np.concatenate([segment1, segment2])\n    else:\n        segment1 = np.concatenate([segment2, segment1])\n\n    new_solution = np.concatenate([new_solution[:i], segment1, new_solution[j:]])\n\n    if random.random() < 0.3:\n        split_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[split_pos:], new_solution[:split_pos]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.844067606863969,
            0.20715874433517456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = np.concatenate([segment1, segment2])\n    else:\n        segment1 = np.concatenate([segment2, segment1])\n\n    new_solution = np.concatenate([new_solution[:i], segment1, new_solution[j:]])\n\n    if random.random() < 0.3:\n        split_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[split_pos:], new_solution[:split_pos]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{An algorithm that combines adaptive segment fragmentation with dynamic segment reassembly and objective-aware segment inversion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if random.random() < 0.7:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        fragment_size = random.randint(1, min(3, len(segment)))\n        fragment = segment[:fragment_size]\n        new_solution = np.concatenate([new_solution[:i], fragment, new_solution[i:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.944989308240645,
            0.4730103015899658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if random.random() < 0.7:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        fragment_size = random.randint(1, min(3, len(segment)))\n        fragment = segment[:fragment_size]\n        new_solution = np.concatenate([new_solution[:i], fragment, new_solution[i:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel algorithm that intelligently selects a solution from the archive based on objective diversity and applies a hybrid segment rotation and insertion operator with adaptive segment selection to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segments intelligently based on distance matrices\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Determine insertion point based on both distance matrices\n    insertion_costs = []\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue\n        # Calculate insertion cost using both distance matrices\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        insertion_costs.append((cost1 + cost2, i))\n\n    if insertion_costs:\n        best_insert = min(insertion_costs, key=lambda x: x[0])[1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        new_solution = np.insert(new_solution, best_insert, segment)\n\n    # Apply adaptive segment rotation\n    if random.random() < 0.3:\n        rotate_pos = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, rotate_pos)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.30298076750924147,
            1.5396501421928406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select segments intelligently based on distance matrices\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Determine insertion point based on both distance matrices\n    insertion_costs = []\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue\n        # Calculate insertion cost using both distance matrices\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        insertion_costs.append((cost1 + cost2, i))\n\n    if insertion_costs:\n        best_insert = min(insertion_costs, key=lambda x: x[0])[1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        new_solution = np.insert(new_solution, best_insert, segment)\n\n    # Apply adaptive segment rotation\n    if random.random() < 0.3:\n        rotate_pos = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, rotate_pos)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives and applies a hybrid of segment reversal with probabilistic segment insertion, combined with adaptive node swapping and dynamic segment shifting to explore the solution space while maintaining feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probabilistic insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment shifting\n    shift = random.randint(-3, 3)\n    if shift != 0:\n        segment_len = random.randint(2, min(5, n-2))\n        start = random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n        new_pos = (start + shift) % (n-1)\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9361930836361451,
            0.3067612648010254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probabilistic insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Adaptive node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment shifting\n    shift = random.randint(-3, 3)\n    if shift != 0:\n        segment_len = random.randint(2, min(5, n-2))\n        start = random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n        new_pos = (start + shift) % (n-1)\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel algorithm that combines a multi-segment extraction with adaptive segment fusion and dynamic segment inversion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segments = []\n    for _ in range(random.randint(2, 4)):\n        i, j = sorted(random.sample(range(n), 2))\n        segments.append((i, j))\n\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for i, j in merged_segments:\n        segment = new_solution[i:j]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9194601049693372,
            1.3629959225654602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segments = []\n    for _ in range(random.randint(2, 4)):\n        i, j = sorted(random.sample(range(n), 2))\n        segments.append((i, j))\n\n    segments.sort()\n    merged_segments = []\n    current_start, current_end = segments[0]\n\n    for start, end in segments[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged_segments.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged_segments.append((current_start, current_end))\n\n    for i, j in merged_segments:\n        segment = new_solution[i:j]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment insertion with adaptive segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9324851077238556,
            0.18121695518493652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel algorithm that combines a dynamic segment reversal with adaptive segment insertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by prioritizing solutions with balanced objective trade-offs and using segment operations that adapt to the problem's structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.insert(new_solution, k, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8607442799028101,
            0.2439153790473938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.insert(new_solution, k, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel algorithm that combines a multi-segment extraction with adaptive segment merging and rotation, guided by objective-aware distance metrics to generate high-quality neighbors while ensuring feasibility through dynamic segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 2 * x[1][0] * x[1][1] / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract multiple segments and merge them\n    segments = []\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segments.append(new_solution[i:j])\n\n    # Adaptive rotation of segments\n    for seg in segments:\n        if random.random() < 0.7:\n            seg = seg[::-1]\n\n    # Merge segments with validation\n    merged = np.concatenate(segments)\n    if len(np.unique(merged)) == len(merged):\n        # Insert merged segments at random positions\n        for seg in segments:\n            pos = random.randint(0, len(new_solution) - len(seg))\n            new_solution = np.concatenate([new_solution[:pos], seg, new_solution[pos+len(seg):]])\n\n    # Ensure feasibility by repairing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Final validation and repair\n    if len(new_solution) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n    elif len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(np.arange(n))\n\n    return new_solution\n\n",
        "score": [
            -0.9915123011180672,
            1.515750765800476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 2 * x[1][0] * x[1][1] / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract multiple segments and merge them\n    segments = []\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segments.append(new_solution[i:j])\n\n    # Adaptive rotation of segments\n    for seg in segments:\n        if random.random() < 0.7:\n            seg = seg[::-1]\n\n    # Merge segments with validation\n    merged = np.concatenate(segments)\n    if len(np.unique(merged)) == len(merged):\n        # Insert merged segments at random positions\n        for seg in segments:\n            pos = random.randint(0, len(new_solution) - len(seg))\n            new_solution = np.concatenate([new_solution[:pos], seg, new_solution[pos+len(seg):]])\n\n    # Ensure feasibility by repairing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Final validation and repair\n    if len(new_solution) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n    elif len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(np.arange(n))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a novel adaptive segment insertion with dynamic segment reversal and probabilistic segment displacement to generate high-quality neighbors while ensuring feasibility through a multi-phase repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    insertion_pos = random.randint(1, n-1)\n    if insertion_pos >= a and insertion_pos <= b:\n        insertion_pos = b + 1 if b + 1 < n else a - 1\n\n    new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8892232851453499,
            0.3976835012435913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    insertion_pos = random.randint(1, n-1)\n    if insertion_pos >= a and insertion_pos <= b:\n        insertion_pos = b + 1 if b + 1 < n else a - 1\n\n    new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment reversal with probabilistic node insertion, combining dynamic segment shifting and conditional edge flipping to explore the solution space while maintaining feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic segment shifting\n    shift = random.randint(1, min(5, n//2))\n    new_solution = np.roll(new_solution, shift)\n\n    # Conditional edge flipping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        if distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i-1], new_solution[i+1]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6991518155915135,
            1.8353699445724487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic segment shifting\n    shift = random.randint(1, min(5, n//2))\n    new_solution = np.roll(new_solution, shift)\n\n    # Conditional edge flipping\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        if distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i-1], new_solution[i+1]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that uses a hybrid segment rotation with dynamic segment inversions and a modified score function to prioritize solutions with high potential for improvement by considering both objective values and their balance, while ensuring feasibility through intelligent segment manipulation and node insertion.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel algorithm that intelligently selects a solution from the archive based on a dynamically weighted score combining objective values and their variance, then applies a hybrid segment relocation and inversion operator with adaptive segment length and position selection to generate diverse high-quality neighbors while ensuring feasibility through comprehensive node validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dynamic_score(obj):\n        mean = (obj[0] + obj[1]) / 2\n        variance = abs(obj[0] - obj[1])\n        return mean + 0.5 * variance\n\n    selected = max(archive, key=lambda x: dynamic_score(x[1]))[0].copy()\n\n    # Hybrid segment relocation and inversion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Select adaptive segment length\n    segment_length = random.randint(1, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n\n    # Decide whether to invert or not\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert segment at new position\n    new_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Validate and repair solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional local improvement\n    if len(new_solution) > 3:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8593677348132559,
            1.632005214691162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dynamic_score(obj):\n        mean = (obj[0] + obj[1]) / 2\n        variance = abs(obj[0] - obj[1])\n        return mean + 0.5 * variance\n\n    selected = max(archive, key=lambda x: dynamic_score(x[1]))[0].copy()\n\n    # Hybrid segment relocation and inversion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Select adaptive segment length\n    segment_length = random.randint(1, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n\n    # Decide whether to invert or not\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert segment at new position\n    new_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Validate and repair solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Additional local improvement\n    if len(new_solution) > 3:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines dynamic segment swapping with adaptive segment rotation and inversion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:] if k < i else new_solution[:k]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{An algorithm that combines adaptive segment reversal with dynamic segment insertion and objective-aware segment rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    if random.random() < 0.3:\n        l = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        if l != m:\n            new_solution[[l, m]] = new_solution[[m, l]]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9119908880715953,
            1.9185338020324707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    if random.random() < 0.3:\n        l = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        if l != m:\n            new_solution[[l, m]] = new_solution[[m, l]]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A novel algorithm that selects a solution from the archive with high potential for improvement based on a diversity-aware score, then applies a hybrid segment relocation and inversion operator to generate neighbors while ensuring feasibility and exploring the solution space through adaptive segment selection and dynamic segment manipulation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select two random segments with adaptive size\n    seg_size = min(3, n // 2)\n    i = random.randint(0, n - seg_size)\n    j = random.randint(0, n - seg_size)\n    segment1 = new_solution[i:i+seg_size]\n    segment2 = new_solution[j:j+seg_size]\n\n    # Apply hybrid operation: relocate and invert segments\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], segment2[::-1], new_solution[i+seg_size:]])\n        new_solution = np.concatenate([new_solution[:j], segment1[::-1], new_solution[j+seg_size:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[i+seg_size:]])\n        new_solution = np.concatenate([new_solution[:j], segment1, new_solution[j+seg_size:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        random.shuffle(missing)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.398580317944367,
            1.3796724677085876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select two random segments with adaptive size\n    seg_size = min(3, n // 2)\n    i = random.randint(0, n - seg_size)\n    j = random.randint(0, n - seg_size)\n    segment1 = new_solution[i:i+seg_size]\n    segment2 = new_solution[j:j+seg_size]\n\n    # Apply hybrid operation: relocate and invert segments\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], segment2[::-1], new_solution[i+seg_size:]])\n        new_solution = np.concatenate([new_solution[:j], segment1[::-1], new_solution[j+seg_size:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[i+seg_size:]])\n        new_solution = np.concatenate([new_solution[:j], segment1, new_solution[j+seg_size:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        random.shuffle(missing)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic objective balance score that considers both objective values and their relative improvement potential, then applies a hybrid of adaptive segment rotation with probabilistic node swapping, ensuring tour feasibility through a multi-step validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    rotation = random.randint(1, b-a)\n    segment = np.roll(segment, rotation)\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-step repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for m in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, m)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.4496725661318117,
            1.550844967365265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    rotation = random.randint(1, b-a)\n    segment = np.roll(segment, rotation)\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-step repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for m in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, m)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{A novel algorithm that dynamically selects a solution from the archive based on a weighted objective score, then applies a hybrid segment rotation and inversion strategy to generate a neighbor solution while ensuring feasibility through node validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9947595232469151,
            0.4426952600479126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment rotation with probabilistic node insertion, combining geometric transformation and neighborhood exploration to generate diverse high-quality solutions while ensuring tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    angle = random.choice([90, 180, 270])\n    rotated_segment = segment.copy()\n    if angle == 90:\n        rotated_segment = np.roll(segment, 1)\n    elif angle == 180:\n        rotated_segment = segment[::-1]\n    else:\n        rotated_segment = np.roll(segment[::-1], 1)\n\n    new_solution[i:i+segment_length] = rotated_segment\n\n    if random.random() < 0.8:\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.4520987521245349,
            1.562586784362793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    angle = random.choice([90, 180, 270])\n    rotated_segment = segment.copy()\n    if angle == 90:\n        rotated_segment = np.roll(segment, 1)\n    elif angle == 180:\n        rotated_segment = segment[::-1]\n    else:\n        rotated_segment = np.roll(segment[::-1], 1)\n\n    new_solution[i:i+segment_length] = rotated_segment\n\n    if random.random() < 0.8:\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on the sum of normalized objective values and applies a hybrid of segment inversion with dynamic segment insertion and probabilistic node swapping to generate diverse neighbor solutions while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(x[1][0] + x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / max_obj if max_obj != 0 else 1)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with dynamic insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7938993773901528,
            0.21185725927352905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(x[1][0] + x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / max_obj if max_obj != 0 else 1)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with dynamic insertion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combined objective score incorporating both cost values and their historical improvement trends, then applies a hybrid segment relocation and rotation operator with dynamically adjusted segment lengths and positions to generate diverse, high-quality neighbors while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment length based on solution size\n    segment_length = random.randint(3, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Extract and optionally rotate the segment\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        rotation = random.randint(1, segment_length-1)\n        segment = np.roll(segment, rotation)\n\n    # Relocate the segment to a new position\n    k = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Remove original segment if it wasn't overwritten\n    if k < i:\n        new_solution = np.concatenate([new_solution[:i+k], new_solution[i+j:]])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Optional: Apply a small perturbation to break symmetry\n    if random.random() < 0.3:\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.7292821246183042,
            0.7454021573066711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment length based on solution size\n    segment_length = random.randint(3, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Extract and optionally rotate the segment\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        rotation = random.randint(1, segment_length-1)\n        segment = np.roll(segment, rotation)\n\n    # Relocate the segment to a new position\n    k = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Remove original segment if it wasn't overwritten\n    if k < i:\n        new_solution = np.concatenate([new_solution[:i+k], new_solution[i+j:]])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Optional: Apply a small perturbation to break symmetry\n    if random.random() < 0.3:\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment inversion with probabilistic node swapping, combining adaptive segment rotation and position-based reinsertion to explore the solution space while ensuring tour feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with probabilistic node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment rotation\n    if random.random() < 0.4:\n        k = random.randint(1, min(3, n-2))\n        segment = np.roll(segment, k)\n\n    # Position-based reinsertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.3524274202223189,
            1.4032914638519287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion with probabilistic node swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment rotation\n    if random.random() < 0.4:\n        k = random.randint(1, min(3, n-2))\n        segment = np.roll(segment, k)\n\n    # Position-based reinsertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{An algorithm that uses a multi-criteria tournament selection to choose solutions with high potential for improvement, followed by a novel adaptive segment relocation and inversion operator that dynamically adjusts segment size and position based on both objective space distances, while ensuring feasibility through a comprehensive repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected = max(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on both distance matrices\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * n)\n\n    segment_length = max(2, min(7, int(avg_dist / (total_dist1 + total_dist2 + 1e-6) * n)))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment relocation and inversion\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.911312231378249,
            1.7226078510284424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected = max(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on both distance matrices\n    total_dist1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * n)\n\n    segment_length = max(2, min(7, int(avg_dist / (total_dist1 + total_dist2 + 1e-6) * n)))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment relocation and inversion\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8467069099225832,
            0.33392995595932007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{A novel algorithm that uses a weighted harmonic mean of objectives to select solutions, then applies a combination of segment reversals and insertions with dynamic segment length adjustments to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 / (0.3 / x[1][0] + 0.7 / x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = random.randint(2, min(5, n // 2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment operations\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]  # Reverse segment\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])  # Move segment\n\n    # Insertion operation\n    if random.random() < 0.3:\n        k = random.randint(0, len(new_solution) - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9100394304372059,
            1.8627236485481262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 / (0.3 / x[1][0] + 0.7 / x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = random.randint(2, min(5, n // 2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment operations\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]  # Reverse segment\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])  # Move segment\n\n    # Insertion operation\n    if random.random() < 0.3:\n        k = random.randint(0, len(new_solution) - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{An algorithm that combines a dynamic node relocation strategy with adaptive segment inversion and rotation, prioritizing solutions with balanced objective improvements while ensuring feasibility through intelligent repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_size = random.randint(2, min(5, n//3))\n    start_idx = random.randint(0, n - segment_size)\n\n    segment = new_solution[start_idx:start_idx+segment_size]\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx+segment_size:]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    node_to_relocate = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_relocate]\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_relocate)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6475614567577891,
            2.094842851161957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_size = random.randint(2, min(5, n//3))\n    start_idx = random.randint(0, n - segment_size)\n\n    segment = new_solution[start_idx:start_idx+segment_size]\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx+segment_size:]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    node_to_relocate = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_relocate]\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_relocate)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a dynamic selection criterion combining both objectives, then applies a hybrid operation of segment relocation with probabilistic segment reversal to generate a diverse neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection criterion combining both objectives\n    def selection_score(solution, obj):\n        return (obj[0] + obj[1]) / (obj[0] * obj[1] + 1e-6) + np.random.uniform(0, 0.1)\n\n    selected = max(archive, key=lambda x: selection_score(x[0], x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment relocation with probabilistic reversal\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.3:  # 30% chance to reverse the segment\n        segment = segment[::-1]\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Insert the segment at new position k\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution, segment])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7820711474070692,
            2.2528260350227356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection criterion combining both objectives\n    def selection_score(solution, obj):\n        return (obj[0] + obj[1]) / (obj[0] * obj[1] + 1e-6) + np.random.uniform(0, 0.1)\n\n    selected = max(archive, key=lambda x: selection_score(x[0], x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment relocation with probabilistic reversal\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.3:  # 30% chance to reverse the segment\n        segment = segment[::-1]\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Insert the segment at new position k\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution, segment])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{An algorithm that uses adaptive segment swapping with dynamic rotation and objective-aware segment selection to generate diverse neighbors by intelligently combining segments from different parts of the tour while maintaining feasibility through careful segment extraction and reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.896566770087952,
            2.3682891130447388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of dynamic segment relocation with probabilistic inversion, combining adaptive segment rotation and node exchange to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Adaptive segment rotation\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[-rotation:], segment[:-rotation]])\n\n    # Probabilistic inversion\n    if random.random() < 0.3:\n        segment = segment[::-1]\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Node exchange\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9624409954331201,
            0.29890966415405273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Adaptive segment rotation\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[-rotation:], segment[:-rotation]])\n\n    # Probabilistic inversion\n    if random.random() < 0.3:\n        segment = segment[::-1]\n\n    # Insert segment at new position\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Node exchange\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{A novel algorithm that dynamically selects solutions based on a weighted sum of objectives with adaptive weights, then applies a hybrid local search combining segment rotations and dynamic inversions, ensuring feasibility and exploring the solution space by prioritizing solutions with high potential for improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 2)\n    selected = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation with dynamic inversion\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Dynamic inversion with probability\n    if random.random() < 0.4:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Segment rotation\n    if k < len(new_solution):\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9036705984897457,
            0.41309666633605957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 2)\n    selected = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation with dynamic inversion\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Dynamic inversion with probability\n    if random.random() < 0.4:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Segment rotation\n    if k < len(new_solution):\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that considers both the normalized objective values and their relative improvement potential, then applies a novel hybrid operator that combines multi-segment relocation with adaptive segment inversion and objective-aware node swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][0] + x[1][1] + 1e-6) + x[1][1] / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation with adaptive segment count\n    num_segments = random.randint(1, min(3, n//4))\n    segments = []\n    segment_indices = []\n\n    for _ in range(num_segments):\n        seg_len = random.randint(2, min(4, n//num_segments))\n        i = random.randint(0, n - seg_len)\n        segments.append(new_solution[i:i+seg_len])\n        segment_indices.append((i, i+seg_len))\n\n    # Remove segments from solution\n    for i, (start, end) in enumerate(sorted(segment_indices, reverse=True)):\n        new_solution = np.delete(new_solution, slice(start, end))\n\n    # Reinsert segments at new positions\n    for seg in segments:\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, seg)\n\n    # Adaptive segment inversion based on objective improvement\n    if random.random() < 0.6:\n        for seg in segments:\n            if len(seg) > 2 and random.random() < 0.5:\n                seg[:] = seg[::-1]\n\n    # Objective-aware node swapping\n    if random.random() < 0.4:\n        for _ in range(min(3, n//2)):\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], node_i] - distance_matrix_1[node_i, new_solution[(i+1)%n]]) + \\\n                    (distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[j-1], node_j] - distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], node_i] - distance_matrix_2[node_i, new_solution[(i+1)%n]]) + \\\n                    (distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[j-1], node_j] - distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n            if delta1 < 0 and delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9704548954413459,
            2.356585144996643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][0] + x[1][1] + 1e-6) + x[1][1] / (x[1][0] + x[1][1] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation with adaptive segment count\n    num_segments = random.randint(1, min(3, n//4))\n    segments = []\n    segment_indices = []\n\n    for _ in range(num_segments):\n        seg_len = random.randint(2, min(4, n//num_segments))\n        i = random.randint(0, n - seg_len)\n        segments.append(new_solution[i:i+seg_len])\n        segment_indices.append((i, i+seg_len))\n\n    # Remove segments from solution\n    for i, (start, end) in enumerate(sorted(segment_indices, reverse=True)):\n        new_solution = np.delete(new_solution, slice(start, end))\n\n    # Reinsert segments at new positions\n    for seg in segments:\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, seg)\n\n    # Adaptive segment inversion based on objective improvement\n    if random.random() < 0.6:\n        for seg in segments:\n            if len(seg) > 2 and random.random() < 0.5:\n                seg[:] = seg[::-1]\n\n    # Objective-aware node swapping\n    if random.random() < 0.4:\n        for _ in range(min(3, n//2)):\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], node_i] - distance_matrix_1[node_i, new_solution[(i+1)%n]]) + \\\n                    (distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[j-1], node_j] - distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], node_i] - distance_matrix_2[node_i, new_solution[(i+1)%n]]) + \\\n                    (distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[j-1], node_j] - distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n            if delta1 < 0 and delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid of adaptive segment reordering with dynamic node insertion and probabilistic segment reversal, combining greedy segment displacement and adaptive node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.5 * (x[1][0] / (distance_matrix_1.max() + 1e-6)) + 0.5 * (x[1][1] / (distance_matrix_2.max() + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size].copy()\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        insert_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        rev_start = random.randint(0, n - segment_size)\n        new_solution[rev_start:rev_start+segment_size] = new_solution[rev_start:rev_start+segment_size][::-1]\n\n    # Greedy segment displacement\n    if random.random() < 0.5:\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(0, n - segment_size + 1):\n            temp = new_solution.copy()\n            temp[pos:pos+segment_size] = segment\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n        new_solution[best_pos:best_pos+segment_size] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = sorted(set(range(n)) - set(unique_nodes))\n        for i, node in enumerate(missing):\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9448931554050177,
            8.09552139043808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.5 * (x[1][0] / (distance_matrix_1.max() + 1e-6)) + 0.5 * (x[1][1] / (distance_matrix_2.max() + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size].copy()\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        insert_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        new_solution = new_solution[:n]  # Ensure length remains n\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        rev_start = random.randint(0, n - segment_size)\n        new_solution[rev_start:rev_start+segment_size] = new_solution[rev_start:rev_start+segment_size][::-1]\n\n    # Greedy segment displacement\n    if random.random() < 0.5:\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(0, n - segment_size + 1):\n            temp = new_solution.copy()\n            temp[pos:pos+segment_size] = segment\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n        new_solution[best_pos:best_pos+segment_size] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = sorted(set(range(n)) - set(unique_nodes))\n        for i, node in enumerate(missing):\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8594800750234349,
            0.3410153388977051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9728266518203773,
            0.25183457136154175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive based on the combined improvement potential in both objectives, then applies a hybrid of adaptive segment reversal with probabilistic segment shifting, combined with dynamic node insertion and constrained swapping to explore the solution space while maintaining feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with probabilistic shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, a + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[b:]])\n\n    # Dynamic node insertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution[1:-1])\n        pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Constrained swapping\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.894202540059986,
            0.6136126518249512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with probabilistic shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, a + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[b:]])\n\n    # Dynamic node insertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution[1:-1])\n        pos = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Constrained swapping\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        if abs(i - j) > 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines a hybrid segment inversion with dynamic segment migration to generate diverse neighbor solutions while maintaining feasibility by adaptively reordering segments based on objective-aware distance metrics and ensuring no nodes are skipped or revisited.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive using a Pareto-dominance-aware selection criterion, then applies a hybrid segment rotation and segment insertion operator that dynamically reorders segments based on both objective distances and spatial proximity, ensuring feasibility by maintaining node uniqueness and tour completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Dynamic segment insertion\n    if random.random() < 0.7:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            # Insert segment with objective-aware positioning\n            obj_dist = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_2[new_solution[k-1], segment[0]]\n            if k < len(new_solution)-1:\n                obj_dist += distance_matrix_1[segment[-1], new_solution[k]] + distance_matrix_2[segment[-1], new_solution[k]]\n            if obj_dist > 0:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            # Insert reversed segment with probability based on objective distances\n            reverse_prob = (distance_matrix_1[new_solution[l-1], segment[-1]] + distance_matrix_2[new_solution[l-1], segment[-1]]) / \\\n                          (distance_matrix_1[new_solution[l-1], segment[0]] + distance_matrix_2[new_solution[l-1], segment[0]] + 1e-6)\n            if random.random() < reverse_prob:\n                new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    # Repair mechanism for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7242770780893009,
            0.2772670388221741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Dynamic segment insertion\n    if random.random() < 0.7:\n        k = random.randint(0, n-1)\n        if k < len(new_solution):\n            # Insert segment with objective-aware positioning\n            obj_dist = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_2[new_solution[k-1], segment[0]]\n            if k < len(new_solution)-1:\n                obj_dist += distance_matrix_1[segment[-1], new_solution[k]] + distance_matrix_2[segment[-1], new_solution[k]]\n            if obj_dist > 0:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        l = random.randint(0, n-1)\n        if l < len(new_solution):\n            # Insert reversed segment with probability based on objective distances\n            reverse_prob = (distance_matrix_1[new_solution[l-1], segment[-1]] + distance_matrix_2[new_solution[l-1], segment[-1]]) / \\\n                          (distance_matrix_1[new_solution[l-1], segment[0]] + distance_matrix_2[new_solution[l-1], segment[0]] + 1e-6)\n            if random.random() < reverse_prob:\n                new_solution = np.concatenate([new_solution[:l], segment[::-1], new_solution[l:]])\n\n    # Repair mechanism for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm selects a solution from the archive based on its proximity to the Pareto front and applies a hybrid of segment reversal with adaptive node insertion, combining dynamic segment shifting and probabilistic edge swapping to explore the solution space while maintaining feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Dynamic segment shifting\n    shift = random.randint(-3, 3)\n    new_solution = np.roll(new_solution, shift)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i = random.randint(1, n-2)\n        new_solution[i:i+2] = new_solution[i+1:i-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9148386244027512,
            0.24692851305007935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Dynamic segment shifting\n    shift = random.randint(-3, 3)\n    new_solution = np.roll(new_solution, shift)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i = random.randint(1, n-2)\n        new_solution[i:i+2] = new_solution[i+1:i-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a novel \"objective-aware tour fragmentation and recombination\" strategy, where segments are extracted and reinserted in positions that are optimized for both objectives, using adaptive segment rotation and displacement to create high-quality neighbors while maintaining tour feasibility through comprehensive validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment based on objective-aware criteria\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Decide rotation direction based on objective balance\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Find optimal insertion position considering both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - segment_length + 1):\n        temp = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Reinsert segment at optimal position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive displacement based on objective differences\n    if random.random() < 0.4:\n        displacement = random.randint(-3, 3)\n        new_pos = max(0, min(n - segment_length, best_pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.922036532431235,
            8.466184377670288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment based on objective-aware criteria\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Decide rotation direction based on objective balance\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Find optimal insertion position considering both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - segment_length + 1):\n        temp = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Reinsert segment at optimal position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive displacement based on objective differences\n    if random.random() < 0.4:\n        displacement = random.randint(-3, 3)\n        new_pos = max(0, min(n - segment_length, best_pos + displacement))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{An algorithm that uses a geometric mean-based selection criterion to prioritize solutions with diverse objective improvements, followed by a hybrid segment rotation and displacement operator with dynamic segment length and position selection to generate innovative neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        new_solution[i:j] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.980213622820245,
            0.4511857032775879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        new_solution[i:j] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{An algorithm that uses a hybrid of segment inversion and adaptive k-opt moves, combined with objective-balanced selection, to generate high-quality neighbors by dynamically adjusting segment sizes and insertion points based on both objective values and spatial diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    k = random.randint(2, min(5, n // 2))\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices]\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    new_solution = np.delete(new_solution, indices)\n    insert_pos = random.randint(0, len(new_solution))\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        new_solution = np.concatenate([segment, new_solution[:insert_pos], new_solution[insert_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6909036809704315,
            1.5471370816230774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    k = random.randint(2, min(5, n // 2))\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices]\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    new_solution = np.delete(new_solution, indices)\n    insert_pos = random.randint(0, len(new_solution))\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        new_solution = np.concatenate([segment, new_solution[:insert_pos], new_solution[insert_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid of adaptive segment reshaping with probabilistic node insertion and displacement, ensuring feasibility through a multi-phase validation and repair process that maintains tour integrity while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshaping\n    segment_length = random.randint(2, min(6, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic segment transformation\n    if random.random() < 0.6:\n        segment = np.roll(segment, random.randint(1, segment_length-1))\n    if random.random() < 0.4:\n        segment = segment[::-1]\n\n    # Position displacement\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos != start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_length])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution[1:-1])\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Ensure tour integrity\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.4594746229192126,
            1.0978184938430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshaping\n    segment_length = random.randint(2, min(6, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic segment transformation\n    if random.random() < 0.6:\n        segment = np.roll(segment, random.randint(1, segment_length-1))\n    if random.random() < 0.4:\n        segment = segment[::-1]\n\n    # Position displacement\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos != start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_length])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution[1:-1])\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    # Ensure tour integrity\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([new_solution, np.setdiff1d(np.arange(n), new_solution)])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{An algorithm that combines a dynamic segment relocation with adaptive segment reversal and insertion, guided by a weighted objective improvement criterion to balance exploration and exploitation while ensuring feasibility through careful node placement and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5917703758498793,
            2.0711244344711304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment reinsertion with dynamic segment reversal to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{A novel algorithm that combines adaptive segment fragmentation with dynamic hub-and-spoke reconfiguration to generate diverse neighbor solutions by strategically breaking and reconnecting tour segments around high-impact nodes while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Identify high-impact nodes (those with high distances in either objective)\n    high_impact_nodes = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] > 2 *\n            np.mean(distance_matrix_1) or\n            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] > 2 *\n            np.mean(distance_matrix_2)):\n            high_impact_nodes.append(i)\n\n    if not high_impact_nodes:\n        high_impact_nodes = [random.randint(0, n-1)]\n\n    # Choose a hub node and perform fragmentation\n    hub = random.choice(high_impact_nodes)\n    segment_length = random.randint(2, min(5, n//2))\n    start = hub\n    end = (start + segment_length) % n\n\n    # Fragment the segment and reconfigure\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Reconnect with dynamic hub-and-spoke pattern\n    if len(segment) > 0:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7619374813599369,
            3.9857417941093445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Identify high-impact nodes (those with high distances in either objective)\n    high_impact_nodes = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] > 2 *\n            np.mean(distance_matrix_1) or\n            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] > 2 *\n            np.mean(distance_matrix_2)):\n            high_impact_nodes.append(i)\n\n    if not high_impact_nodes:\n        high_impact_nodes = [random.randint(0, n-1)]\n\n    # Choose a hub node and perform fragmentation\n    hub = random.choice(high_impact_nodes)\n    segment_length = random.randint(2, min(5, n//2))\n    start = hub\n    end = (start + segment_length) % n\n\n    # Fragment the segment and reconfigure\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Reconnect with dynamic hub-and-spoke pattern\n    if len(segment) > 0:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.003964443870748,
            0.21871668100357056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9613480786427335,
            0.18998849391937256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a novel circular permutation with adaptive segment merging and probabilistic arc reversal to generate diverse neighbor solutions while maintaining feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Circular permutation with adaptive segment merging\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        # Merge with adjacent segments\n        if a > 1 and random.random() < 0.5:\n            segment = np.concatenate([new_solution[a-1:a], segment])\n        if b < n-1 and random.random() < 0.5:\n            segment = np.concatenate([segment, new_solution[b:b+1]])\n\n    # Probabilistic arc reversal\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.872962889100483,
            1.1454275250434875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Circular permutation with adaptive segment merging\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        # Merge with adjacent segments\n        if a > 1 and random.random() < 0.5:\n            segment = np.concatenate([new_solution[a-1:a], segment])\n        if b < n-1 and random.random() < 0.5:\n            segment = np.concatenate([segment, new_solution[b:b+1]])\n\n    # Probabilistic arc reversal\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity score that balances Pareto dominance and solution quality, then applies a hybrid of adaptive segment insertion with position-based mutation and probabilistic node exchange to generate a neighbor solution while ensuring tour feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with position-based mutation\n    segment_size = max(2, min(5, random.randint(1, n//3)))\n    start = random.randint(1, n-segment_size-1)\n    segment = new_solution[start:start+segment_size].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(1, n-segment_size)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node exchange with distance awareness\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.in1d(new_solution, missing, invert=True))[0]]\n        for m in missing:\n            idx = np.random.choice(np.where(new_solution == np.random.choice(duplicates))[0])\n            new_solution[idx] = m\n\n    return new_solution\n\n",
        "score": [
            -0.9076047313874671,
            0.23132961988449097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with position-based mutation\n    segment_size = max(2, min(5, random.randint(1, n//3)))\n    start = random.randint(1, n-segment_size-1)\n    segment = new_solution[start:start+segment_size].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(1, n-segment_size)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic node exchange with distance awareness\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.in1d(new_solution, missing, invert=True))[0]]\n        for m in missing:\n            idx = np.random.choice(np.where(new_solution == np.random.choice(duplicates))[0])\n            new_solution[idx] = m\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{An algorithm that prioritizes solutions with balanced objective improvements using a geometric mean selection criterion, then applies a novel adaptive segment rotation and inversion operator with dynamic segment length and position selection to generate diverse, high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    rotation = random.randint(1, segment_length - 1)\n    segment = np.roll(segment, rotation)\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9294185126193035,
            0.2542646527290344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    rotation = random.randint(1, segment_length - 1)\n    segment = np.roll(segment, rotation)\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A novel algorithm that combines a hybrid segment relocation with dynamic segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function that prioritizes both objective values and their relative diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution, segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8590364603723533,
            1.339292585849762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution, segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective-aware diversity metric, then applies a hybrid of adaptive segment permutation with dynamic position swapping and probabilistic node reinsertion, ensuring feasibility through systematic validation and repair while exploring the solution space with a focus on both objective improvements and structural diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment permutation\n    segment_size = random.randint(3, min(7, n//3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Dynamic position swapping\n    if random.random() < 0.8:\n        new_pos = (start + random.randint(1, n//2)) % n\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.46527267013325335,
            0.49041759967803955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment permutation\n    segment_size = random.randint(3, min(7, n//3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Dynamic position swapping\n    if random.random() < 0.8:\n        new_pos = (start + random.randint(1, n//2)) % n\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance, then applies a hybrid of probabilistic segment rotation with dynamic segment inversion, combining adaptive segment shifting and intelligent edge swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.roll(segment, shift)\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9295309123000709,
            0.2529761791229248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.roll(segment, shift)\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9353929569017456,
            0.17754900455474854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment reshaping with probabilistic node reinsertion, combining dynamic segment inversion and context-aware displacement to explore the solution space while ensuring feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshaping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment_size = len(segment)\n\n    if segment_size > 1:\n        if random.random() < 0.7:\n            segment = np.roll(segment, random.randint(1, segment_size-1))\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n    # Context-aware displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    if new_pos < pos:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:pos], new_solution[pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.9:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.isin(new_solution, unique_nodes, invert=True))[0]]\n\n        for m in missing:\n            idx = np.where(new_solution == duplicates[0])[0][0]\n            new_solution[idx] = m\n            duplicates = duplicates[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9639846337840939,
            0.2432616949081421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshaping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment_size = len(segment)\n\n    if segment_size > 1:\n        if random.random() < 0.7:\n            segment = np.roll(segment, random.randint(1, segment_size-1))\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n    # Context-aware displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    if new_pos < pos:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:pos], new_solution[pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.9:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = new_solution[np.where(np.isin(new_solution, unique_nodes, invert=True))[0]]\n\n        for m in missing:\n            idx = np.where(new_solution == duplicates[0])[0][0]\n            new_solution[idx] = m\n            duplicates = duplicates[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of dynamic segment reversal with adaptive node insertion, combining probabilistic segment shifting and systematic node reordering to explore the solution space while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Probabilistic segment shifting\n    if random.random() < 0.5:\n        segment_length = random.randint(2, min(5, n//3))\n        start = random.randint(1, n-segment_length-1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(1, n-segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.3664287745868199,
            1.3730373978614807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Probabilistic segment shifting\n    if random.random() < 0.5:\n        segment_length = random.randint(2, min(5, n//3))\n        start = random.randint(1, n-segment_length-1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(1, n-segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{An algorithm that uses adaptive segment rotation and intelligent segment reinsertion, combined with objective-aware selection and dynamic segment length adjustment, to generate high-quality neighbor solutions while ensuring feasibility and exploring the solution space through non-uniform segment manipulations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, max(3, n // 3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8823592552366541,
            1.3133401274681091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, max(3, n // 3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{A novel hybrid algorithm that intelligently combines adaptive segment relocations with dynamic segment inversions, guided by a multi-objective improvement score, to generate diverse neighbor solutions while ensuring feasibility and maximizing exploration of promising regions in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n\n    # Select solution based on normalized improvement potential\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n\n    new_solution = selected.copy()\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, max(3, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic segment inversion with probability\n    if random.random() < 0.3:\n        inv_start = random.randint(0, len(new_solution) - 2)\n        inv_end = random.randint(inv_start + 1, len(new_solution))\n        new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n    # Repair to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9725049437722136,
            1.4596818089485168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n\n    # Select solution based on normalized improvement potential\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n\n    new_solution = selected.copy()\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, max(3, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic segment inversion with probability\n    if random.random() < 0.3:\n        inv_start = random.randint(0, len(new_solution) - 2)\n        inv_end = random.randint(inv_start + 1, len(new_solution))\n        new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n    # Repair to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{A novel algorithm that combines a hybrid segment inversion with dynamic segment shifting and objective-aware segment reinsertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-linear segment manipulations and adaptive objective-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + (x[1][0] - x[1][1])**2))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.5:\n        shift = random.randint(1, n//2)\n        new_solution = np.roll(new_solution, shift)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8695862500335271,
            0.42619264125823975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + (x[1][0] - x[1][1])**2))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.5:\n        shift = random.randint(1, n//2)\n        new_solution = np.roll(new_solution, shift)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel algorithm that combines adaptive segment decomposition with multi-objective-aware node redistribution, using dynamic segment merging and probabilistic node reinsertion to create high-quality neighbors while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segment_size = random.randint(2, max(3, n//4))\n    start = random.randint(0, n-segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Multi-objective-aware node redistribution\n    if random.random() < 0.7:\n        # Calculate node importance based on both objectives\n        node_importance = np.zeros(n)\n        for i in range(n-1):\n            node1, node2 = new_solution[i], new_solution[i+1]\n            node_importance[node1] += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n            node_importance[node2] += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n\n        # Sort nodes by importance\n        sorted_nodes = np.argsort(node_importance)[::-1]\n        important_segment = sorted_nodes[:segment_size]\n\n        # Reinsert important nodes at new positions\n        new_solution = np.setdiff1d(new_solution, important_segment)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], important_segment, new_solution[insert_pos:]])\n\n    # Dynamic segment merging\n    if random.random() < 0.5 and len(new_solution) > segment_size*2:\n        merge_pos = random.randint(segment_size, len(new_solution)-segment_size)\n        new_solution = np.concatenate([new_solution[:merge_pos], new_solution[merge_pos+segment_size:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node_to_reinsert = random.choice(new_solution[1:-1])\n        new_solution = new_solution[new_solution != node_to_reinsert]\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_reinsert)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n",
        "score": [
            -0.47640763991425616,
            2.075329899787903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment decomposition\n    segment_size = random.randint(2, max(3, n//4))\n    start = random.randint(0, n-segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Multi-objective-aware node redistribution\n    if random.random() < 0.7:\n        # Calculate node importance based on both objectives\n        node_importance = np.zeros(n)\n        for i in range(n-1):\n            node1, node2 = new_solution[i], new_solution[i+1]\n            node_importance[node1] += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n            node_importance[node2] += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2]\n\n        # Sort nodes by importance\n        sorted_nodes = np.argsort(node_importance)[::-1]\n        important_segment = sorted_nodes[:segment_size]\n\n        # Reinsert important nodes at new positions\n        new_solution = np.setdiff1d(new_solution, important_segment)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], important_segment, new_solution[insert_pos:]])\n\n    # Dynamic segment merging\n    if random.random() < 0.5 and len(new_solution) > segment_size*2:\n        merge_pos = random.randint(segment_size, len(new_solution)-segment_size)\n        new_solution = np.concatenate([new_solution[:merge_pos], new_solution[merge_pos+segment_size:]])\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:\n        node_to_reinsert = random.choice(new_solution[1:-1])\n        new_solution = new_solution[new_solution != node_to_reinsert]\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_reinsert)\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9855014600354379,
            0.2146586775779724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel combination of probabilistic segment permutation with adaptive segment displacement, incorporating dynamic segment rotation and conditional node transposition to create diverse neighbor solutions while preserving feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment permutation\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Adaptive segment displacement\n    i, j = random.sample(range(1, n-1), 2)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Dynamic segment rotation\n    if len(segment) > 2 and random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[i:i+len(segment)] = segment\n\n    # Conditional node transposition\n    if random.random() < 0.9:\n        k, l = random.sample(range(1, n-1), 2)\n        if abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.where(np.diff(new_solution) == 0)[0] + 1\n        for d in duplicates:\n            new_solution[d] = missing[0] if len(missing) > 0 else random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.5041149028980904,
            1.6906882524490356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment permutation\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Adaptive segment displacement\n    i, j = random.sample(range(1, n-1), 2)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Dynamic segment rotation\n    if len(segment) > 2 and random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[i:i+len(segment)] = segment\n\n    # Conditional node transposition\n    if random.random() < 0.9:\n        k, l = random.sample(range(1, n-1), 2)\n        if abs(k - l) > 1:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = np.where(np.diff(new_solution) == 0)[0] + 1\n        for d in duplicates:\n            new_solution[d] = missing[0] if len(missing) > 0 else random.choice(np.setdiff1d(np.arange(n), new_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel algorithm that employs a hybrid segment rotation with adaptive segment lengths and dynamic segment inversions, guided by a modified score function that prioritizes solutions with balanced improvement potential in both objectives, to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    max_segment = min(5, n // 2)\n    segment_length = random.randint(2, max_segment)\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9121929829923223,
            1.539859414100647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    max_segment = min(5, n // 2)\n    segment_length = random.randint(2, max_segment)\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{An algorithm that employs a dominance-based selection criterion to prioritize solutions with non-dominated objectives, followed by a novel segment rotation and displacement operator with dynamic segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment rotation\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Displacement with position adjustment\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.insert(new_solution, k, rotated_segment)\n        new_solution = np.delete(new_solution, np.s_[k + segment_length:k + segment_length + segment_length])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7766619590923912,
            0.590153694152832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Segment rotation\n    rotation = random.randint(1, segment_length - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Displacement with position adjustment\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.insert(new_solution, k, rotated_segment)\n        new_solution = np.delete(new_solution, np.s_[k + segment_length:k + segment_length + segment_length])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive based on the maximum improvement potential in either objective space, then applies a novel hybrid operator that combines segment-based displacement with adaptive node reordering, followed by a probabilistic local inversion and intelligent segment rotation to explore the solution space while ensuring feasibility through systematic validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment displacement with adaptive node reordering\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Adaptive node reordering\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        if len(segment) > 2:\n            mid = len(segment) // 2\n            segment = np.concatenate([segment[mid:], segment[:mid]])\n\n    # Probabilistic local inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Intelligent segment rotation\n    if random.random() < 0.3:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Insert segment at new position\n    insert_pos = random.randint(0, n - segment_size)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicates while maintaining order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.8613395055165308,
            2.3429441452026367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment displacement with adaptive node reordering\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Adaptive node reordering\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        if len(segment) > 2:\n            mid = len(segment) // 2\n            segment = np.concatenate([segment[mid:], segment[:mid]])\n\n    # Probabilistic local inversion\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Intelligent segment rotation\n    if random.random() < 0.3:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Insert segment at new position\n    insert_pos = random.randint(0, n - segment_size)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicates while maintaining order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{An algorithm that uses a lexicographic selection criterion to prioritize solutions with better performance in the first objective, followed by a hybrid segment insertion and reversal operator with dynamic segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6899410230471449,
            0.35100865364074707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score function that balances the objectives and their trade-off, then applies a hybrid local search combining probabilistic segment relocations and dynamic segment inversions to generate a diverse neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.7:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8977396200502669,
            0.36285853385925293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.7:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid operator that combines adaptive segment swapping with probabilistic edge inversions to explore the solution space while maintaining feasibility and ensuring diversity in the generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]) ** 2 + (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    segment1 = new_solution[i:i+segment_length]\n    segment2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = segment2\n    new_solution[j:j+segment_length] = segment1\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9007488450454447,
            0.7075154781341553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] - x[1][1]) ** 2 + (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    segment1 = new_solution[i:i+segment_length]\n    segment2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = segment2\n    new_solution[j:j+segment_length] = segment1\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment merging with dynamic segment splitting, combining probabilistic node insertion and conditional segment reversal to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n    merged_segment = np.concatenate([segment2, segment1, segment3])\n\n    # Dynamic segment splitting\n    split_pos = random.randint(1, len(merged_segment)-1)\n    split_segment = np.concatenate([merged_segment[split_pos:], merged_segment[:split_pos]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = split_segment[i]\n        split_segment = np.delete(split_segment, i)\n        insert_pos = random.randint(1, len(split_segment)-1)\n        split_segment = np.insert(split_segment, insert_pos, node)\n\n    # Conditional segment reversal\n    if random.random() < 0.6:\n        rev_a, rev_b = sorted(random.sample(range(1, len(split_segment)-1), 2))\n        split_segment[rev_a:rev_b] = split_segment[rev_b-1:rev_a-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(split_segment)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        split_segment = np.concatenate([split_segment, missing])\n        split_segment = split_segment[:n]\n\n    return split_segment\n\n",
        "score": [
            -0.4131389112711777,
            2.751668930053711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n    merged_segment = np.concatenate([segment2, segment1, segment3])\n\n    # Dynamic segment splitting\n    split_pos = random.randint(1, len(merged_segment)-1)\n    split_segment = np.concatenate([merged_segment[split_pos:], merged_segment[:split_pos]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = split_segment[i]\n        split_segment = np.delete(split_segment, i)\n        insert_pos = random.randint(1, len(split_segment)-1)\n        split_segment = np.insert(split_segment, insert_pos, node)\n\n    # Conditional segment reversal\n    if random.random() < 0.6:\n        rev_a, rev_b = sorted(random.sample(range(1, len(split_segment)-1), 2))\n        split_segment[rev_a:rev_b] = split_segment[rev_b-1:rev_a-1:-1]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(split_segment)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        split_segment = np.concatenate([split_segment, missing])\n        split_segment = split_segment[:n]\n\n    return split_segment\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A novel algorithm that combines adaptive segment relocations with dynamic node swaps to generate high-quality neighbor solutions by prioritizing solutions with high potential for improvement while ensuring feasibility through intelligent segment manipulation and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform adaptive segment relocation\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Perform dynamic node swaps\n    swap_count = random.randint(1, min(3, n//2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and fix feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        extra = list(set(new_solution) - set(range(n)))\n        for m, e in zip(missing, extra):\n            new_solution[new_solution == e] = m\n\n    return new_solution\n\n",
        "score": [
            -0.5995003664616655,
            3.4455894827842712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform adaptive segment relocation\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Perform dynamic node swaps\n    swap_count = random.randint(1, min(3, n//2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and fix feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = list(set(range(n)) - set(unique_nodes))\n        extra = list(set(new_solution) - set(range(n)))\n        for m, e in zip(missing, extra):\n            new_solution[new_solution == e] = m\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance rank and applies a hybrid of probabilistic node swapping with adaptive segment rotation, combining intelligent segment reversal and dynamic node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][1] + 1e-6)) + (x[1][1] / (x[1][0] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if random.random() < 0.7:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.003085657938074,
            0.4182806611061096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][1] + 1e-6)) + (x[1][1] / (x[1][0] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if random.random() < 0.7:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{An algorithm that combines dynamic segment extraction with adaptive segment reinsertion and rotation, but instead of random segment selection and insertion, it uses a greedy approach to select segments that improve both objectives simultaneously, while also incorporating a novel segment rotation strategy that considers both distance matrices to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    def calculate_improvement(solution, i, j, k):\n        original_cost = (distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j-1], solution[j]] +\n                         distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j-1], solution[j]])\n        segment = solution[i:j]\n        rotated_segment = segment[::-1]\n        new_cost = (distance_matrix_1[solution[i-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], solution[j]] +\n                    distance_matrix_2[solution[i-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], solution[j]])\n        return original_cost - new_cost\n\n    best_improvement = -float('inf')\n    best_i, best_j, best_k = 0, 0, 0\n\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        improvement = calculate_improvement(new_solution, i, j, k)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_i, best_j, best_k = i, j, k\n\n    if best_improvement > 0:\n        segment = new_solution[best_i:best_j]\n        rotated_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_i], rotated_segment, new_solution[best_j:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5209081371111496,
            3.82139652967453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    def calculate_improvement(solution, i, j, k):\n        original_cost = (distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j-1], solution[j]] +\n                         distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j-1], solution[j]])\n        segment = solution[i:j]\n        rotated_segment = segment[::-1]\n        new_cost = (distance_matrix_1[solution[i-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], solution[j]] +\n                    distance_matrix_2[solution[i-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], solution[j]])\n        return original_cost - new_cost\n\n    best_improvement = -float('inf')\n    best_i, best_j, best_k = 0, 0, 0\n\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        improvement = calculate_improvement(new_solution, i, j, k)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_i, best_j, best_k = i, j, k\n\n    if best_improvement > 0:\n        segment = new_solution[best_i:best_j]\n        rotated_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_i], rotated_segment, new_solution[best_j:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{A novel algorithm that employs a multi-segment extraction and adaptive rotation with dynamic segment merging to create diverse neighbor solutions while ensuring feasibility through constraint-aware segment reinsertion and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][1] + 1e-6)) + (x[1][1] / (x[1][0] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segments = []\n    num_segments = random.randint(2, min(4, n // 2))\n    points = sorted(random.sample(range(1, n), num_segments - 1))\n    points = [0] + points + [n]\n    for i in range(len(points) - 1):\n        segments.append(new_solution[points[i]:points[i+1]])\n\n    random.shuffle(segments)\n    if random.random() < 0.7:\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n\n    merged = []\n    for seg in segments:\n        if random.random() < 0.3 and len(merged) > 0:\n            pos = random.randint(0, len(merged[-1]) - 1)\n            merged[-1] = np.concatenate([merged[-1][:pos], seg, merged[-1][pos:]])\n        else:\n            merged.append(seg)\n\n    new_solution = np.concatenate(merged)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3992966277339942,
            1.6858570575714111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] / (x[1][1] + 1e-6)) + (x[1][1] / (x[1][0] + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segments = []\n    num_segments = random.randint(2, min(4, n // 2))\n    points = sorted(random.sample(range(1, n), num_segments - 1))\n    points = [0] + points + [n]\n    for i in range(len(points) - 1):\n        segments.append(new_solution[points[i]:points[i+1]])\n\n    random.shuffle(segments)\n    if random.random() < 0.7:\n        for i in range(len(segments)):\n            if random.random() < 0.5:\n                segments[i] = segments[i][::-1]\n\n    merged = []\n    for seg in segments:\n        if random.random() < 0.3 and len(merged) > 0:\n            pos = random.randint(0, len(merged[-1]) - 1)\n            merged[-1] = np.concatenate([merged[-1][:pos], seg, merged[-1][pos:]])\n        else:\n            merged.append(seg)\n\n    new_solution = np.concatenate(merged)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A novel algorithm that combines a dynamic segment insertion with adaptive segment reversal and position swapping to generate high-quality neighbor solutions while ensuring feasibility by maintaining node uniqueness and tour continuity through intelligent segment manipulation and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(1, min(4, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - segment_length)\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.92271716855064,
            0.9892308115959167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(1, min(4, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        k = random.randint(0, n - segment_length)\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{An algorithm that combines adaptive segment relocations with dynamic segment rotations to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and inversion, motivated by the diversity-aware selection and hybrid segment operations from the provided algorithms but with a novel segment rotation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / ((x[1][0] + x[1][1]) ** 2 + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.5:\n        rotation = random.randint(1, segment_length - 1)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7758166828472658,
            0.20212078094482422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / ((x[1][0] + x[1][1]) ** 2 + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.5:\n        rotation = random.randint(1, segment_length - 1)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{An algorithm that employs a multi-criteria selection based on Pareto dominance and dominance area to prioritize solutions with high potential for improvement, followed by a hybrid segment rotation and displacement operator with adaptive segment length and position selection to generate diverse neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_area(sol):\n        c1, c2 = sol[1]\n        dominates = sum(1 for s in archive if s[1][0] <= c1 and s[1][1] <= c2 and (s[1][0] < c1 or s[1][1] < c2))\n        dominated = sum(1 for s in archive if s[1][0] >= c1 and s[1][1] >= c2 and (s[1][0] > c1 or s[1][1] > c2))\n        return dominates - dominated\n\n    selected = max(archive, key=lambda x: dominance_area(x))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment rotation and displacement operator\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Rotate segment\n    rotate_pos = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n\n    # Insert rotated segment at a different position\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:k], rotated_segment, new_solution[k:]])\n\n    # Remove duplicate nodes\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique_nodes[counts > 1]\n    for node in duplicates:\n        indices = np.where(new_solution == node)[0]\n        for idx in indices[1:]:\n            new_solution[idx] = -1\n    new_solution = new_solution[new_solution != -1]\n\n    # Reinsert missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    for node in missing_nodes:\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9157040401953864,
            10.840790033340454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_area(sol):\n        c1, c2 = sol[1]\n        dominates = sum(1 for s in archive if s[1][0] <= c1 and s[1][1] <= c2 and (s[1][0] < c1 or s[1][1] < c2))\n        dominated = sum(1 for s in archive if s[1][0] >= c1 and s[1][1] >= c2 and (s[1][0] > c1 or s[1][1] > c2))\n        return dominates - dominated\n\n    selected = max(archive, key=lambda x: dominance_area(x))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid segment rotation and displacement operator\n    segment_length = random.randint(2, min(7, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Rotate segment\n    rotate_pos = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n\n    # Insert rotated segment at a different position\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:k], rotated_segment, new_solution[k:]])\n\n    # Remove duplicate nodes\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique_nodes[counts > 1]\n    for node in duplicates:\n        indices = np.where(new_solution == node)[0]\n        for idx in indices[1:]:\n            new_solution[idx] = -1\n    new_solution = new_solution[new_solution != -1]\n\n    # Reinsert missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    for node in missing_nodes:\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{An algorithm that uses a diversity-aware selection criterion to prioritize solutions with complementary objective trade-offs, followed by an adaptive segment rotation and insertion operator with probabilistic segment selection and dynamic rotation angles to generate highly diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(4, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    rotation_angle = random.randint(1, segment_length-1)\n    rotated_segment = np.roll(segment, rotation_angle)\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = rotated_segment\n\n    insertion_point = random.randint(0, n - segment_length)\n    if insertion_point != i:\n        new_solution = np.concatenate([new_solution[:insertion_point], rotated_segment, new_solution[insertion_point:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9202355308183137,
            0.3424694538116455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(4, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    rotation_angle = random.randint(1, segment_length-1)\n    rotated_segment = np.roll(segment, rotation_angle)\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = rotated_segment\n\n    insertion_point = random.randint(0, n - segment_length)\n    if insertion_point != i:\n        new_solution = np.concatenate([new_solution[:insertion_point], rotated_segment, new_solution[insertion_point:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel algorithm that combines adaptive segment shuffling with dynamic reversal and insertion operations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (min(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n    if k < len(new_solution):\n        extracted = np.delete(new_solution, slice(i, j))\n        new_solution = np.concatenate([extracted[:k], segment, extracted[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3298421398800293,
            2.2416933178901672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (min(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n    if k < len(new_solution):\n        extracted = np.delete(new_solution, slice(i, j))\n        new_solution = np.concatenate([extracted[:k], segment, extracted[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{An algorithm that uses a hybrid of dynamic segment relinking and adaptive node swapping, guided by objective-aware selection and distance-based perturbation, to generate diverse neighbor solutions while ensuring feasibility and exploring the solution space through non-uniform segment manipulations and adaptive local improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + (x[1][0] - x[1][1])**2))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.3:\n        segment = segment[::-1]\n    elif random.random() < 0.6:\n        segment = np.roll(segment, random.randint(-n//2, n//2))\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if random.random() < 0.4:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n        else:\n            new_solution = np.concatenate([segment, new_solution[:k], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8743991767710126,
            0.22837227582931519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + (x[1][0] - x[1][1])**2))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.3:\n        segment = segment[::-1]\n    elif random.random() < 0.6:\n        segment = np.roll(segment, random.randint(-n//2, n//2))\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if random.random() < 0.4:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n        else:\n            new_solution = np.concatenate([segment, new_solution[:k], new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{An algorithm that uses a multi-objective diversity-aware selection criterion to prioritize solutions with complementary objective improvements, followed by a hybrid segment crossover and adaptive segment inversion operator with dynamic segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on both distance matrices\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Hybrid operator: segment crossover with adaptive inversion\n    if random.random() < 0.6:\n        # Segment crossover with another solution from archive\n        donor = random.choice(archive)[0]\n        donor_segment = donor[i:j]\n        if random.random() < 0.5:\n            new_solution[i:j] = donor_segment\n        else:\n            new_solution[i:j] = np.concatenate([segment[:len(segment)//2], donor_segment[len(donor_segment)//2:]])\n    else:\n        # Adaptive segment inversion based on objective improvements\n        if distance_matrix_1[segment[0], segment[-1]] > distance_matrix_2[segment[0], segment[-1]]:\n            new_solution[i:j] = segment[::-1]\n\n    # Ensure feasibility through validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9272197899585668,
            1.0454930067062378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on both distance matrices\n    segment_length = random.randint(2, min(7, n//3))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Hybrid operator: segment crossover with adaptive inversion\n    if random.random() < 0.6:\n        # Segment crossover with another solution from archive\n        donor = random.choice(archive)[0]\n        donor_segment = donor[i:j]\n        if random.random() < 0.5:\n            new_solution[i:j] = donor_segment\n        else:\n            new_solution[i:j] = np.concatenate([segment[:len(segment)//2], donor_segment[len(donor_segment)//2:]])\n    else:\n        # Adaptive segment inversion based on objective improvements\n        if distance_matrix_1[segment[0], segment[-1]] > distance_matrix_2[segment[0], segment[-1]]:\n            new_solution[i:j] = segment[::-1]\n\n    # Ensure feasibility through validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{An algorithm that employs a dynamic segment extraction with adaptive segment rotation and insertion, guided by objective-aware selection and non-uniform segment manipulations to generate diverse neighbor solutions while ensuring feasibility and exploring the solution space through probabilistic segment reordering and objective-balanced segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n\n    segment = new_solution[a:b]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9711345361442242,
            0.42783039808273315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n\n    segment = new_solution[a:b]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel algorithm that uses a dynamic segment inversion and adaptive segment placement strategy, combined with a crowding-distance-inspired selection to prioritize solutions with better objective diversity for neighborhood generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        n = len(solutions)\n        distances = np.zeros(n)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([sol[1][m] for sol in solutions])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                if solutions[sorted_idx[-1]][1][m] == solutions[sorted_idx[0]][1][m]:\n                    continue\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m]) / (solutions[sorted_idx[-1]][1][m] - solutions[sorted_idx[0]][1][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected = archive[selected_idx][0].copy()\n\n    # Hybrid segment operation\n    n = len(selected)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = selected[i:j]\n    new_solution = np.concatenate([selected[:i], segment[::-1], selected[j:]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], selected[i:j], new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9381647071475308,
            1.1742740273475647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(solutions):\n        n = len(solutions)\n        distances = np.zeros(n)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([sol[1][m] for sol in solutions])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                if solutions[sorted_idx[-1]][1][m] == solutions[sorted_idx[0]][1][m]:\n                    continue\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m]) / (solutions[sorted_idx[-1]][1][m] - solutions[sorted_idx[0]][1][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected = archive[selected_idx][0].copy()\n\n    # Hybrid segment operation\n    n = len(selected)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = selected[i:j]\n    new_solution = np.concatenate([selected[:i], segment[::-1], selected[j:]])\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], selected[i:j], new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function that prioritizes solutions with balanced objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8661226763248975,
            0.4053077697753906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of segment reversal with adaptive segment shifting, combining dynamic node insertion and probabilistic edge swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()[::-1]\n    shift = random.randint(-min(3, a-1), min(3, n-b-1))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-2), 2)\n        if i < j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8756267001020686,
            0.3498768210411072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()[::-1]\n    shift = random.randint(-min(3, a-1), min(3, n-b-1))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-2), 2)\n        if i < j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance rank and applies a hybrid of segment reversal with adaptive segment shifting, combining probabilistic node insertion and dynamic edge swapping to explore the solution space while ensuring feasibility through a systematic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = sorted(archive, key=lambda x: x[1][0] + x[1][1])[0][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Reverse segment\n\n    shift = random.randint(-min(3, a), min(3, n-b))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic edge swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8829209206453498,
            0.4352819323539734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = sorted(archive, key=lambda x: x[1][0] + x[1][1])[0][0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    segment = segment[::-1]  # Reverse segment\n\n    shift = random.randint(-min(3, a), min(3, n-b))\n    new_pos = max(1, min(n-1, a + shift))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node insertion\n    if random.random() < 0.7:\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic edge swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance, then applies a hybrid of adaptive segment merging and intelligent node reinsertion, combining dynamic segment splitting with probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[a:a+1]\n    segment2 = new_solution[b:b+1]\n\n    if random.random() < 0.5:\n        segment1, segment2 = segment2, segment1\n\n    new_solution = np.concatenate([new_solution[:a], segment1, new_solution[a+1:b], segment2, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:k+2], new_solution[k:k+1], new_solution[k+2:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9040573913430179,
            1.420020580291748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[a:a+1]\n    segment2 = new_solution[b:b+1]\n\n    if random.random() < 0.5:\n        segment1, segment2 = segment2, segment1\n\n    new_solution = np.concatenate([new_solution[:a], segment1, new_solution[a+1:b], segment2, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.2:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:k+2], new_solution[k:k+1], new_solution[k+2:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{An algorithm that combines a diversity-aware selection criterion with a hybrid segment rotation and adaptive segment insertion operator to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    rotation = random.randint(1, segment_length - 1)\n    segment = np.roll(segment, rotation)\n\n    new_solution[i:i+segment_length] = segment\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8697750643428578,
            0.4725559949874878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    rotation = random.randint(1, segment_length - 1)\n    segment = np.roll(segment, rotation)\n\n    new_solution[i:i+segment_length] = segment\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel algorithm that combines adaptive segment clustering with objective-aware dynamic reordering to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and multi-objective aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    k = random.randint(1, n // 2)\n    clusters = [new_solution[i:i+k] for i in range(0, n, k)]\n\n    random.shuffle(clusters)\n\n    if random.random() < 0.5:\n        clusters = [cluster[::-1] for cluster in clusters]\n\n    new_solution = np.concatenate(clusters)\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7230009758197712,
            1.813652217388153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    k = random.randint(1, n // 2)\n    clusters = [new_solution[i:i+k] for i in range(0, n, k)]\n\n    random.shuffle(clusters)\n\n    if random.random() < 0.5:\n        clusters = [cluster[::-1] for cluster in clusters]\n\n    new_solution = np.concatenate(clusters)\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that uses a weighted harmonic selection criterion to prioritize solutions with balanced objective improvements, followed by a hybrid segment insertion and reversal operator with adaptive segment length and position selection to generate diverse and high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        new_solution[i:j] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    if k != i:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{An algorithm that uses a multi-objective diversity-aware selection criterion to prioritize solutions with unbalanced objective improvements, followed by a novel hybrid segment inversion and displacement operator that dynamically adapts segment length and position based on objective space correlations to generate high-quality, diverse neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment length based on objective correlation\n    correlation = abs(distance_matrix_1[new_solution[0], new_solution[1]] - distance_matrix_2[new_solution[0], new_solution[1]])\n    segment_length = max(2, min(7, int(correlation / (max(correlation, 1e-5)) * n)))\n\n    # Select segment with highest intra-segment correlation\n    best_corr = -1\n    best_i = 0\n    for i in range(n - segment_length):\n        segment = new_solution[i:i+segment_length]\n        corr = sum(abs(distance_matrix_1[segment[j], segment[j+1]] - distance_matrix_2[segment[j], segment[j+1]])\n                  for j in range(segment_length-1))\n        if corr > best_corr:\n            best_corr = corr\n            best_i = i\n\n    i = best_i\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Hybrid inversion and displacement\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Adaptive displacement based on objective space\n    if distance_matrix_1[segment[0], segment[-1]] > distance_matrix_2[segment[0], segment[-1]]:\n        k = random.randint(0, n - segment_length)\n    else:\n        k = random.randint(segment_length, n)\n\n    # Ensure feasible insertion\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Repair if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7887657968019259,
            2.4275238513946533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment length based on objective correlation\n    correlation = abs(distance_matrix_1[new_solution[0], new_solution[1]] - distance_matrix_2[new_solution[0], new_solution[1]])\n    segment_length = max(2, min(7, int(correlation / (max(correlation, 1e-5)) * n)))\n\n    # Select segment with highest intra-segment correlation\n    best_corr = -1\n    best_i = 0\n    for i in range(n - segment_length):\n        segment = new_solution[i:i+segment_length]\n        corr = sum(abs(distance_matrix_1[segment[j], segment[j+1]] - distance_matrix_2[segment[j], segment[j+1]])\n                  for j in range(segment_length-1))\n        if corr > best_corr:\n            best_corr = corr\n            best_i = i\n\n    i = best_i\n    j = i + segment_length\n    segment = new_solution[i:j]\n\n    # Hybrid inversion and displacement\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Adaptive displacement based on objective space\n    if distance_matrix_1[segment[0], segment[-1]] > distance_matrix_2[segment[0], segment[-1]]:\n        k = random.randint(0, n - segment_length)\n    else:\n        k = random.randint(segment_length, n)\n\n    # Ensure feasible insertion\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Repair if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This new algorithm combines a novel adaptive segment swapping mechanism with dynamic segment rotations to generate high-quality neighbor solutions by intelligently selecting segments based on their contribution to the objective values, ensuring both feasibility and exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9035910470369233,
            0.2051815390586853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment shuffling with adaptive position-based displacement, combining probabilistic segment reversal and node reallocation to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = min(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment shuffling with adaptive displacement\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    # Probabilistic segment reversal\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    # Insert segment at new position with displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Node reallocation\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9531806465140837,
            0.174299955368042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel algorithm that dynamically selects a solution from the archive based on a hybrid of objective diversity and improvement potential, then applies a segment-based relocation with adaptive segment length and direction to generate high-quality neighbors while ensuring feasibility through careful node insertion and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (diversity in objectives)\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection and manipulation\n    segment_length = random.randint(2, max(3, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    direction = random.choice([-1, 1])  # -1 for reverse, 1 for original\n\n    if direction == -1:\n        segment = segment[::-1]\n\n    # Adaptive insertion point\n    insertion_point = random.randint(0, n - segment_length)\n    while insertion_point >= start and insertion_point <= end:\n        insertion_point = random.randint(0, n - segment_length)\n\n    # Apply segment relocation\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        segment,\n        np.delete(new_solution, np.s_[start:end]),\n        new_solution[insertion_point:]\n    ])\n\n    # Validate and repair solution if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8578267031965264,
            0.31245994567871094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (diversity in objectives)\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection and manipulation\n    segment_length = random.randint(2, max(3, n // 4))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    segment = new_solution[start:end]\n    direction = random.choice([-1, 1])  # -1 for reverse, 1 for original\n\n    if direction == -1:\n        segment = segment[::-1]\n\n    # Adaptive insertion point\n    insertion_point = random.randint(0, n - segment_length)\n    while insertion_point >= start and insertion_point <= end:\n        insertion_point = random.randint(0, n - segment_length)\n\n    # Apply segment relocation\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        segment,\n        np.delete(new_solution, np.s_[start:end]),\n        new_solution[insertion_point:]\n    ])\n\n    # Validate and repair solution if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm uses a dynamic segment rotation with adaptive segment inversions, combined with a novel diversity-aware selection mechanism that prioritizes solutions with high potential for improvement based on a modified score function incorporating both objective values and their variance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection score based on normalized objectives and their difference\n    def score(obj):\n        norm_obj1 = obj[0] / (np.max([o[0] for _, o in archive]) + 1e-6)\n        norm_obj2 = obj[1] / (np.max([o[1] for _, o in archive]) + 1e-6)\n        return (norm_obj1 * norm_obj2) / (abs(norm_obj1 - norm_obj2) + 1e-6)\n\n    selected = max(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = max(2, random.randint(1, min(5, n//2)))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Hybrid operation: rotation and conditional inversion\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        k = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n    else:\n        segment = segment[::-1]\n\n    new_solution[i:j] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.872594587465174,
            8.38813030719757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection score based on normalized objectives and their difference\n    def score(obj):\n        norm_obj1 = obj[0] / (np.max([o[0] for _, o in archive]) + 1e-6)\n        norm_obj2 = obj[1] / (np.max([o[1] for _, o in archive]) + 1e-6)\n        return (norm_obj1 * norm_obj2) / (abs(norm_obj1 - norm_obj2) + 1e-6)\n\n    selected = max(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection\n    segment_length = max(2, random.randint(1, min(5, n//2)))\n    i = random.randint(0, n - segment_length)\n    j = i + segment_length\n\n    # Hybrid operation: rotation and conditional inversion\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        k = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n    else:\n        segment = segment[::-1]\n\n    new_solution[i:j] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{A novel algorithm that combines a dynamic segment inversion with adaptive segment repositioning to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        new_solution = np.roll(new_solution, k)\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8335896095501438,
            0.9306342005729675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if random.random() < 0.5:\n        new_solution = np.roll(new_solution, k)\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This algorithm selects a solution from the archive based on its Pareto dominance and applies a hybrid of adaptive segment reversal with dynamic segment shifting, combining probabilistic edge insertion and node relocation to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic segment shifting\n    shift = random.randint(1, min(3, n//4))\n    if random.random() < 0.6:\n        new_solution = np.roll(new_solution, shift)\n\n    # Probabilistic edge insertion\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8932442346926597,
            1.533159077167511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic segment shifting\n    shift = random.randint(1, min(3, n//4))\n    if random.random() < 0.6:\n        new_solution = np.roll(new_solution, shift)\n\n    # Probabilistic edge insertion\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of segment reversal with probabilistic segment shifting, combining adaptive node insertion and dynamic segment rotation to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probabilistic shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, a + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node insertion\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Dynamic segment rotation\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.37715060751988183,
            1.1795249581336975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment reversal with probabilistic shifting\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        shift = random.randint(-3, 3)\n        new_pos = max(1, min(n-1, a + shift))\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive node insertion\n    if random.random() < 0.9:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Dynamic segment rotation\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{A novel algorithm that combines probabilistic segment shuffling with adaptive segment replacements to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively through dynamic segment selection and position-based swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    if random.random() > 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6082229488818365,
            2.1472946405410767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    if random.random() > 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{An algorithm that uses an entropy-based selection criterion to prioritize solutions with high diversity and potential improvement, followed by a hybrid edge-swap and segment relocation operator with adaptive segment length and position selection to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.sum(np.abs(x[1][0] - x[1][1])))  # Prioritize solutions with high objective diversity\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    # Edge-swap or segment relocation\n    if random.random() < 0.5:\n        # Edge-swap\n        j = random.randint(0, n - 1)\n        while j == i or j == i + segment_length - 1:\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation\n        k = random.randint(0, n - segment_length)\n        while k == i:\n            k = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.38712463988529777,
            1.204599142074585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.sum(np.abs(x[1][0] - x[1][1])))  # Prioritize solutions with high objective diversity\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment length\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    # Edge-swap or segment relocation\n    if random.random() < 0.5:\n        # Edge-swap\n        j = random.randint(0, n - 1)\n        while j == i or j == i + segment_length - 1:\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation\n        k = random.randint(0, n - segment_length)\n        while k == i:\n            k = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{A novel algorithm that combines adaptive segment swapping with probabilistic segment reordering to generate high-quality neighbors by intelligently selecting solutions with diverse potential for improvement and applying a dynamic local search strategy that balances exploration and exploitation in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    n = len(archive[0][0])\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected.copy()\n\n    # Determine segment boundaries\n    seg_length = max(2, min(n // 3, random.randint(1, n // 2)))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n\n    # Extract and reorder segment\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Invert with 50% probability\n    else:\n        segment = np.roll(segment, random.randint(1, len(segment)-1))  # Rotate otherwise\n\n    # Insert segment at a new position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:end],\n        new_solution[end:]\n    ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8757638436162174,
            0.3155819773674011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    n = len(archive[0][0])\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n    new_solution = selected.copy()\n\n    # Determine segment boundaries\n    seg_length = max(2, min(n // 3, random.randint(1, n // 2)))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n\n    # Extract and reorder segment\n    segment = new_solution[start:end]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Invert with 50% probability\n    else:\n        segment = np.roll(segment, random.randint(1, len(segment)-1))  # Rotate otherwise\n\n    # Insert segment at a new position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:end],\n        new_solution[end:]\n    ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective diversity and solution quality, then applies a hybrid of adaptive segment merging and probabilistic node swapping with a novel segment inversion pattern that considers both objective spaces simultaneously to explore the solution space while ensuring feasibility through an intelligent validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 / (abs(x[1][0] - x[1][1]) + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging\n    if n > 5:\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        segment1 = new_solution[a:a+2]\n        segment2 = new_solution[b:b+2]\n        merged = np.concatenate([segment1, segment2])\n        new_solution = np.concatenate([new_solution[:a], merged, new_solution[a+2:b], new_solution[b+2:]])\n\n    # Novel segment inversion pattern\n    if random.random() < 0.5:\n        k = random.randint(1, min(4, n//2))\n        for i in range(k):\n            start = random.randint(1, n-3)\n            end = min(start + random.randint(2, 4), n-1)\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                # Invert with probability based on objective improvement potential\n                cost1_before = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n                cost1_after = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[end]]\n                cost2_before = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n                cost2_after = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[end]]\n\n                if (cost1_after < cost1_before and cost2_after < cost2_before) or random.random() < 0.3:\n                    new_solution[start:end] = segment[::-1]\n\n    # Probabilistic node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        # Only swap if it improves both objectives\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution)-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7301207823189779,
            1.5287139415740967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 / (abs(x[1][0] - x[1][1]) + 1e-6)))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging\n    if n > 5:\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        segment1 = new_solution[a:a+2]\n        segment2 = new_solution[b:b+2]\n        merged = np.concatenate([segment1, segment2])\n        new_solution = np.concatenate([new_solution[:a], merged, new_solution[a+2:b], new_solution[b+2:]])\n\n    # Novel segment inversion pattern\n    if random.random() < 0.5:\n        k = random.randint(1, min(4, n//2))\n        for i in range(k):\n            start = random.randint(1, n-3)\n            end = min(start + random.randint(2, 4), n-1)\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                # Invert with probability based on objective improvement potential\n                cost1_before = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n                cost1_after = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[end]]\n                cost2_before = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n                cost2_after = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[end]]\n\n                if (cost1_after < cost1_before and cost2_after < cost2_before) or random.random() < 0.3:\n                    new_solution[start:end] = segment[::-1]\n\n    # Probabilistic node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        # Only swap if it improves both objectives\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution)-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment permutation with probabilistic node insertion, combining segment reversal with dynamic segment displacement to explore the solution space while maintaining tour feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.6:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9060121299279441,
            0.3426159620285034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.6:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm uses a hybrid approach combining segment swapping with adaptive insertion and deletion of nodes to generate diverse neighbor solutions, while ensuring feasibility through a comprehensive validation and repair mechanism that maintains node uniqueness and tour completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:c], segment1, new_solution[d:]])\n\n    if random.random() < 0.3:\n        node_to_remove = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_remove]\n\n    if len(new_solution) < n:\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6770282583057978,
            0.9944960474967957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a:c], segment1, new_solution[d:]])\n\n    if random.random() < 0.3:\n        node_to_remove = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_remove]\n\n    if len(new_solution) < n:\n        missing_nodes = set(range(n)) - set(new_solution)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective values and node importance scores, then applies a hybrid local search operator that combines edge swapping and segment rotation to generate diverse neighbor solutions while ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and node importance\n    def selection_score(sol_obj):\n        cost1, cost2 = sol_obj[1]\n        return (cost1 * cost2) / (cost1 + cost2 + 1e-6)  # Harmonic mean-like score\n\n    selected = max(archive, key=lambda x: selection_score(x))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n >= 4:\n        # Edge swapping component\n        a, b, c = sorted(random.sample(range(n), 3))\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            temp = new_solution[b]\n            new_solution[b] = new_solution[a]\n            new_solution[a] = temp\n\n        # Segment rotation component\n        if n >= 6:\n            k = random.randint(3, min(5, n//2))\n            start = random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotation = random.randint(1, k-1)\n            rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+k] = rotated\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9446722589530576,
            1.769395887851715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and node importance\n    def selection_score(sol_obj):\n        cost1, cost2 = sol_obj[1]\n        return (cost1 * cost2) / (cost1 + cost2 + 1e-6)  # Harmonic mean-like score\n\n    selected = max(archive, key=lambda x: selection_score(x))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n >= 4:\n        # Edge swapping component\n        a, b, c = sorted(random.sample(range(n), 3))\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            temp = new_solution[b]\n            new_solution[b] = new_solution[a]\n            new_solution[a] = temp\n\n        # Segment rotation component\n        if n >= 6:\n            k = random.randint(3, min(5, n//2))\n            start = random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotation = random.randint(1, k-1)\n            rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+k] = rotated\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of probabilistic sub-tour reversal with adaptive segment insertion, combining dynamic node relocation with segment rotation to explore the solution space while ensuring tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8251993372782889,
            0.3442050814628601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance, applies a hybrid of adaptive segment inversion with probabilistic node relocation, and combines edge-based swaps with dynamic segment reordering to explore the solution space while ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i:\n            j = random.randint(1, n-2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        new_solution = np.roll(new_solution, k)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5936269775241823,
            2.1126646995544434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if random.random() < 0.6:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i:\n            j = random.randint(1, n-2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.5:\n        k = random.randint(1, n-2)\n        new_solution = np.roll(new_solution, k)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm performs a hybrid of adaptive segment extraction with probabilistic node reordering, combining dynamic segment reversal and objective-aware node swapping to explore the solution space while maintaining feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    if random.random() < 0.4:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5534795067705569,
            2.4547587037086487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    if random.random() < 0.4:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{An algorithm that combines multi-objective-aware segment extraction with adaptive segment displacement and rotation, leveraging both objective spaces to guide segment manipulations while ensuring feasibility through dynamic node reinsertion and node displacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment and decide whether to rotate or reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.roll(segment, rotation)\n\n    # Calculate insertion position based on both objective spaces\n    costs = []\n    for k in range(n):\n        if k >= i and k < j:\n            continue\n        cost1 = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[k]]\n        cost2 = distance_matrix_2[new_solution[k-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[k]]\n        costs.append((cost1 + cost2, k))\n\n    if costs:\n        best_pos = min(costs, key=lambda x: x[0])[1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9252423964573329,
            2.0155689120292664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment and decide whether to rotate or reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.roll(segment, rotation)\n\n    # Calculate insertion position based on both objective spaces\n    costs = []\n    for k in range(n):\n        if k >= i and k < j:\n            continue\n        cost1 = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[k]]\n        cost2 = distance_matrix_2[new_solution[k-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[k]]\n        costs.append((cost1 + cost2, k))\n\n    if costs:\n        best_pos = min(costs, key=lambda x: x[0])[1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure all nodes are present\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and solution quality, then applies a hybrid of probabilistic segment inversion with adaptive node relocation, combining dynamic segment shifting with intelligent node repositioning to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply probabilistic segment inversion\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply adaptive node relocation\n    if random.random() < 0.7:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Apply dynamic segment shifting\n    if random.random() < 0.6:\n        k = random.randint(1, min(5, n//2))\n        segment = new_solution[-k:].copy()\n        new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    # Ensure solution validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3709504057799935,
            1.7388876676559448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply probabilistic segment inversion\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply adaptive node relocation\n    if random.random() < 0.7:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Apply dynamic segment shifting\n    if random.random() < 0.6:\n        k = random.randint(1, min(5, n//2))\n        segment = new_solution[-k:].copy()\n        new_solution = np.concatenate([segment, new_solution[:-k]])\n\n    # Ensure solution validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment swap with dynamic segment rotations to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation, guided by a hybrid objective-aware selection criterion that balances exploration and exploitation, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and dynamic segment rotations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9609159947572723,
            0.27804553508758545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid of probabilistic segment reversal with adaptive node reinsertion, combining dynamic segment rotation with controlled node swapping to explore the solution space while ensuring tour feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.4:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9434642595900194,
            0.34030675888061523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if random.random() < 0.4:\n        k = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel algorithm that uses a dynamic segment rotation with adaptive segment inversions to generate diverse neighbor solutions by selecting solutions with high potential for improvement based on a modified score function that balances objective costs and their differences.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, shift=k)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9831591620288708,
            1.516086220741272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.roll(new_solution, shift=k)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive based on its balanced improvement potential across both objectives, then applies a hybrid of adaptive segment relocation with probabilistic node clustering, combining dynamic segment rotations with targeted node swaps to explore the solution space while ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic node clustering\n    if random.random() < 0.6:\n        cluster_size = random.randint(2, min(5, n//2))\n        nodes = random.sample(range(1, n-1), cluster_size)\n        for i in range(len(nodes)-1):\n            new_solution[nodes[i]], new_solution[nodes[i+1]] = new_solution[nodes[i+1]], new_solution[nodes[i]]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.886614687741862,
            0.35558199882507324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Probabilistic node clustering\n    if random.random() < 0.6:\n        cluster_size = random.randint(2, min(5, n//2))\n        nodes = random.sample(range(1, n-1), cluster_size)\n        for i in range(len(nodes)-1):\n            new_solution[nodes[i]], new_solution[nodes[i+1]] = new_solution[nodes[i+1]], new_solution[nodes[i]]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a hybrid of adaptive segment reversal with probabilistic segment insertion, combining dynamic node displacement and segment shuffling to explore the solution space while ensuring feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic segment insertion\n    if random.random() < 0.6:\n        seg_len = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-seg_len-1)\n        segment = new_solution[start:start+seg_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node displacement\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shuffling\n    if random.random() < 0.4:\n        k = random.randint(2, min(7, n//2))\n        points = sorted(random.sample(range(1, n-1), k))\n        segments = [new_solution[points[i]:points[i+1]] for i in range(len(points)-1)]\n        random.shuffle(segments)\n        new_solution = np.concatenate([new_solution[:points[0]], *segments, new_solution[points[-1]:]])\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8488738677909704,
            1.5631755590438843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic segment insertion\n    if random.random() < 0.6:\n        seg_len = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-seg_len-1)\n        segment = new_solution[start:start+seg_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node displacement\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment shuffling\n    if random.random() < 0.4:\n        k = random.randint(2, min(7, n//2))\n        points = sorted(random.sample(range(1, n-1), k))\n        segments = [new_solution[points[i]:points[i+1]] for i in range(len(points)-1)]\n        random.shuffle(segments)\n        new_solution = np.concatenate([new_solution[:points[0]], *segments, new_solution[points[-1]:]])\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment reversal with dynamic node insertion, combining probabilistic edge swapping and segment translation to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Segment translation\n    if random.random() < 0.4:\n        seg_len = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-seg_len-1)\n        segment = new_solution[start:start+seg_len].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:]])\n        insert_pos = random.randint(1, n-seg_len)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.34699632834587135,
            1.6955735683441162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Dynamic node insertion\n    if random.random() < 0.7:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Segment translation\n    if random.random() < 0.4:\n        seg_len = random.randint(2, min(5, n//2))\n        start = random.randint(1, n-seg_len-1)\n        segment = new_solution[start:start+seg_len].copy()\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_len:]])\n        insert_pos = random.randint(1, n-seg_len)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0430839320090328,
            0.25227147340774536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0430839320090328,
            0.25227147340774536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of adaptive segment permutation with probabilistic inversion, combining dynamic segment shifting and conditional edge swapping to explore the solution space while ensuring feasibility through a multi-step validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.7:\n        segment = np.random.permutation(segment)\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    j = random.randint(0, n - segment_length)\n    while j == i:\n        j = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:j], segment, new_solution[j:]])\n\n    if random.random() < 0.4:\n        a, b = random.sample(range(1, n-1), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution[:n]\n\n",
        "score": [
            -0.8345565568571205,
            0.28442054986953735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(5, n//2))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.7:\n        segment = np.random.permutation(segment)\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    j = random.randint(0, n - segment_length)\n    while j == i:\n        j = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:j], segment, new_solution[j:]])\n\n    if random.random() < 0.4:\n        a, b = random.sample(range(1, n-1), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel algorithm that employs a hybrid segment rotation with dynamic segment inversions and adaptive node swaps, guided by a Pareto dominance-based score function, to generate high-quality neighbor solutions while ensuring feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9701088763638454,
            0.2230820655822754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions and adaptive segment swaps to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function that considers both objective values and their relative improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n    else:\n        k = random.randint(0, n-1)\n        segment = new_solution[k:]\n        new_solution = np.concatenate([new_solution[:k], segment])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5841415529051619,
            1.3941930532455444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n    else:\n        k = random.randint(0, n-1)\n        segment = new_solution[k:]\n        new_solution = np.concatenate([new_solution[:k], segment])\n\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{An algorithm that employs a hybrid of segment inversion and node relocation with adaptive segment length selection and objective-aware segment insertion to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through dynamic segment manipulations and non-uniform node repositioning.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insertion_point = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    if random.random() < 0.3:\n        node_to_relocate = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_relocate)[0][0])\n        new_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    return new_solution\n\n",
        "score": [
            -0.9671540501251832,
            1.3817376494407654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insertion_point = random.randint(0, n - segment_length)\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    new_solution = np.concatenate([new_solution[:insertion_point], segment, new_solution[insertion_point:]])\n\n    if random.random() < 0.3:\n        node_to_relocate = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_relocate)[0][0])\n        new_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{An algorithm that combines multi-objective-aware segment swaps with dynamic segment rotations and probabilistic segment extensions, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        extend_length = random.randint(1, min(3, n - (j - i)))\n        extend_segment = new_solution[(j + 1):(j + 1 + extend_length)]\n        new_solution = np.concatenate([new_solution[:i], extend_segment, new_solution[i:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0251979004270682,
            0.25304561853408813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if random.random() < 0.3:\n        extend_length = random.randint(1, min(3, n - (j - i)))\n        extend_segment = new_solution[(j + 1):(j + 1 + extend_length)]\n        new_solution = np.concatenate([new_solution[:i], extend_segment, new_solution[i:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm combines multi-objective-aware node clustering with dynamic segment inversion and adaptive segment reinsertion, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on both objectives\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Randomly select clusters to manipulate\n    if len(clusters) > 1:\n        idx1, idx2 = random.sample(range(len(clusters)), 2)\n        cluster1, cluster2 = clusters[idx1], clusters[idx2]\n\n        # Dynamic segment inversion with probability\n        if random.random() < 0.6:\n            cluster1 = cluster1[::-1]\n            cluster2 = cluster2[::-1]\n\n        # Swap clusters\n        clusters[idx1], clusters[idx2] = clusters[idx2], clusters[idx1]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(clusters)\n\n    # Adaptive segment reinsertion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        pos = random.randint(0, i)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:i], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9702227390086333,
            1.3579646348953247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on both objectives\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Randomly select clusters to manipulate\n    if len(clusters) > 1:\n        idx1, idx2 = random.sample(range(len(clusters)), 2)\n        cluster1, cluster2 = clusters[idx1], clusters[idx2]\n\n        # Dynamic segment inversion with probability\n        if random.random() < 0.6:\n            cluster1 = cluster1[::-1]\n            cluster2 = cluster2[::-1]\n\n        # Swap clusters\n        clusters[idx1], clusters[idx2] = clusters[idx2], clusters[idx1]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(clusters)\n\n    # Adaptive segment reinsertion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        pos = random.randint(0, i)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:i], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective balance and applies a hybrid of probabilistic segment reversal with dynamic segment displacement, combining adaptive segment rotation and intelligent node insertion to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if random.random() < 0.6:\n        rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel objective score function that emphasizes diversity and balance, then applies a hybrid of dynamic segment shuffling with probabilistic node swaps and adaptive segment insertion to generate high-quality neighbors while ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.8:\n        random.shuffle(segment)\n\n    if random.random() < 0.5:\n        segment = np.roll(segment, random.randint(1, len(segment)-1) if len(segment) > 1 else 0)\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9477020087623467,
            0.2324957251548767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.8:\n        random.shuffle(segment)\n\n    if random.random() < 0.5:\n        segment = np.roll(segment, random.randint(1, len(segment)-1) if len(segment) > 1 else 0)\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{An algorithm that employs a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection, while also incorporating a dynamic segment extraction strategy that prioritizes segments with high potential for improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9497268021937585,
            0.24911260604858398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() < 0.6:\n        segment = segment[::-1]\n\n    k = random.randint(0, n-1)\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that employs a diversity-aware selection criterion to prioritize solutions with high potential for improvement, followed by a hybrid segment relocation and inversion operator with dynamic segment length and adaptive position selection to generate diverse neighbor solutions while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) ** 2 / (x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(6, n//3))\n    i = random.randint(0, n - segment_length)\n    segment = new_solution[i:i+segment_length]\n\n    if random.random() < 0.6:\n        new_solution[i:i+segment_length] = segment[::-1]\n\n    k = random.randint(0, n - segment_length)\n    while k == i:\n        k = random.randint(0, n - segment_length)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{An algorithm that employs a dynamic segment exchange strategy with objective-aware segment selection and probabilistic segment rotation to generate diverse neighbor solutions, combining both objectives' information to guide the search while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and adaptive segment exchange probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on objectives\n    obj1, obj2 = max(archive, key=lambda x: x[1][0] + x[1][1])[1]\n    len1 = max(2, int(n * (obj1 / (obj1 + obj2))))\n    len2 = max(2, int(n * (obj2 / (obj1 + obj2))))\n\n    # Select two segments with different lengths\n    i = random.randint(0, n - len1)\n    j = random.randint(0, n - len2)\n\n    # Extract segments\n    seg1 = new_solution[i:i+len1]\n    seg2 = new_solution[j:j+len2]\n\n    # Probabilistically rotate segments\n    if random.random() < 0.5:\n        seg1 = np.roll(seg1, random.randint(1, len(seg1)-1))\n    if random.random() < 0.5:\n        seg2 = np.roll(seg2, random.randint(1, len(seg2)-1))\n\n    # Exchange segments\n    new_solution = np.concatenate([new_solution[:i], seg2, new_solution[i+len1:]])\n    new_solution = np.concatenate([new_solution[:j], seg1, new_solution[j+len2:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8872226863473631,
            0.47614383697509766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on objectives\n    obj1, obj2 = max(archive, key=lambda x: x[1][0] + x[1][1])[1]\n    len1 = max(2, int(n * (obj1 / (obj1 + obj2))))\n    len2 = max(2, int(n * (obj2 / (obj1 + obj2))))\n\n    # Select two segments with different lengths\n    i = random.randint(0, n - len1)\n    j = random.randint(0, n - len2)\n\n    # Extract segments\n    seg1 = new_solution[i:i+len1]\n    seg2 = new_solution[j:j+len2]\n\n    # Probabilistically rotate segments\n    if random.random() < 0.5:\n        seg1 = np.roll(seg1, random.randint(1, len(seg1)-1))\n    if random.random() < 0.5:\n        seg2 = np.roll(seg2, random.randint(1, len(seg2)-1))\n\n    # Exchange segments\n    new_solution = np.concatenate([new_solution[:i], seg2, new_solution[i+len1:]])\n    new_solution = np.concatenate([new_solution[:j], seg1, new_solution[j+len2:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{An algorithm that employs an adaptive segment relocation and rotation strategy, guided by a dynamic objective weighting that balances exploration and exploitation, to generate diverse neighbor solutions by intelligently extracting and reinserting segments while ensuring feasibility through node validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment and optionally reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Remove the segment and reinsert it at a new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate the segment within the solution\n    if random.random() < 0.3:\n        k = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, k)\n\n    # Repair the solution if nodes are missing or duplicated\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.897896568736004,
            1.5996168851852417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Extract a segment and optionally reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Remove the segment and reinsert it at a new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate the segment within the solution\n    if random.random() < 0.3:\n        k = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, k)\n\n    # Repair the solution if nodes are missing or duplicated\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of probabilistic segment rotation with adaptive node insertion, combining segment reversal with dynamic node swapping to explore the solution space while maintaining tour feasibility through comprehensive validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n\n    if random.random() < 0.5:\n        k = random.randint(0, len(segment)-1)\n        segment = np.concatenate([segment[k:], segment[:k]])\n\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm combines a dynamic segment relocation with adaptive segment inversions to generate high-quality neighbor solutions by intelligently selecting segments based on their potential to improve both objectives, while ensuring feasibility through a validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n\n    if random.random() < 0.5:\n        new_solution[a:b] = segment[::-1]\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if c < len(new_solution):\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective balance and applies a novel hybrid of adaptive segment permutation with dynamic node reinsertion, combining probabilistic segment inversion with segment shuffling to explore the solution space while ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node_i = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node_i)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9844844775337641,
            1.839251458644867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], x[1][1]) + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node_i = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node_i)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and applies a hybrid of segment rearrangement with dynamic segment reversal, combining adaptive segment shifting and probabilistic edge swapping to explore the solution space while maintaining feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8092043855626111,
            0.36994922161102295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(3, pos-1), min(3, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{An algorithm that leverages a multi-objective-aware k-segment extraction and adaptive segment permutation with dynamic segment flipping, guided by a Pareto-frontier aware selection metric, to generate high-quality neighbor solutions by exploring non-contiguous segment manipulations and balancing objective improvements through a weighted probabilistic approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine number of segments to extract (2-4 segments)\n    k = random.randint(2, 4)\n    segment_indices = sorted(random.sample(range(n), k))\n\n    # Extract segments and collect them in a list\n    segments = []\n    for i in range(0, k, 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1] if i+1 < k else n\n        segment = new_solution[start:end]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Randomly flip segment\n        segments.append(segment)\n\n    # Shuffle segments and reinsert them at random positions\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure all nodes are present (repair if needed)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Randomly permute small segments for additional diversification\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.9392723507781834,
            2.989674210548401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine number of segments to extract (2-4 segments)\n    k = random.randint(2, 4)\n    segment_indices = sorted(random.sample(range(n), k))\n\n    # Extract segments and collect them in a list\n    segments = []\n    for i in range(0, k, 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1] if i+1 < k else n\n        segment = new_solution[start:end]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Randomly flip segment\n        segments.append(segment)\n\n    # Shuffle segments and reinsert them at random positions\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure all nodes are present (repair if needed)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Randomly permute small segments for additional diversification\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that combines a hybrid segment rotation with dynamic segment inversions to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This new algorithm combines a hybrid segment rotation with dynamic segment inversions, guided by objective-specific distance matrices, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space more effectively by selecting solutions with high potential for improvement based on a modified score function that considers both objectives and their relative distances.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9339663338488282,
            0.2324143648147583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that combines adaptive segment relocations with dynamic segment inversions to create diverse neighbor solutions while preserving feasibility and exploring the solution space more effectively through probabilistic segment selection and rotation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A novel algorithm that employs adaptive segment relocations with dynamic segment rotations and probabilistic node swaps to generate diverse neighbor solutions while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[j:]])\n\n    for _ in range(random.randint(1, 3)):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8013926604917572,
            0.23460716009140015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    if random.random() > 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[j:]])\n\n    for _ in range(random.randint(1, 3)):\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of segment rotation with dynamic segment inversion, combining adaptive segment displacement and probabilistic node swapping to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment rotation with dynamic inversion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Adaptive segment displacement\n    pos = random.randint(1, n-1)\n    displacement = random.randint(-min(5, pos-1), min(5, n-pos-1))\n    new_pos = max(1, min(n-1, pos + displacement))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic node swapping\n    if random.random() < 0.8:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a hybrid of adaptive segment reversal with probabilistic node insertion, combining dynamic segment displacement and segment-wise mutation to explore the solution space while ensuring feasibility through systematic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        new_solution[a:b] = segment[::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment displacement\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Segment-wise mutation\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.40198287750435147,
            1.2649226188659668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    if random.random() < 0.7:\n        new_solution[a:b] = segment[::-1]\n\n    # Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(1, n-1), 2)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment displacement\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Segment-wise mutation\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b].copy()\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n    # Systematic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing])\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{An algorithm that combines a multi-objective-aware segment extraction with adaptive segment reinsertion and rotation, guided by a weighted combination of both objectives, to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{An algorithm that employs a multi-objective-aware hybrid of adaptive segment inversion and node swapping, guided by a dynamic weight adaptation mechanism that prioritizes segments with high potential for improvement in both objectives, while ensuring feasibility through a node reassignment mechanism that maintains tour continuity and completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective-aware selection\n    segment_size = max(2, random.randint(1, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive segment manipulation: invert or swap nodes\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]  # Invert segment\n    else:\n        # Swap nodes within segment based on distance matrices\n        for i in range(start, end):\n            if random.random() < 0.3:\n                j = random.randint(start, end - 1)\n                if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic node reassignment to maintain feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour by removing duplicates and reinserting missing nodes\n    new_solution = np.array([x for x in new_solution if x in range(n)])\n    if len(new_solution) < n:\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n",
        "score": [
            -0.9758701077183095,
            1.8326953053474426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on objective-aware selection\n    segment_size = max(2, random.randint(1, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive segment manipulation: invert or swap nodes\n    if random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]  # Invert segment\n    else:\n        # Swap nodes within segment based on distance matrices\n        for i in range(start, end):\n            if random.random() < 0.3:\n                j = random.randint(start, end - 1)\n                if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic node reassignment to maintain feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure circular tour by removing duplicates and reinserting missing nodes\n    new_solution = np.array([x for x in new_solution if x in range(n)])\n    if len(new_solution) < n:\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{An algorithm that combines a dynamic segment extraction with adaptive segment reinsertion and rotation to generate diverse neighbor solutions while maintaining feasibility and exploring the solution space through non-uniform segment manipulations and objective-aware selection.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    if k < len(new_solution):\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{An algorithm that employs a hybrid of adaptive segment inversion and dynamic segment relocation, guided by objective-aware selection and non-uniform segment manipulation, to generate diverse neighbor solutions while ensuring feasibility and exploring the solution space through probabilistic segment operations and objective-balanced selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < i:\n        new_solution = np.concatenate([segment, new_solution[:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8407512157597653,
            1.0540974140167236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    segment = new_solution[i:j]\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    if k < i:\n        new_solution = np.concatenate([segment, new_solution[:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n        if k < len(new_solution):\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    }
]